package rolit.view.layout;

import java.awt.*;

/**
 * @author Pieter Bos
 *
 * Lays out exactly two components stacked vertically, splitting at a given distance from the top or bottom.
 */
public class VSplitLayoutManager implements LayoutManager {
    public enum VSplitType {
        Top,
        Bottom
    }

    private static final int DEFAULT_SPLIT = 24;
    private static final VSplitType DEFAULT_TYPE = VSplitType.Top;

    private VSplitType splitType;
    private int split;

    public VSplitLayoutManager(int split, VSplitType type) {
        this.splitType = type;
        this.split = split;
    }

    public VSplitLayoutManager(int split) {
        this(split, DEFAULT_TYPE);
    }

    public VSplitLayoutManager(VSplitType type) {
        this(DEFAULT_SPLIT, type);
    }

    public VSplitLayoutManager() {
        this(DEFAULT_TYPE);
    }

    @Override
    public void addLayoutComponent(String name, Component comp) {
    }

    @Override
    public void removeLayoutComponent(Component comp) {
    }

    @Override
    public Dimension preferredLayoutSize(Container parent) {
        return parent.getParent().getMinimumSize();
    }

    @Override
    public Dimension minimumLayoutSize(Container parent) {
        Dimension size1 = parent.getComponent(0).getMinimumSize();
        Dimension size2 = parent.getComponent(1).getMinimumSize();
        return new Dimension(Math.max(size1.width, size2.width), size1.height + size2.height);
    }

    @Override
    public void layoutContainer(Container parent) {
        Dimension parentSize = parent.getSize();
        Dimension size1 = parent.getComponent(0).getPreferredSize();
        Dimension size2 = parent.getComponent(1).getPreferredSize();

        if(splitType == VSplitType.Top) {
            parent.getComponent(0).setBounds(0, 0, parentSize.width, split);
            parent.getComponent(1).setBounds(0, split, parentSize.width, parentSize.height - split);
        } else {
            parent.getComponent(0).setBounds(0, 0, parentSize.width, parentSize.height - split);
            parent.getComponent(1).setBounds(0, parentSize.height - split, parentSize.width, split);
        }
    }
}
package rolit.view.layout;

import java.awt.*;

/**
 * @author Pieter Bos
 *
 * Lays out all components horizontally with a given gap, aligned to the top.
 */
public class HBoxLayoutManager implements LayoutManager {
    private static final int DEFAULT_GAP = 8;

    private int gap;

    public HBoxLayoutManager(int gap) {
        this.gap = gap;
    }

    public HBoxLayoutManager() {
        this(DEFAULT_GAP);
    }

    @Override
    public void addLayoutComponent(String name, Component comp) {
    }

    @Override
    public void removeLayoutComponent(Component comp) {
    }

    @Override
    public Dimension preferredLayoutSize(Container parent) {
        int max = 0;
        int totalWidth = 0;

        for(int i = parent.getComponentCount() - 1; i >= 0; i--) {
            if(parent.getComponent(i).getMinimumSize().height > max) {
                max = parent.getComponent(i).getMinimumSize().height;
            }

            totalWidth += parent.getComponent(i).getMinimumSize().width;
        }

        return new Dimension(totalWidth + (parent.getComponentCount() - 1) * gap, max);
    }

    @Override
    public Dimension minimumLayoutSize(Container parent) {
        return preferredLayoutSize(parent);
    }

    @Override
    public void layoutContainer(Container parent) {
        int currentX = 0;

        int components = parent.getComponentCount();

        for(int i = 0; i < components; i++) {
            Component component = parent.getComponent(i);
            component.setBounds(currentX, 0, component.getPreferredSize().width, component.getPreferredSize().height);

            currentX += component.getPreferredSize().width + gap;
        }
    }
}
package rolit.view.layout;

import java.awt.*;

/**
 * @author Pieter Bos
 *
 * Always centers a single component.
 */
public class CenterLayoutManager implements LayoutManager {
    @Override
    public void addLayoutComponent(String name, Component comp) {
    }

    @Override
    public void removeLayoutComponent(Component comp) {
    }

    @Override
    public Dimension preferredLayoutSize(Container parent) {
        Component component = parent.getComponent(0);
        return component.getMinimumSize();
    }

    @Override
    public Dimension minimumLayoutSize(Container parent) {
        return preferredLayoutSize(parent);
    }

    @Override
    public void layoutContainer(Container parent) {
        Dimension parentSize = parent.getSize();
        Component component = parent.getComponent(0);
        Dimension componentSize = component.getPreferredSize();
        component.setBounds((parentSize.width - componentSize.width) / 2, (parentSize.height - componentSize.height) / 2, componentSize.width, componentSize.height);
    }
}
package rolit.view.layout;

import java.awt.*;

/**
 * @author Pieter Bos
 *
 * Stacks all components vertically with a given gap. The components are left-aligned.
 */
public class VBoxLayoutManager implements LayoutManager {
    private static final int DEFAULT_GAP = 8;

    private int gap;

    public VBoxLayoutManager(int gap) {
        this.gap = gap;
    }

    public VBoxLayoutManager() {
        this(DEFAULT_GAP);
    }

    @Override
    public void addLayoutComponent(String name, Component comp) {
    }

    @Override
    public void removeLayoutComponent(Component comp) {
    }

    @Override
    public Dimension preferredLayoutSize(Container parent) {
        int max = 0;
        int totalHeight = 0;

        for(int i = parent.getComponentCount() - 1; i >= 0; i--) {
            if(parent.getComponent(i).getMinimumSize().width > max) {
                max = parent.getComponent(i).getMinimumSize().width;
            }

            totalHeight += parent.getComponent(i).getMinimumSize().height;
        }

        return new Dimension(max, totalHeight + (parent.getComponentCount() - 1) * gap);
    }

    @Override
    public Dimension minimumLayoutSize(Container parent) {
        return preferredLayoutSize(parent);
    }

    @Override
    public void layoutContainer(Container parent) {
        int currentY = 0;

        int components = parent.getComponentCount();

        for(int i = 0; i < components; i++) {
            Component component = parent.getComponent(i);
            component.setBounds(0, currentY, component.getPreferredSize().width, component.getPreferredSize().height);

            currentY += component.getPreferredSize().height + gap;
        }
    }
}
package rolit.view.layout;

import java.awt.*;

public class HSplitLayoutManager implements LayoutManager {
    public enum HSplitType {
        Left,
        Right
    }

    private static final int DEFAULT_SPLIT = 24;
    private static final HSplitType DEFAULT_TYPE = HSplitType.Left;

    private HSplitType splitType;
    private int split;

    public HSplitLayoutManager(int split, HSplitType type) {
        this.splitType = type;
        this.split = split;
    }

    public HSplitLayoutManager(int split) {
        this(split, DEFAULT_TYPE);
    }

    public HSplitLayoutManager(HSplitType type) {
        this(DEFAULT_SPLIT, type);
    }

    public HSplitLayoutManager() {
        this(DEFAULT_TYPE);
    }

    @Override
    public void addLayoutComponent(String name, Component comp) {
    }

    @Override
    public void removeLayoutComponent(Component comp) {
    }

    @Override
    public Dimension preferredLayoutSize(Container parent) {
        return parent.getParent().getMinimumSize();
    }

    @Override
    public Dimension minimumLayoutSize(Container parent) {
        Dimension size1 = parent.getComponent(0).getMinimumSize();
        Dimension size2 = parent.getComponent(1).getMinimumSize();
        return new Dimension(size1.width + size2.width, Math.max(size1.height, size2.height));
    }

    @Override
    public void layoutContainer(Container parent) {
        Dimension parentSize = parent.getSize();
        Dimension size1 = parent.getComponent(0).getPreferredSize();
        Dimension size2 = parent.getComponent(1).getPreferredSize();

        if(splitType == HSplitType.Left) {
            parent.getComponent(0).setBounds(0, 0, split, parentSize.height);
            parent.getComponent(1).setBounds(split, 0, parentSize.width - split, parentSize.height);
        } else {
            parent.getComponent(0).setBounds(0, 0, parentSize.width - split, parentSize.height);
            parent.getComponent(1).setBounds(parentSize.width - split, 0, split, parentSize.height);
        }
    }
}
package rolit.view.layout;

import java.awt.*;

/**
 * @author Pieter Bos
 *
 * Lays out exactly two components left and right, with a given minimum gap.
 */
public class LeftRightLayoutManager implements LayoutManager {
    private static final int DEFAULT_MINIMUM_GAP = 8;

    private int minimumGap;

    public LeftRightLayoutManager(int minimumGap) {
        this.minimumGap = minimumGap;
    }

    public LeftRightLayoutManager() {
        this(DEFAULT_MINIMUM_GAP);
    }

    @Override
    public void addLayoutComponent(String name, Component comp) {
    }

    @Override
    public void removeLayoutComponent(Component comp) {
    }

    @Override
    public Dimension preferredLayoutSize(Container parent) {
        int width = Math.max(minimumLayoutSize(parent).width, parent.getParent().getPreferredSize().width);
        int height = minimumLayoutSize(parent).height;
        return new Dimension(width, height);
    }

    @Override
    public Dimension minimumLayoutSize(Container parent) {
        Dimension size1 = parent.getComponent(0).getPreferredSize();
        Dimension size2 = parent.getComponent(1).getPreferredSize();
        return new Dimension(size1.width + size2.width + minimumGap, Math.max(size1.height, size2.height));
    }

    @Override
    public void layoutContainer(Container parent) {
        int height = minimumLayoutSize(parent).height;
        Dimension size1 = parent.getComponent(0).getPreferredSize();
        Dimension size2 = parent.getComponent(1).getPreferredSize();
        parent.getComponent(0).setBounds(0, (height - size1.height) / 2, size1.width, size1.height);
        parent.getComponent(1).setBounds(parent.getSize().width - size2.width, (height - size2.height) / 2, size2.width, size2.height);
    }
}
package rolit.view.layout;

import java.awt.*;

public class GridLayoutManager implements LayoutManager {
    private static final int DEFAULT_GAP = 8;

    private int width;
    private int height;
    private int gap;

    public GridLayoutManager(int width, int height, int gap) {
        this.width = width;
        this.height = height;
        this.gap = gap;
    }

    public GridLayoutManager(int width, int height) {
        this(width, height, DEFAULT_GAP);
    }

    @Override
    public void addLayoutComponent(String name, Component comp) {
    }

    @Override
    public void removeLayoutComponent(Component comp) {
    }

    @Override
    public Dimension preferredLayoutSize(Container parent) {
        int[] x = new int[width + 1];
        int[] y = new int[height + 1];

        for(int i = 0; i < height; i++) {
            int maxHeight = 0;

            for(int j = 0; j < width; j++) {
                Dimension size = parent.getComponent(j + i * width).getPreferredSize();
                if(size.height > maxHeight) {
                    maxHeight = size.height;
                }
            }

            y[i + 1] = y[i] + maxHeight;
        }

        for(int i = 0; i < width; i++) {
            int maxWidth = 0;

            for(int j = 0; j < height; j++) {
                Dimension size = parent.getComponent(i + j * width).getPreferredSize();
                if(size.width > maxWidth) {
                    maxWidth = size.width;
                }
            }

            x[i + 1] = x[i] + maxWidth;
        }

        return new Dimension(x[width] + (width - 1) * gap, y[height] + (height - 1) * gap);
    }

    @Override
    public Dimension minimumLayoutSize(Container parent) {
        return preferredLayoutSize(parent);
    }

    @Override
    public void layoutContainer(Container parent) {
        int[] x = new int[width + 1];
        int[] y = new int[height + 1];

        for(int i = 0; i < height; i++) {
            int maxHeight = 0;

            for(int j = 0; j < width; j++) {
                Dimension size = parent.getComponent(j + i * width).getPreferredSize();
                if(size.height > maxHeight) {
                    maxHeight = size.height;
                }
            }

            y[i + 1] = y[i] + maxHeight + gap;
        }

        for(int i = 0; i < width; i++) {
            int maxWidth = 0;

            for(int j = 0; j < height; j++) {
                Dimension size = parent.getComponent(i + j * width).getPreferredSize();
                if(size.width > maxWidth) {
                    maxWidth = size.width;
                }
            }

            x[i + 1] = x[i] + maxWidth + gap;
        }

        for(int i = 0; i < width; i++) {
            for(int j = 0; j < height; j++) {
                parent.getComponent(i + j * width).setBounds(x[i], y[j], x[i + 1] - x[i] - gap, y[j + 1] - y[j] - gap);
            }
        }
    }
}
package rolit.view.client;

import rolit.view.layout.VSplitLayoutManager;

import javax.swing.*;

public class ChatPanel extends JPanel {
    private JTextArea textArea;
    private JTextField textField;

    public ChatPanel() {
        setLayout(new VSplitLayoutManager(VSplitLayoutManager.VSplitType.Bottom));

        textArea = new JTextArea();
        textField = new JTextField();

        add(textArea);
        add(textField);
    }
}
package rolit.view.client;

import rolit.view.layout.*;

import javax.swing.*;
import java.awt.*;

public class GameListPanel extends JPanel {
    public GameListPanel() {
        setLayout(new VSplitLayoutManager(VSplitLayoutManager.VSplitType.Top));

        JPanel mainPanel = new JPanel();
        mainPanel.setLayout(new HSplitLayoutManager(200, HSplitLayoutManager.HSplitType.Right));

        JPanel gamesPanel = new JPanel();
        gamesPanel.setLayout(new VSplitLayoutManager(VSplitLayoutManager.VSplitType.Bottom));

        JPanel listPanel = new JPanel();
        listPanel.setLayout(new GridLayoutManager(3, 3));

        listPanel.add(new JLabel("Spelmaker"));
        listPanel.add(new JLabel("Aantal spelers"));
        listPanel.add(Box.createGlue());
        listPanel.add(new JLabel("Pieter"));
        listPanel.add(new JLabel("2"));
        listPanel.add(new JButton("Meedoen"));
        listPanel.add(new JLabel("Martijn"));
        listPanel.add(new JLabel("4"));
        JButton joinGameButton = new JButton("Meedoen");
        joinGameButton.setEnabled(false);
        listPanel.add(joinGameButton);


        JPanel buttonsArrayPanel = new JPanel();
        buttonsArrayPanel.setLayout(new HBoxLayoutManager());

        JButton createGameButton = new JButton("Maak spel");
        JButton challengeButton = new JButton("Daag een speler uit");

        buttonsArrayPanel.add(createGameButton);
        buttonsArrayPanel.add(challengeButton);

        gamesPanel.add(listPanel);
        gamesPanel.add(buttonsArrayPanel);

        mainPanel.add(gamesPanel);
        mainPanel.add(new ChatPanel());

        add(new ServerPanel());
        add(mainPanel);
    }

    public static void main(String[] args) throws ClassNotFoundException, UnsupportedLookAndFeelException, InstantiationException, IllegalAccessException {
        UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
        JFrame frame = new JFrame();
        frame.getContentPane().add(new GameListPanel());
        frame.setSize(640, 480);
        frame.setMinimumSize(new Dimension(640, 480));
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.setVisible(true);
    }
}
package rolit.view.client;

import rolit.view.layout.CenterLayoutManager;
import rolit.view.layout.LeftRightLayoutManager;
import rolit.view.layout.VBoxLayoutManager;

import javax.swing.*;
import java.awt.*;

/**
 * @author Pieter Bos
 *
 * Panel to connect to a server.
 */
public class ConnectPanel extends JPanel {
    private static final int DEFAULT_TEXT_FIELD_WIDTH = 200;
    private static final int DEFAULT_TEXT_FIELD_HEIGHT = 24;

    private JTextField hostname;
    private JTextField userName;
    private JButton loginButton;

    public ConnectPanel() {
        setLayout(new CenterLayoutManager());

        JPanel panel = new JPanel();
        panel.setLayout(new VBoxLayoutManager());

        JLabel logInLabel = new JLabel("Verbinden met server");
        panel.add(logInLabel);

        JPanel panel1 = new JPanel();
        panel1.setLayout(new LeftRightLayoutManager());

        JLabel hostnameLabel = new JLabel("Hostname");
        hostname = new JTextField();
        hostname.setPreferredSize(new Dimension(DEFAULT_TEXT_FIELD_WIDTH, DEFAULT_TEXT_FIELD_HEIGHT));
        panel1.add(hostnameLabel);
        panel1.add(hostname);
        panel.add(panel1);

        JPanel panel2 = new JPanel();
        panel2.setLayout(new LeftRightLayoutManager());

        JLabel userNameLabel = new JLabel("Gebruikersnaam");
        userName = new JTextField();
        userName.setPreferredSize(new Dimension(DEFAULT_TEXT_FIELD_WIDTH, DEFAULT_TEXT_FIELD_HEIGHT));
        panel2.add(userNameLabel);
        panel2.add(userName);
        panel.add(panel2);

        JPanel panel3 = new JPanel();
        panel3.setLayout(new LeftRightLayoutManager());


        loginButton = new JButton("Inloggen");
        panel3.add(Box.createGlue());
        panel3.add(loginButton);
        panel.add(panel3);

        add(panel);
    }

    public static void main(String[] args) throws ClassNotFoundException, UnsupportedLookAndFeelException, InstantiationException, IllegalAccessException {
        UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
        JFrame window = new JFrame();
        window.getContentPane().add(new ConnectPanel());
        window.setSize(640, 480);
        window.setMinimumSize(new Dimension(640, 480));
        window.setVisible(true);
    }
}
package rolit.view.client;

import rolit.view.layout.HBoxLayoutManager;
import rolit.view.layout.LeftRightLayoutManager;

import javax.swing.*;

public class ServerPanel extends JPanel {
    JLabel serverConnectionLabel;
    JLabel userNameLabel;
    JButton logoutButton;

    public ServerPanel() {
        setLayout(new LeftRightLayoutManager());

        serverConnectionLabel = new JLabel("Verbonden met pieterbos.me:667");
        add(serverConnectionLabel);

        JPanel rightPanel = new JPanel();
        rightPanel.setLayout(new HBoxLayoutManager());

        userNameLabel = new JLabel("Ingelogd als Pieter");
        logoutButton = new JButton("Uitloggen");

        rightPanel.add(userNameLabel);
        rightPanel.add(logoutButton);

        add(rightPanel);
    }
}
package rolit.view.client;

import javax.swing.*;

public class MainView extends JFrame {
    
}
package rolit.view.client;

import rolit.view.layout.CenterLayoutManager;
import rolit.view.layout.GridLayoutManager;
import rolit.view.layout.HBoxLayoutManager;
import rolit.view.layout.VBoxLayoutManager;

import javax.swing.*;
import java.awt.*;

public class ChallengePanel extends JPanel {
    public ChallengePanel() {
        setLayout(new CenterLayoutManager());
        setSize(new Dimension(300, 1));

        JPanel mainPanel = new JPanel();
        mainPanel.setLayout(new VBoxLayoutManager());

        JLabel challengeLabel = new JLabel("Daag mensen uit:");

        JPanel challengePanel = new JPanel();
        challengePanel.setLayout(new HBoxLayoutManager());

        JComboBox players = new JComboBox<String>();
        players.addItem("Pieter");
        players.addItem("Martijn");

        JButton challengeButton = new JButton("Uitdagen");

        challengePanel.add(players);
        challengePanel.add(challengeButton);

        JLabel challengedPeople = new JLabel("Uitgedaagde mensen:");

        JPanel challengedPanel = new JPanel();
        challengedPanel.setLayout(new GridLayoutManager(2, 2));
        challengedPanel.add(new JLabel("Laurens"));
        challengedPanel.add(new JButton("Verwijder"));
        challengedPanel.add(new JLabel("Sophie"));
        challengedPanel.add(new JButton("Verwijder"));

        mainPanel.add(challengeLabel);
        mainPanel.add(challengePanel);
        mainPanel.add(Box.createGlue());
        mainPanel.add(challengedPeople);
        mainPanel.add(challengedPanel);

        add(mainPanel);
    }

    public static void main(String[] args) throws ClassNotFoundException, UnsupportedLookAndFeelException, InstantiationException, IllegalAccessException {
        UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
        JFrame frame = new JFrame();
        frame.getContentPane().add(new ChallengePanel());
        frame.setSize(640, 480);
        frame.setMinimumSize(new Dimension(640, 480));
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.setVisible(true);
    }
}
package rolit.view.client;

import rolit.view.layout.VBoxLayoutManager;
import rolit.view.layout.VSplitLayoutManager;

import javax.swing.*;
import java.awt.*;

public class WaitPanel extends JPanel {
    public WaitPanel() {
        setLayout(new VSplitLayoutManager(VSplitLayoutManager.VSplitType.Top));

        JPanel mainPanel = new JPanel();
        mainPanel.setLayout(new VBoxLayoutManager());

        JLabel status = new JLabel("Het spel van Pieter is nog niet begonnen. Er zitten nu 3 mensen in het spel.");
        JButton actionButton = new JButton("Beginnen");
        actionButton.setEnabled(false);

        mainPanel.add(status);
        mainPanel.add(actionButton);

        add(new ServerPanel());
        add(mainPanel);
    }

    public static void main(String[] args) throws ClassNotFoundException, UnsupportedLookAndFeelException, InstantiationException, IllegalAccessException {
        UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
        JFrame frame = new JFrame();
        frame.getContentPane().add(new WaitPanel());
        frame.setSize(640, 480);
        frame.setMinimumSize(new Dimension(640, 480));
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.setVisible(true);
    }
}
package rolit.view.client;

import rolit.view.layout.GridLayoutManager;
import rolit.view.layout.HSplitLayoutManager;
import rolit.view.layout.VSplitLayoutManager;

import javax.swing.*;
import java.awt.*;

public class GamePanel extends JPanel {
    public GamePanel() {
        setLayout(new VSplitLayoutManager(VSplitLayoutManager.VSplitType.Top));

        JPanel mainPanel = new JPanel();
        mainPanel.setLayout(new HSplitLayoutManager(200, HSplitLayoutManager.HSplitType.Right));

        JPanel gamePanel = new JPanel();
        gamePanel.setLayout(new GridLayout(8, 8));

        JButton[][] buttons = new JButton[8][8];

        for(int y = 0; y < 8; y++) {
            for(int x = 0; x < 8; x++) {
                buttons[x][y] = new JButton("(" + x + "; " + y + ")");
                gamePanel.add(buttons[x][y]);
            }
        }

        JPanel sideBarPanel = new JPanel();
        sideBarPanel.setLayout(new VSplitLayoutManager(100, VSplitLayoutManager.VSplitType.Top));

        JPanel scorePanel = new JPanel();
        scorePanel.setLayout(new GridLayoutManager(2, 4));

        scorePanel.add(new JLabel("Pieter"));
        scorePanel.add(new JLabel("0"));
        scorePanel.add(new JLabel("Martijn"));
        scorePanel.add(new JLabel("0"));
        scorePanel.add(new JLabel("Laurens"));
        scorePanel.add(new JLabel("0"));
        scorePanel.add(new JLabel("Sophie"));
        scorePanel.add(new JLabel("0"));

        sideBarPanel.add(scorePanel);
        sideBarPanel.add(new ChatPanel());

        mainPanel.add(gamePanel);
        mainPanel.add(sideBarPanel);

        add(new ServerPanel());
        add(mainPanel);
    }

    public static void main(String[] args) throws ClassNotFoundException, UnsupportedLookAndFeelException, InstantiationException, IllegalAccessException {
        UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
        JFrame frame = new JFrame();
        frame.getContentPane().add(new GamePanel());
        frame.setSize(640, 480);
        frame.setMinimumSize(new Dimension(640, 480));
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.setVisible(true);
    }
}
package rolit.model.networking.common;

import java.io.*;
import java.security.*;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.PKCS8EncodedKeySpec;
import java.util.Arrays;

/**
 * @author Pieter Bos
 * @author Martijn de Bijl
 *
 *
 */
public class CommonProtocol {
    /**
     * Constante om aan te geven dat de client of server alleen de basisdingen kan doen.
     */
    public static final int SUPPORTS_BAREBONE = 0;

    /**
     * Constante om aan te geven dat de client of server ook kan chatten.
     */
    public static final int SUPPORTS_CHAT = 1;

    /**
     * Constante om aan te geven dat de client of server ook kan uitdagen / uitgedaagd worden.
     */
    public static final int SUPPORTS_CHALLENGE = 2;

    /**
     * SUPPORTS_CHAT | SUPPORTS_CHALLENGE
     */
    public static final int SUPPORTS_CHAT_CHALLENGE = 3;

    /**
     * String-waarde voor true in het protocol
     */
    public static final String T_BOOLEAN_TRUE = "true";

    /**
     * String-waarde voor false in het protocol
     */
    public static final String T_BOOLEAN_FALSE = "false";

    /**
     * Versie in de handshake voor een standaardimplementatie
     */
    public static final String VERSION_NONE = "Standaard";

    /**
     * Einde van regels
     */
    public static final String LINE_ENDING = "\r\n";

    /**
     * Delimiter van commando's
     */
    public static final String COMMAND_DELIMITER = " ";

    /**
     * Alle characters van base64 in volgorde.
     */
    private static final String BASE64_CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

    private static final char BASE64_PADDING = '=';

    /**
     * Methode om van een {@code OutputStream} een correcte {@code PrintStream} te maken.
     * @param output De {@code OutputStream}
     * @return de {@code PrintStream}
     */
    public PrintStream getPrintStream(OutputStream output) {
        try {
            return new PrintStream(output, true, "UTF-8");
        } catch (UnsupportedEncodingException e) {
            return null;
        }
    }

    /**
     * Methode om van een {@code InputStream} een correcte {@code BufferedReader} te maken.
     * @param input De {@code InputStream}
     * @return De {@code BufferedReader}
     */
    public BufferedReader getBufferedReader(InputStream input) {
        try {
            return new BufferedReader(new InputStreamReader(input, "UTF-8"));
        } catch (UnsupportedEncodingException e) {
            return null;
        }
    }

    /**
     * Methode om een commando naar een {@code PrintStream} te schrijven.
     * @param commandParts De gedeeltes van het commando.
     * @param output De {@code PrintStream}
     */
    public void writeCommandTo(String[] commandParts, PrintStream output) {
        boolean first = true;
        String command = "";

        for(String argument : commandParts) {
            if(!first) {
                command += " ";
            }

            first = false;

            command += argument;
        }

        output.print(command);
        output.print("\r\n");
    }

    /**
     * Methode om een commando van een {@code BufferedReader} te lezen.
     * @param input De {@code BufferedReader}
     * @return De array van {@code String}s
     * @throws IOException
     */
    public String[] readCommandFrom(BufferedReader input) throws IOException {
        String line = input.readLine();

        return line.split(" ");
    }

    /**
     * Converteert bytes naar een Base64-String. Er is namelijk geen standaardmethode in Java om dit te doen.
     * @param data De bytes
     * @return De String
     */
    public String base64Encode(byte[] data) {
        String result = "";

        for(int i = 0; i < data.length / 3; i++) {
            byte byte1 = data[i * 3], byte2 = data[i * 3 + 1], byte3 = data[i * 3 + 2];

            result += BASE64_CHARS.charAt(byte1 / 4);
            result += BASE64_CHARS.charAt((byte1 % 4) * 16 + byte2 / 16);
            result += BASE64_CHARS.charAt((byte2 % 16) * 4 + byte3 / 64);
            result += BASE64_CHARS.charAt(byte3 % 64);
        }

        if(data.length % 3 == 1) {
            byte byte1 = data[data.length - 1];

            result += BASE64_CHARS.charAt(byte1 / 4);
            result += BASE64_CHARS.charAt((byte1 % 4) * 16);
            result += BASE64_PADDING;
            result += BASE64_PADDING;
        } else if(data.length % 3 == 2) {
            byte byte1 = data[data.length - 2], byte2 = data[data.length - 1];

            result += BASE64_CHARS.charAt(byte1 / 4);
            result += BASE64_CHARS.charAt((byte1 % 4) * 16 + byte2 / 16);
            result += BASE64_CHARS.charAt((byte2 % 16) * 4);
            result += BASE64_PADDING;
        }

        return result;
    }

    /**
     * Converteert een Bas64-String naar bytes.
     * @param data De String
     * @return De bytes
     */
    public byte[] base64Decode(String data) {
        byte[] result = new byte[data.length() / 4 * 3];

        for(int i = 0; i < data.length() / 4; i++) {
            char char1 = data.charAt(i * 4), char2 = data.charAt(i * 4 + 1),
                    char3 = data.charAt(i * 4 + 2), char4 = data.charAt(i * 4 + 3);

            result[i * 3] = (byte) (BASE64_CHARS.indexOf(char1) * 4 + BASE64_CHARS.indexOf(char2) / 16);
            result[i * 3 + 1] = (byte) ((BASE64_CHARS.indexOf(char2) % 16) * 16 + BASE64_CHARS.indexOf(char3) / 4);
            result[i * 3 + 2] = (byte) (((BASE64_CHARS.indexOf(char3) + 4) % 4) * 64 + BASE64_CHARS.indexOf(char4));
        }

        if(data.charAt(data.length() - 2) == '=') {
            return Arrays.copyOfRange(result, 0, result.length - 2);
        } else if(data.charAt(data.length() - 1) == '=') {
            return Arrays.copyOfRange(result, 0, result.length - 1);
        } else {
            return result;
        }
    }

    /**
     * Converteert een String van de ss-security-server naar een {@code PrivateKey}
     * @param data De data van de ss-security-server
     * @return De {@code PrivateKey}
     * @throws InvalidKeySpecException Als de data van de ss-security-server niet klopt.
     */
    public PrivateKey stringToPrivateKey(String data) throws InvalidKeySpecException {
        try {
            PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(data.getBytes());
            KeyFactory keyFactory = KeyFactory.getInstance("RSA");
            return keyFactory.generatePrivate(keySpec);
        } catch (NoSuchAlgorithmException e) {
            return null;
        }
    }

    /**
     * Signt een bericht met een {@code PrivateKey} en retourneert het resultaat in Base64
     * @param message Het bericht
     * @param key De {@code PrivateKey}
     * @return Het resultaat in Base64
     * @throws InvalidKeyException
     */
    public String sign(String message, PrivateKey key) throws InvalidKeyException {
        try {
            Signature signature = Signature.getInstance("SHA1withRSA");
            signature.initSign(key);
            signature.update(message.getBytes());
            return base64Encode(signature.sign());
        } catch (NoSuchAlgorithmException e) {
            return null;
        } catch (SignatureException e) {
            return null;
        }
    }

    /**
     * Converteert een String van de ss-security-server naar een {@code PublicKey}
     * @param data De data van de ss-security-server
     * @return De {@code PublicKey}
     * @throws InvalidKeySpecException
     */
    public PublicKey stringToPublicKey(String data) throws InvalidKeySpecException {
        try {
            PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(data.getBytes());
            KeyFactory keyFactory = KeyFactory.getInstance("RSA");
            return keyFactory.generatePublic(keySpec);
        } catch (NoSuchAlgorithmException e) {
            return null;
        }
    }

    /**
     * Verifieert een gesignd bericht voor een {@code PublicKey}.
     * @param message Het bericht
     * @param signedMessage Het gesignde bericht
     * @param key De {@code PublicKey}
     * @return Of het signen goed is gegaan
     * @throws InvalidKeyException
     */
    public boolean verify(String message, String signedMessage, PublicKey key) throws InvalidKeyException {
        try {
            Signature signature = Signature.getInstance("SHA1withRSA");
            signature.initVerify(key);
            signature.update(message.getBytes());
            return signature.verify(base64Decode(signedMessage));
        } catch (NoSuchAlgorithmException e) {
            return false;
        } catch (SignatureException e) {
            return false;
        }
    }
}
package rolit.model.networking.common;

import rolit.model.networking.client.*;
import rolit.model.networking.client.ChallengePacket;
import rolit.model.networking.client.HandshakePacket;
import rolit.model.networking.client.HighscorePacket;
import rolit.model.networking.client.MessagePacket;
import rolit.model.networking.client.MovePacket;
import rolit.model.networking.server.*;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintStream;
import java.util.Arrays;
import java.util.LinkedHashMap;

public abstract class Packet {
    private static final LinkedHashMap<String, Class<? extends Packet>> CLIENT_PACKETS = new LinkedHashMap<String, Class<? extends Packet>>();
    private static final LinkedHashMap<String, Class<? extends Packet>> SERVER_PACKETS = new LinkedHashMap<String, Class<? extends Packet>>();

    static {
        CLIENT_PACKETS.put(ClientProtocol.HANDSHAKE, HandshakePacket.class);
        CLIENT_PACKETS.put(ClientProtocol.AUTH, AuthPacket.class);
        CLIENT_PACKETS.put(ClientProtocol.CREATE_GAME, CreateGamePacket.class);
        CLIENT_PACKETS.put(ClientProtocol.JOIN_GAME, JoinGamePacket.class);
        CLIENT_PACKETS.put(ClientProtocol.START_GAME, StartGamePacket.class);
        CLIENT_PACKETS.put(ClientProtocol.MOVE, MovePacket.class);
        CLIENT_PACKETS.put(ClientProtocol.MESSAGE, rolit.model.networking.client.MessagePacket.class);
        CLIENT_PACKETS.put(ClientProtocol.CHALLENGE, rolit.model.networking.client.ChallengePacket.class);
        CLIENT_PACKETS.put(ClientProtocol.CHALLENGE_RESPONSE, rolit.model.networking.client.ChallengeResponsePacket.class);
        CLIENT_PACKETS.put(ClientProtocol.HIGHSCORE, rolit.model.networking.client.HighscorePacket.class);

        SERVER_PACKETS.put(ServerProtocol.HANDSHAKE, HandshakePacket.class);
        SERVER_PACKETS.put(ServerProtocol.ERROR, ErrorPacket.class);
        SERVER_PACKETS.put(ServerProtocol.GAME, GamePacket.class);
        SERVER_PACKETS.put(ServerProtocol.START, StartGamePacket.class);
        SERVER_PACKETS.put(ServerProtocol.MOVE, MovePacket.class);
        SERVER_PACKETS.put(ServerProtocol.MOVE_DONE, MoveDonePacket.class);
        SERVER_PACKETS.put(ServerProtocol.GAME_OVER, GameOverPacket.class);
        SERVER_PACKETS.put(ServerProtocol.MESSAGE, rolit.model.networking.server.MessagePacket.class);
        SERVER_PACKETS.put(ServerProtocol.CHALLENGE, rolit.model.networking.server.ChallengePacket.class);
        SERVER_PACKETS.put(ServerProtocol.CHALLENGE_RESPONSE, rolit.model.networking.server.ChallengeResponsePacket.class);
        SERVER_PACKETS.put(ServerProtocol.CAN_BE_CHALLENGED, CanBeChallengedPacket.class);
        SERVER_PACKETS.put(ServerProtocol.HIGHSCORE, rolit.model.networking.server.HighscorePacket.class);
        SERVER_PACKETS.put(ServerProtocol.ONLINE, OnlinePacket.class);
    }

    protected abstract void readFromArgs(PacketArgs args);

    protected abstract PacketArgs.ArgumentType[] getArgumentTypes();

    protected abstract Object[] getData();

    private static Packet readFrom(BufferedReader input, LinkedHashMap<String, Class<? extends Packet>> packets) throws IOException, ProtocolException {
        String[] parts = input.readLine().split(CommonProtocol.COMMAND_DELIMITER);
        String command = parts[0];
        parts = Arrays.copyOfRange(parts, 1, parts.length);

        Packet result = null;

        try {
            Class<? extends Packet> packetClass = packets.get(command);

            if(packetClass == null) {
                throw new ProtocolException("Can't parse unregistered command " + command, ServerProtocol.ERROR_GENERIC);
            } else {
                result = packetClass.newInstance();
            }
        } catch (InstantiationException e) {

        } catch (IllegalAccessException e) {

        }

        PacketArgs.ArgumentType[] args = result.getArgumentTypes();

        result.readFromArgs(PacketArgs.fromParts(parts, args));

        return result;
    }

    public static Packet readClientPacketFrom(BufferedReader input) throws IOException, ProtocolException {
        return readFrom(input, CLIENT_PACKETS);
    }

    public static Packet readServerPacketFrom(BufferedReader input) throws IOException, ProtocolException {
        return readFrom(input, SERVER_PACKETS);
    }

    public void writeTo(PrintStream output) {
        output.print(new PacketArgs(getData()).toString());
        output.print(CommonProtocol.LINE_ENDING);
    }
}
package rolit.model.networking.common;

public class ProtocolException extends Exception {
    private final int code;

    public ProtocolException(String message, int code) {
        super(message);
        this.code = code;
    }

    public int getCode() {
        return code;
    }
}
package rolit.model.networking.common;

import rolit.model.networking.client.ClientProtocol;
import rolit.model.networking.server.ServerProtocol;
import rolit.util.Strings;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintStream;
import java.util.Arrays;
import java.util.HashMap;
import java.util.LinkedHashMap;

public class Command {
    private final static HashMap<String, ArgumentType[]> serverArgumentTypes = new LinkedHashMap<String, ArgumentType[]>();
    private final static HashMap<String, ArgumentType[]> clientArgumentTypes = new LinkedHashMap<String, ArgumentType[]>();

    static {
        serverArgumentTypes.put(ServerProtocol.HANDSHAKE, new ArgumentType[] { ArgumentType.Integer, ArgumentType.String });
        serverArgumentTypes.put(ServerProtocol.ERROR, new ArgumentType[] { ArgumentType.Integer });
        serverArgumentTypes.put(ServerProtocol.GAME, new ArgumentType[] { ArgumentType.String, ArgumentType.Boolean, ArgumentType.Integer });
        serverArgumentTypes.put(ServerProtocol.START, new ArgumentType[] { ArgumentType.MultiString });
        serverArgumentTypes.put(ServerProtocol.MOVE, new ArgumentType[] {  });
        serverArgumentTypes.put(ServerProtocol.MOVE_DONE, new ArgumentType[] { ArgumentType.String, ArgumentType.Integer, ArgumentType.Integer });
        serverArgumentTypes.put(ServerProtocol.GAME_OVER, new ArgumentType[] { ArgumentType.Integer, ArgumentType.MultiString });
        serverArgumentTypes.put(ServerProtocol.MESSAGE, new ArgumentType[] { ArgumentType.String, ArgumentType.String });
        serverArgumentTypes.put(ServerProtocol.CHALLENGE, new ArgumentType[] { ArgumentType.MultiString } );
        serverArgumentTypes.put(ServerProtocol.CHALLENGE_RESPONSE, new ArgumentType[] { ArgumentType.String, ArgumentType.Boolean });
        serverArgumentTypes.put(ServerProtocol.CAN_BE_CHALLENGED, new ArgumentType[] { ArgumentType.String, ArgumentType.Boolean });
        serverArgumentTypes.put(ServerProtocol.HIGHSCORE, new ArgumentType[] { ArgumentType.MultiString });
        serverArgumentTypes.put(ServerProtocol.ONLINE, new ArgumentType[] { ArgumentType.String, ArgumentType.Boolean });

        clientArgumentTypes.put(ClientProtocol.HANDSHAKE, new ArgumentType[] { ArgumentType.String, ArgumentType.Integer, ArgumentType.String });
        clientArgumentTypes.put(ClientProtocol.CREATE_GAME, new ArgumentType[] {  });
        clientArgumentTypes.put(ClientProtocol.JOIN_GAME, new ArgumentType[] { ArgumentType.String });
        clientArgumentTypes.put(ClientProtocol.START_GAME, new ArgumentType[] {  });
        clientArgumentTypes.put(ClientProtocol.MOVE, new ArgumentType[] { ArgumentType.Integer, ArgumentType.Integer });
        clientArgumentTypes.put(ClientProtocol.MESSAGE, new ArgumentType[] { ArgumentType.String });
        clientArgumentTypes.put(ClientProtocol.CHALLENGE, new ArgumentType[] { ArgumentType.MultiString });
        clientArgumentTypes.put(ClientProtocol.CHALLENGE_RESPONSE, new ArgumentType[] { ArgumentType.Boolean });
        clientArgumentTypes.put(ClientProtocol.HIGHSCORE, new ArgumentType[] { ArgumentType.String, ArgumentType.String });
    }

    private final Object[] arguments;
    private final String command;



    public Command(String command, Object... arguments) {
        this.command = command;
        this.arguments = arguments;
    }

    public String getCommand() {
        return command;
    }

    public Object getArgument(int i) {
        return arguments[i];
    }

    public int getArgumentCount() {
        return arguments.length;
    }

    public void writeTo(PrintStream output) throws IOException {
        output.print(this.command);

        for(Object argument : arguments) {
            output.print(CommonProtocol.COMMAND_DELIMITER);

            if(argument instanceof String[]) {
                output.print(Strings.join(CommonProtocol.COMMAND_DELIMITER, (String[]) argument));
            } else {
                output.print(argument);
            }
        }

        output.print(CommonProtocol.LINE_ENDING);
        output.flush();

        if(output.checkError()) {
            throw new IOException("Write failed");
        }
    }

    private static Object parse(String data, ArgumentType arg) throws ProtocolException {
        switch(arg) {
            case Integer:
                return Integer.parseInt(data);
            case Boolean:
                if(!data.equals(CommonProtocol.T_BOOLEAN_TRUE) && !data.equals(CommonProtocol.T_BOOLEAN_FALSE)) {
                    throw new ProtocolException("Boolean must be true or false.", ServerProtocol.ERROR_GENERIC);
                }

                return data.equals(CommonProtocol.T_BOOLEAN_TRUE);
            case String:
                return data;
            case MultiString:
                throw new ProtocolException("Cannot parse a MultiString as a singular argument.", ServerProtocol.ERROR_GENERIC);
        }

        // Impossible
        return null;
    }

    public static Command readFromClient(BufferedReader input) throws IOException, ProtocolException {
        return readFrom(input, clientArgumentTypes);
    }

    public static Command readFromServer(BufferedReader input) throws IOException, ProtocolException {
        return readFrom(input, serverArgumentTypes);
    }

    private static Command readFrom(BufferedReader input, HashMap<String, ArgumentType[]> argumentTypes) throws IOException, ProtocolException {
        String[] parts = input.readLine().split(CommonProtocol.COMMAND_DELIMITER);
        String command = parts[0];
        parts = Arrays.copyOfRange(parts, 1, parts.length);

        ArgumentType[] args = argumentTypes.get(command);

        if(args == null) {
            throw new ProtocolException("Can't parse unregistered command " + command, ServerProtocol.ERROR_GENERIC);
        }

        boolean multiString = false;
        int multiStringLocation = -1;

        for(int i = 0; i < args.length; i++) {
            if(args[i] == ArgumentType.MultiString) {
                multiString = true;
                multiStringLocation = i;
                break;
            }
        }

        Object[] result = new Object[args.length];

        if(multiString) {
            for(int i = 0; i < multiStringLocation; i++) {
                result[i] = parse(parts[i], args[i]);
            }

            int left = args.length - multiStringLocation - 1;

            for(int i = parts.length - left, resultI = multiStringLocation + 1; i < parts.length; i++, resultI++) {
                result[resultI] = parse(parts[i], args[resultI]);
            }

            result[multiStringLocation] = Arrays.copyOfRange(parts, multiStringLocation, multiStringLocation + parts.length - args.length + 1);
        } else {
            if(parts.length > args.length) {
                throw new ProtocolException("Length of parts exceeds argument count.", ServerProtocol.ERROR_GENERIC);
            }

            for(int i = 0; i < parts.length; i++) {
                result[i] = parse(parts[i], args[i]);
            }
        }

        return new Command(command, result);
    }
}
package rolit.model.networking.common;

import rolit.model.networking.server.ServerProtocol;
import rolit.util.Strings;

import java.util.Arrays;

public class PacketArgs {
    public enum ArgumentType {
        Integer,
        Boolean,
        String,
        MultiString
    }

    private Object[] data;

    public PacketArgs(Object[] data) {
        this.data = data;
    }

    private static Object parse(String data, ArgumentType arg) throws ProtocolException {
        switch(arg) {
            case Integer:
                return Integer.parseInt(data);
            case Boolean:
                if(!data.equals(CommonProtocol.T_BOOLEAN_TRUE) && !data.equals(CommonProtocol.T_BOOLEAN_FALSE)) {
                    throw new ProtocolException("Boolean must be true or false.", ServerProtocol.ERROR_GENERIC);
                }

                return data.equals(CommonProtocol.T_BOOLEAN_TRUE);
            case String:
                return data;
            case MultiString:
                throw new ProtocolException("Cannot parse a MultiString as a singular argument.", ServerProtocol.ERROR_GENERIC);
        }

        // Impossible
        return null;
    }

    public int getInt(int i) {
        return (Integer) data[i];
    }

    public boolean getBool(int i) {
        return (Boolean) data[i];
    }

    public String getString(int i) {
        return (String) data[i];
    }

    public String[] getMultiString(int i) {
        return (String[]) data[i];
    }

    public String getSpacedString(int i) {
        return Strings.join(CommonProtocol.COMMAND_DELIMITER, getMultiString(i));
    }

    public static PacketArgs fromParts(String[] parts, ArgumentType[] args) throws ProtocolException {
        boolean multiString = false;
        int multiStringLocation = -1;

        for(int i = 0; i < args.length; i++) {
            if(args[i] == ArgumentType.MultiString) {
                multiString = true;
                multiStringLocation = i;
                break;
            }
        }

        Object[] result = new Object[args.length];

        if(multiString) {
            for(int i = 0; i < multiStringLocation; i++) {
                result[i] = parse(parts[i], args[i]);
            }

            int left = args.length - multiStringLocation - 1;

            for(int i = parts.length - left, resultI = multiStringLocation + 1; i < parts.length; i++, resultI++) {
                result[resultI] = parse(parts[i], args[resultI]);
            }

            result[multiStringLocation] = Arrays.copyOfRange(parts, multiStringLocation, multiStringLocation + parts.length - args.length + 1);
        } else {
            if(parts.length > args.length) {
                throw new ProtocolException("Length of parts exceeds argument count.", ServerProtocol.ERROR_GENERIC);
            }

            for(int i = 0; i < parts.length; i++) {
                result[i] = parse(parts[i], args[i]);
            }
        }

        return new PacketArgs(result);
    }

    @Override
    public String toString() {
        String result = "";
        boolean first = true;

        for(Object unit : data) {
            if(!first) {
                result += CommonProtocol.COMMAND_DELIMITER;
            }

            first = false;

            if(unit instanceof Integer) {
                result += Integer.toString((Integer) unit);
            } else if(unit instanceof Boolean) {
                result += Boolean.toString((Boolean) unit);
            } else if(unit instanceof String) {
                result += (String) unit;
            } else {
                result += Strings.join(CommonProtocol.COMMAND_DELIMITER, (String[]) unit);
            }
        }

        return result;
    }

    public static String[] spacedToMulti(String s) {
        return s.split(CommonProtocol.COMMAND_DELIMITER);
    }
}
package rolit.model.networking.extensions;

import rolit.model.networking.client.ClientProtocol;

public abstract class WebSocketClientProtocol extends ClientProtocol {
    public static final String GET = "GET";

    /**
     * Bij wijze van spreke een methode van de client.
     * @param path Moet altijd / zijn
     * @param version Moet altijd HTTP/1.1 zijn;
     */
    public abstract void get(String path, String version);
}
package rolit.model.networking.extensions;

import rolit.model.networking.server.ServerProtocol;

/**
 * @author Pieter Bos
 *
 * Abstract class voor het protocol van een rolit WebSocket server.
 *
 * Dit type server kan een extra commando ontvangen, GET. Deze moet als eerste worden verstuurd in plaats van de
 * handshake, of helemaal niet. Als dit commando wordt verstuurd wordt de connectie omgezet naar een HTTP-verbinding.
 * De server verwacht dan een "Upgrade: websocket" header en verder alle andere headers zoals gespecificeerd in
 * rfc #6455. Daarna reageert de server of met een 501 Not Implemented of een 101 Switching Protocols, afhankelijk van
 * of de request correct is. In het tweede geval wordt de connectie verheven naar een JSON-RPC 2.0 WebSocket server,
 * zoals hier gespecificeerd: http://www.jsonrpc.org/specification.
 * Elk commando is dan een JSON-RPC methode, met als argumenten gewoon de argumenten. Uitzondering is het chat-bericht,
 * die als één argument wordt verzonden. Daarnaast zijn de typen gewoon native JSON typen, namelijk strings, numbers en
 * booleans.
 *
 * Redenen voor dit protocol:
 * - Webstandaard die geïmplementeerd is in alle moderne browsers: IE10+, FF4+, Chrome14+, Safari5+, Opera11+ en deze
 *   browsers voor mobiele platforms.
 * - Heeft libraries voor bijna alle talen
 * - Is tekst-gebaseerd in het begin, zodat het redelijk vloeiend gaat tussen een WebSocket client en een gewone
 *   server.
 */
public abstract class WebSocketServerProtocol extends ServerProtocol {

}
package rolit.model.networking.server;

import rolit.model.networking.common.Packet;
import rolit.model.networking.common.PacketArgs;

public class CanBeChallengedPacket extends Packet {
    private String user;
    private boolean canBeChallenged;

    public CanBeChallengedPacket(String user, boolean canBeChallenged) {
        this.user = user;
        this.canBeChallenged = canBeChallenged;
    }

    public String getUser() {
        return user;
    }

    public boolean isCanBeChallenged() {
        return canBeChallenged;
    }

    @Override
    protected void readFromArgs(PacketArgs args) {
        this.user = args.getString(0);
        this.canBeChallenged = args.getBool(1);
    }

    @Override
    protected PacketArgs.ArgumentType[] getArgumentTypes() {
        return new PacketArgs.ArgumentType[] { PacketArgs.ArgumentType.String, PacketArgs.ArgumentType.Boolean };
    }

    @Override
    protected Object[] getData() {
        return new Object[] { user, canBeChallenged };
    }
}
package rolit.model.networking.server;

import rolit.model.networking.common.Packet;
import rolit.model.networking.common.PacketArgs;

public class ErrorPacket extends Packet {
    private int code;

    public ErrorPacket(int code) {
        this.code = code;
    }

    public int getCode() {
        return code;
    }

    @Override
    protected void readFromArgs(PacketArgs args) {
        this.code = args.getInt(0);
    }

    @Override
    protected PacketArgs.ArgumentType[] getArgumentTypes() {
        return new PacketArgs.ArgumentType[] { PacketArgs.ArgumentType.Integer };
    }

    @Override
    protected Object[] getData() {
        return new Object[] { this.code };
    }
}
package rolit.model.networking.server;

import rolit.model.networking.client.StartGamePacket;

public class WaitForGameClientHandlerState extends ClientHandlerState {
    private final String creator;

    public WaitForGameClientHandlerState(ClientHandler handler, String creator) {
        super(handler);
        this.creator = creator;
    }

    public String getCreator() {
        return creator;
    }

    @Override
    public ClientHandlerState startGame(StartGamePacket packet) {
        return new GameClientHandlerState(getHandler(), getCreator());
    }
}
package rolit.model.networking.server;

import rolit.model.networking.client.ClientProtocol;
import rolit.model.networking.client.HandshakePacket;
import rolit.model.networking.common.CommonProtocol;
import rolit.model.networking.common.ProtocolException;

public class InitialClientHandlerState extends ClientHandlerState {
    public InitialClientHandlerState(ClientHandler handler) {
        super(handler);
    }

    @Override
    public ClientHandlerState handshake(HandshakePacket packet) throws ProtocolException {
        if(packet.getSupports() < CommonProtocol.SUPPORTS_BAREBONE || packet.getSupports() > CommonProtocol.SUPPORTS_CHAT_CHALLENGE) {
            throw new ProtocolException("Invalid supports integer", ServerProtocol.ERROR_GENERIC);
        }

        if(packet.getName().length() < 2 || packet.getName().length() > 32) {
            throw new ProtocolException("Invalid name length or format", ServerProtocol.ERROR_INVALID_LOGIN);
        }

        getHandler().setClientName(packet.getName());
        getHandler().setClientSupports(packet.getSupports());

        if(packet.getName().startsWith("player_")) {
            return new AuthClientHandlerState(getHandler());
        } else {
            return new GameLobbyClientHandlerState(getHandler());
        }
    }
}
package rolit.model.networking.server;

import rolit.model.event.ServerListener;
import rolit.model.game.Game;
import rolit.model.networking.common.CommonProtocol;

import java.io.IOException;
import java.net.InetAddress;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.LinkedList;

public class Server extends ServerSocket implements Runnable {
    private static final int DEFAULT_BACKLOG = 5;
    public static final int GLOBAL_SUPPORTS = CommonProtocol.SUPPORTS_CHAT_CHALLENGE;
    public static final String GLOBAL_VERSION = "PieterMartijn_Alpha1";

    private Thread serverThread;
    private LinkedList<ServerListener> listeners = new LinkedList<ServerListener>();
    private LinkedList<ClientHandler> clients = new LinkedList<ClientHandler>();
    private LinkedList<User> users = new LinkedList<User>();
    private LinkedList<ServerGame> games = new LinkedList<ServerGame>();

    public Server(String bindAddress, int port) throws IOException {
        super(port, DEFAULT_BACKLOG, InetAddress.getByName(bindAddress));
        serverThread = new Thread(this);
    }

    public Thread getServerThread() {
        return serverThread;
    }

    public void addListener(ServerListener listener) {
        listeners.add(listener);
    }

    public void removeListener(ServerListener listener) {
        listeners.remove(listener);
    }

    public void serveForever() {
        serverThread.start();
    }

    public void fireServerError(String reason) {
        for(ServerListener listener : listeners) {
            listener.serverError(reason);
        }
    }

    private void fireNewClient(ClientHandler handler) {
        for(ServerListener listener : listeners) {
            listener.newClient(handler);
        }
    }

    public void fireClientError(String reason) {
        for(ServerListener listener : listeners) {
            listener.clientError(reason);
        }
    }

    public synchronized User authenticateUser(String username) {
        boolean exists = false;
        User theUser = null;

        for(User user : users) {
            if(user.getUsername().equals(username)) {
                exists = true;
                theUser = user;
                break;
            }
        }

        if(!exists) {
            User user = new User(username);
            users.add(user);
            return user;
        } else {
            for(ClientHandler client : clients) {
                if(client.getUser() == theUser) {
                    return null;
                }
            }

            return theUser;
        }
    }

    public synchronized void addGame(ServerGame game) {
        games.add(game);
    }

    public synchronized ServerGame getGame(String creator) {
        for(ServerGame game : games) {
            if(game.getCreator().getUsername().equals(creator)) {
                return game;
            }
        }

        return null;
    }

    public synchronized void broadcastMessage(User user, String message) {
        for(ClientHandler client : clients) {
            try {
                client.message(user.getUsername(), message);
            } catch(IOException e) {
                // Wait for client to be removed by ClientHandler
            }
        }
    }

    public synchronized void gameMessage(User user, String join, ServerGame game) {
//        for(User gameUser : game.getPlayers()) {
//            for(ClientHandler client : clients) {
//                if(client.getUser() == gameUser) {
//                    try {
//                        client.message(user.getUsername(), join);
//                    } catch (IOException e) {
//
//                    }
//                }
//            }
//        }
    }

    public void challenge(User user, String[] others) {
        for(String userName : others) {
            for(ClientHandler client : clients) {
                if(client.getUser().getUsername().equals(userName)) {
                    try {
                        switch(others.length) {
                            case 1:
                                client.challenge(user.getUsername(), others[0]);
                                break;
                            case 2:
                                client.challenge(user.getUsername(), others[0], others[1]);
                                break;
                            case 3:
                                client.challenge(user.getUsername(), others[0], others[1], others[2]);
                        }
                    } catch (IOException e) {

                    }
                }
            }
        }

    }

    @Override
    public void run() {
        try {
            while(true) {
                Socket client = accept();
                ClientHandler handler = new ClientHandler(this, client);
                fireNewClient(handler);
            }
        } catch(IOException e) {
            fireServerError("IOException: " + e.getMessage());
        }
    }
}
package rolit.model.networking.server;

import rolit.model.networking.common.Packet;
import rolit.model.networking.common.PacketArgs;

public class StartPacket extends Packet {
    private String[] players;

    public StartPacket(String[] players) {
        this.players = players;
    }

    public String[] getPlayers() {
        return players;
    }

    @Override
    protected void readFromArgs(PacketArgs args) {
        this.players = args.getMultiString(0);
    }

    @Override
    protected PacketArgs.ArgumentType[] getArgumentTypes() {
        return new PacketArgs.ArgumentType[] { PacketArgs.ArgumentType.MultiString };
    }

    @Override
    protected Object[] getData() {
        return new Object[] { players };
    }
}
package rolit.model.networking.server;

import rolit.model.game.Game;

import java.util.LinkedList;

public class ServerGame extends Game {
    private final LinkedList<User> players = new LinkedList<User>();
    private final User creator;
    private boolean started;

    public ServerGame(User creator) {
        super(1);
        this.creator = creator;
        players.add(creator);
    }

    public User getCreator() {
        return creator;
    }

    public void addPlayer(User player) {
        players.add(player);
    }

    public void removePlayer(User player) {
        players.remove(player);
    }

//    public User[] getPlayers() {
//        User[] result = new User[players.size()];
//        players.toArray(result);
//        return result;
//    }

    public boolean isStarted() {
        return started;
    }

    public void start() {
        started = true;
    }

    public boolean isNext(User user) {
        return true;
    }

    public boolean canDoMove(int x, int y) {
        return true;
    }

    public void doMove(int x, int y) {

    }
}
package rolit.model.networking.server;

public class User {
    private final String username;

    public User(String username) {
        this.username = username;
    }

    public boolean isValidAuthentication() {
        return true;
    }

    public String getUsername() {
        return username;
    }
}
package rolit.model.networking.server;

import rolit.model.networking.common.Packet;
import rolit.model.networking.common.PacketArgs;

public class MessagePacket extends Packet {
    private String user;
    private String message;

    public MessagePacket(String user, String message) {
        this.user = user;
        this.message = message;
    }

    @Override
    protected void readFromArgs(PacketArgs args) {
        this.user = args.getString(0);
        this.message = args.getSpacedString(1);
    }

    @Override
    protected PacketArgs.ArgumentType[] getArgumentTypes() {
        return new PacketArgs.ArgumentType[] { PacketArgs.ArgumentType.String, PacketArgs.ArgumentType.MultiString };
    }

    @Override
    protected Object[] getData() {
        return new Object[] { user, message };
    }
}
package rolit.model.networking.server;

import rolit.model.networking.client.ChallengePacket;
import rolit.model.networking.client.ChallengeResponsePacket;
import rolit.model.networking.client.CreateGamePacket;
import rolit.model.networking.client.HandshakePacket;
import rolit.model.networking.client.JoinGamePacket;
import rolit.model.networking.client.MovePacket;
import rolit.model.networking.client.StartGamePacket;
import rolit.model.networking.common.ProtocolException;

public abstract class ClientHandlerState {
    private ClientHandler handler;

    public ClientHandlerState(ClientHandler handler) {
        this.handler = handler;
    }

    private void error(String commandName) throws ProtocolException {
        throw new ProtocolException("Cannot do " + commandName + " while in state " + this.getClass().getName(), ServerProtocol.ERROR_GENERIC);
    }

    public ClientHandlerState challenge(ChallengePacket packet) throws ProtocolException {
        error("challenge");
        return null;
    }

    public ClientHandlerState challengeResponse(ChallengeResponsePacket packet) throws ProtocolException {
        error("challenge response");
        return null;
    }

    public ClientHandlerState createGame(CreateGamePacket packet) throws ProtocolException {
        error("create game");
        return null;
    }

    public ClientHandlerState handshake(HandshakePacket packet) throws ProtocolException {
        error("hello");
        return null;
    }

    public ClientHandlerState joinGame(JoinGamePacket packet) throws ProtocolException {
        error("join game");
        return null;
    }

    public ClientHandlerState move(MovePacket packet) throws ProtocolException {
        error("move");
        return null;
    }

    public ClientHandlerState startGame(StartGamePacket packet) throws ProtocolException {
        error("start game");
        return null;
    }

    public ClientHandler getHandler() {
        return handler;
    }
}
package rolit.model.networking.server;

import rolit.model.networking.common.Packet;
import rolit.model.networking.common.PacketArgs;

public class ChallengeResponsePacket extends Packet {
    private String user;
    private boolean accept;

    public ChallengeResponsePacket(String user, boolean accept) {
        this.user = user;
        this.accept = accept;
    }

    public String getUser() {
        return user;
    }

    public boolean isAccept() {
        return accept;
    }

    @Override
    protected void readFromArgs(PacketArgs args) {
        this.user = args.getString(0);
        this.accept = args.getBool(1);
    }

    @Override
    protected PacketArgs.ArgumentType[] getArgumentTypes() {
        return new PacketArgs.ArgumentType[] { PacketArgs.ArgumentType.String, PacketArgs.ArgumentType.Boolean };
    }

    @Override
    protected Object[] getData() {
        return new Object[] { user, accept };
    }
}
package rolit.model.networking.server;

import rolit.model.networking.common.Packet;
import rolit.model.networking.common.PacketArgs;

public class GameOverPacket extends Packet {
    private int score;
    private String[] winners;

    public GameOverPacket(int score, String[] winners) {
        this.score = score;
        this.winners = winners;
    }

    public int getScore() {
        return score;
    }

    public String[] getWinners() {
        return winners;
    }

    @Override
    protected void readFromArgs(PacketArgs args) {
        this.score = args.getInt(0);
        this.winners = args.getMultiString(1);
    }

    @Override
    protected PacketArgs.ArgumentType[] getArgumentTypes() {
        return new PacketArgs.ArgumentType[] { PacketArgs.ArgumentType.Integer, PacketArgs.ArgumentType.MultiString };
    }

    @Override
    protected Object[] getData() {
        return new Object[] { score, winners };
    }
}
package rolit.model.networking.server;

import rolit.model.networking.client.ClientProtocol;
import rolit.model.networking.client.CreateGamePacket;
import rolit.model.networking.client.JoinGamePacket;
import rolit.model.networking.client.StartGamePacket;
import rolit.model.networking.common.Command;
import rolit.model.networking.common.Packet;
import rolit.model.networking.common.ProtocolException;
import rolit.model.networking.client.ChallengePacket;
import rolit.model.networking.client.ChallengeResponsePacket;
import rolit.model.networking.client.HandshakePacket;
import rolit.model.networking.client.MovePacket;
import rolit.util.Strings;

import java.io.*;
import java.net.Socket;

public class ClientHandler implements Runnable {
    private final Server server;
    private final Socket client;
    private BufferedReader input;
    private PrintStream output;
    private final Thread thread;

    private ClientHandlerState state;

    private int clientSupports;
    private String clientName;

    public ClientHandler(Server server, Socket client) throws IOException {
        this.server = server;
        this.client = client;
        thread = new Thread(this);
        state = new InitialClientHandlerState(this);
    }

    public void start() {
        thread.start();
    }

    private void handlePacket(Packet packet) throws ProtocolException {
        if(packet instanceof ChallengePacket) {
            state = state.challenge((ChallengePacket) packet);
        } else if(packet instanceof ChallengeResponsePacket) {
            state = state.challengeResponse((ChallengeResponsePacket) packet);
        } else if(packet instanceof CreateGamePacket) {
            state = state.createGame((CreateGamePacket) packet);
        } else if(packet instanceof HandshakePacket) {
            state = state.handshake((HandshakePacket) packet);
        } else if(packet instanceof HighscorePacket) {
            highscore((HighscorePacket) packet);
        } else if(packet instanceof JoinGamePacket) {
            state = state.joinGame((JoinGamePacket) packet);
        } else if(packet instanceof MessagePacket) {
            message((MessagePacket) packet);
        } else if(packet instanceof MovePacket) {
            state = state.move((MovePacket) packet);
        } else if(packet instanceof StartGamePacket) {
            state = state.startGame((StartGamePacket) packet);
        } else {
            throw new ProtocolException("Client caused the server to be in an impossible condition", ServerProtocol.ERROR_GENERIC);
        }
    }

    private void message(MessagePacket packet) {

    }

    private void highscore(HighscorePacket packet) {

    }

    @Override
    public void run() {
        try {
            try {
                this.input = new BufferedReader(new InputStreamReader(client.getInputStream(), "UTF-8"));
                this.output = new PrintStream(client.getOutputStream(), true, "UTF-8");

                while(true) {
                    handlePacket(Packet.readClientPacketFrom(input));
                }
            } catch (ProtocolException e) {
                server.fireClientError("ProtocolException: " + e.getMessage());
                new ErrorPacket(e.getCode()).writeTo(output);
                client.close();
            }
        } catch (IOException e) {
            server.fireClientError("IOException: " + e.getMessage());
        }
    }

    public int getClientSupports() {
        return clientSupports;
    }

    public void setClientSupports(int clientSupports) {
        this.clientSupports = clientSupports;
    }

    public String getClientName() {
        return clientName;
    }

    public void setClientName(String clientName) {
        this.clientName = clientName;
    }

    public void write(Packet packet) {
        packet.writeTo(output);
    }
}
package rolit.model.networking.server;

import rolit.model.networking.common.Packet;
import rolit.model.networking.common.PacketArgs;

public class MovePacket extends Packet {
    public MovePacket() {

    }

    @Override
    protected void readFromArgs(PacketArgs args) {

    }

    @Override
    protected PacketArgs.ArgumentType[] getArgumentTypes() {
        return new PacketArgs.ArgumentType[] {  };
    }

    @Override
    protected Object[] getData() {
        return new Object[] {  };
    }
}
package rolit.model.networking.server;

import rolit.model.networking.common.Packet;
import rolit.model.networking.common.PacketArgs;

public class ChallengePacket extends Packet {
    @Override
    protected void readFromArgs(PacketArgs args) {
        //To change body of implemented methods use File | Settings | File Templates.
    }

    @Override
    protected PacketArgs.ArgumentType[] getArgumentTypes() {
        return new PacketArgs.ArgumentType[0];  //To change body of implemented methods use File | Settings | File Templates.
    }

    @Override
    protected Object[] getData() {
        return new Object[0];  //To change body of implemented methods use File | Settings | File Templates.
    }
}
package rolit.model.networking.server;

import rolit.model.networking.common.Packet;
import rolit.model.networking.common.PacketArgs;

public class GamePacket extends Packet {
    private String game;
    private int status;
    private int players;

    public GamePacket(String game, int status, int players) {
        this.game = game;
        this.status = status;
        this.players = players;
    }

    public String getGame() {
        return game;
    }

    public int getStatus() {
        return status;
    }

    public int getPlayers() {
        return players;
    }

    @Override
    protected void readFromArgs(PacketArgs args) {
        this.game = args.getString(0);
        this.status = args.getInt(1);
        this.players = args.getInt(2);
    }

    @Override
    protected PacketArgs.ArgumentType[] getArgumentTypes() {
        return new PacketArgs.ArgumentType[] { PacketArgs.ArgumentType.String, PacketArgs.ArgumentType.Integer, PacketArgs.ArgumentType.Integer };
    }

    @Override
    protected Object[] getData() {
        return new Object[] { game, status, players };
    }
}
package rolit.model.networking.server;

public class AuthClientHandlerState extends ClientHandlerState {
    public AuthClientHandlerState(ClientHandler handler) {
        super(handler);
        getHandler().write(new HandshakePacket(Server.GLOBAL_SUPPORTS, Server.GLOBAL_VERSION, "hallo"));
    }
}
package rolit.model.networking.server;

import rolit.model.networking.common.Packet;
import rolit.model.networking.common.PacketArgs;

public class OnlinePacket extends Packet {
    private String user;
    private boolean online;

    public OnlinePacket(String user, boolean online) {
        this.user = user;
        this.online = online;
    }

    public String getUser() {
        return user;
    }

    public boolean isOnline() {
        return online;
    }

    @Override
    protected void readFromArgs(PacketArgs args) {
        this.user = args.getString(0);
        this.online = args.getBool(1);
    }

    @Override
    protected PacketArgs.ArgumentType[] getArgumentTypes() {
        return new PacketArgs.ArgumentType[] { PacketArgs.ArgumentType.String, PacketArgs.ArgumentType.Boolean }
    }

    @Override
    protected Object[] getData() {
        return new Object[] { user, online };
    }
}
package rolit.model.networking.server;

import rolit.model.networking.common.CommonProtocol;

import java.io.IOException;

/**
 * @author Pieter Bos
 * @author Martijn de Bijl
 *
 * Abstract class met alle constanten en methodes die gebruikt kunnen worden
 */
public abstract class ServerProtocol extends CommonProtocol {
    /**
     * Constante voor het handshake-commando
     */
    public static final String HANDSHAKE = "hello";

    /**
     * Constante voor het authOk-commando
     */
    public static final String AUTH_OK = "authOk";

    /**
     * Constante voor het error-commando
     */
    public static final String ERROR = "error";

    /**
     * Constante voor het game-commando
     */
    public static final String GAME = "game";

    /**
     * Constante voor het start-commando
     */
    public static final String START = "start";

    /**
     * Constante voor het move-commando
     */
    public static final String MOVE = "move";

    /**
     * Constante voor het move-done-commando
     */
    public static final String MOVE_DONE = "moveDone";

    /**
     * Constante voor het game-over-command
     */
    public static final String GAME_OVER = "gameOver";

    /**
     * Constante voor het message-commando
     */
    public static final String MESSAGE = "message";

    /**
     * Constante voor het challenge-commando
     */
    public static final String CHALLENGE = "challenge";

    /**
     * Constante voor het challenge-response-commando
     */
    public static final String CHALLENGE_RESPONSE = "challengeResponse";

    /**
     * Constante voor het can-be-challenged-commando
     */
    public static final String CAN_BE_CHALLENGED = "canBeChallenged";

    /**
     *
     */
    public static final String ONLINE = "online";

    /**
     * Constante voor highscore
     */
    public static final String HIGHSCORE = "highscore";

    public static final int ERROR_GENERIC = -1;
    public static final int ERROR_INVALID_LOGIN = 1;
    public static final int ERROR_GAME_FULL = 2;
    public static final int ERROR_TOO_LITTLE_PLAYERS = 3;
    public static final int ERROR_INVALID_MOVE = 4;
    public static final int ERROR_NO_SUCH_GAME = 5;
    public static final int ERROR_USER_HAS_NO_GAME = 6;
    public static final int ERROR_HANDSHAKE_MISSING = 7;
    public static final int ERROR_USER_ALREADY_HAS_GAME = 8;

    public static final int HIGHSCORE_UNAVAILABLE = -1;

    /**
     * Status om aan te geven dat de creator voortijdig is weggegaan
     */
    public static final int STATUS_PREMATURE_LEAVE = -1;

    /**
     * Status om aan te geven dat het spel nog niet is gestart.
     */
    public static final int STATUS_NOT_STARTED = 0;

    /**
     * Status om aan te geven dat het spel is gestart.
     */
    public static final int STATUS_STARTED = 1;

    /**
     * Antwoord op de handshake van de client. Moet altijd het eerst verzonden commando zijn, met uitzondering van
     * errors.
     * @requires Dat de handshake van de client is verzonden.
     * @requires Dat de handshake van de client niet een al ingelodge naam kiest.
     * @requires Dat de clientName niet begint met "player_"
     * @param supports Wat de server ondersteunt.
     * @param version Een beschrijving van wat de server kan
     */
    public abstract void handshake(int supports, String version) throws IOException;

    /**
     * Antwoord op de handshake van de client. Moet altijd het eerst verzonden commando zijn, met uitzondering van
     * errors.
     * @requires Dat de requirements van de eerste overload zijn voldaan.
     * @requires Dat de clientName juist wel begint met "player_"
     * @param supports
     * @param version
     * @param nonce
     * @throws IOException
     */
    public abstract void handshake(int supports, String version, String nonce) throws IOException;

    /**
     * Antwoord op het auth-pakket van de client.
     * @requires Dat de handshake is gedaan.
     * @requires Dat de client een juist gesignde nonce heeft gestuurd.
     * @requires Dat de nonce gesigned is met de juiste public-key volgens ss-security.student.utwente.nl
     * @throws IOException
     */
    public abstract void authOk() throws IOException;

    /**
     * Commando om de client te laten weten dat hij iets fout heeft gedaan, waardoor de verbinding moet worden
     * verbroken.
     * @requires Dat de client iets fout heeft gedaan...
     * @requires Dat dit het enige en eerste pakket na de fout is.
     * @param errorCode De error-code, op te zoeken in de errorCode-tabel.
     */
    public abstract void error(int errorCode) throws IOException;

    /**
     * Commando om de client te laten weten dat er óf een nieuw spel is, óf dat er een spel is veranderd in status.
     * Clients krijgen een serie van deze commando's na de handshake om zo een lijst van alle spellen op te bouwen. Als
     * er daarna iets verandert aan het aantal spelers of dat het spel is begonnen moet de server weer een update
     * sturen.
     * @requires Dat de handshake is gedaan.
     * @requires Dat óf het spel in hasStarted-status is veranderd, óf in aantal spelers is veranderd, óf dat de client
     * nog niet de volledige lijst met spellen heeft ontvangen direct na de handshake.
     * @param creator De maker van het spel.
     * @param hasStarted De status van het spel.
     * @param noPlayers Het aantal spelers in het spel.
     */
    public abstract void game(String creator, int status, int noPlayers) throws IOException;

    /**
     * Commando om een spel te starten met twee spelers, die in die volgorde een zet moeten doen.
     * @requires Dat de handshake is gedaan.
     * @requires Dat de speler in een spel zit.
     * @requires Dat de creator van het spel het spel heeft gestart.
     * @requires Dat dit bericht nog niet is gestuurd voor dit spel.
     * @param playerOne De eerste speler
     * @param playerTwo De tweede speler
     */
    public abstract void start(String playerOne, String playerTwo) throws IOException;

    /**
     * Commando om een spel te starten met drie spelers, die in die volgorde een zet moeten doen.
     * @requires Dat de requirements bij de eerste overload zijn voldaan.
     * @param playerOne De eerste speler
     * @param playerTwo De tweede speler
     * @param playerThree De derde speler
     */
    public abstract void start(String playerOne, String playerTwo, String playerThree) throws IOException;

    /**
     * Commando om een spel te starten met vier spelers, die in die volgorde een zet moeten doen.
     * @requires Dat de requirements bij de eerste overload zijn voldaan.
     * @param playerOne De eerste speler
     * @param playerTwo De tweede speler
     * @param playerThree De derde speler
     * @param playerFour De vierde speler
     */
    public abstract void start(String playerOne, String playerTwo, String playerThree, String playerFour) throws IOException;

    /**
     * Commando om de client te vertellen dat hij een zet moet gaan doen.
     * @requires Dat de handshake is gedaan.
     * @requires Dat de speler in een spel zit.
     * @requires Dat het spel is gestart.
     * @requires Dat de speler ook echt aan de beurt is.
     */
    public abstract void move() throws IOException;

    /**
     * Commando om de client te laten weten dat iemand een zet heeft gedaan in het huidige spel.
     * @requires Dat de handshake is gedaan.
     * @requires Dat de speler in een spel zit.
     * @requires Dat het spel is gestart.
     * @requires Dat de speler die zet heeft gedaan
     * @param name Naam van de speler die de zet heeft gedan.
     * @param x X-coördinaat, waarbij de linkerkant 0 is en de rechterkant 7.
     * @param y Y-coördinaat, waarbij de bovenkant 0 is en de onderkant 7.
     */
    public abstract void moveDone(String name, int x, int y) throws IOException;

    /**
     * Commando om de client te laten weten dat het spel is afgelopen, om welke reden dan ook. Eventueel zijn er
     * winnaars als het spel helemaal is voltooid. De server mag bepalen wat er gebeurt als er meerdere mensen dezelfde
     * score hebben.
     * @requires Dat de handshake is gedaan.
     * @requires Dat de speler in een spel zit.
     * @requires Dat het spel is gestart.
     * @requires Dat:
     *           * Als het spel is gestart: ofwel het spel is afgelopen volgens de regels van de server ofwel één van de
     *                 mensen is weggegaan
     * @param score De hoogste score
     * @param winners De mensen met die score
     */
    public abstract void gameOver(int score, String[] winners) throws IOException;

    /**
     * Commando om de client op te hoogte te stellen van een chatbericht
     * @requires Dat de handshake is gedaan.
     * @requires Dat de speler dit bericht heeft verzonden.
     * @param name Afzender van het chatbericht
     * @param body Tekst van het chatbericht
     */
    public abstract void message(String name, String body) throws IOException;

    /**
     * Commando om de client op te hoogte te stellen van een uitdaging met twee mensen.
     * @requires Dat de handshake is gedaan.
     * @requires Dat de speler niet is uitgedaagd.
     * @requires Dat de speler niet in een spel zit.
     * @requires Dat de speler uitdaagbaar is.
     * @param challenger De uitdager
     */
    public abstract void challenge(String challenger, String other1) throws IOException;

    /**
     * Commando om de client op de hoogte te stellen van een uitdaging met drie mensen
     * @requires Dat de requirements bij de eerste overload zijn voldaan.
     * @param challenger De uitdager
     * @param other1 Andere gebruiker
     */
    public abstract void challenge(String challenger, String other1, String other2) throws IOException;

    /**
     * Commando om de client op de hoogte te stellen van een uitdaging met vier mensen
     * @requires Dat de requirements bij de eerste overload zijn voldaan.
     * @param challenger De uitdager
     * @param other1 Andere gebruiker 1
     * @param other2 Andere gebruiker 2
     */
    public abstract void challenge(String challenger, String other1, String other2, String other3) throws IOException;

    /**
     * Commando om mensen die in een uitdaging zitten op de hoogte te stellen van de status van de uitgedaagden.
     * @requires Dat de handshake is gedaan.
     * @requires Dat de client is uitgedaagd.
     * @param name Naam van de uitgedaagde.
     * @param accept Of deze persoon accepteert.
     */
    public abstract void challengeResponse(String name, boolean accept) throws IOException;

    /**
     * Commando om de client op de hoogte te stellen van het veranderen van de status van iemand.
     * @requires Dat de handshake is gedaan.
     * @requires Dat de flag true is als de speler is uitgedaagd of een uitdager is.
     * @param name Naam van de uitgedaagde
     * @param flag Of hij kan worden uitgedaagd.
     */
    public abstract void canBeChallenged(String name, boolean flag) throws IOException;

    /**
     * Commando om de client op de hoogte te stellen van de gevraagde highscores.
     * @requires Dat de handshake is gedaan.
     * @requires Dat de client heeft gevraagd om highscores.
     * @param args Argumenten
     */
    public abstract void highscore(String[] args) throws IOException;

    /**
     * Commando om de client op de hoogte te stellen van een gebruiker die inlogt of weggaat
     * @requires Dat de handshake is gedaan
     * @requires Dat ófwel er een client bijkomt, ófwel er een client weggaat, ófwel dat de client de lijst met mensen
     * nog niet in zijn geheel heeft ontvangen na de lijst van spellen. Dit laatste is geen requirement voor servers
     * zonder chat.
     */
    public abstract void online(String name, boolean isOnline) throws IOException;
}
package rolit.model.networking.server;

import rolit.model.networking.client.MovePacket;

public class GameClientHandlerState extends ClientHandlerState {
    private final String creator;

    public GameClientHandlerState(ClientHandler handler, String creator) {
        super(handler);
        this.creator = creator;
    }

    public String getCreator() {
        return creator;
    }

    @Override
    public ClientHandlerState move(MovePacket packet) {
        return this;
    }
}
package rolit.model.networking.server;

import rolit.model.networking.common.Packet;
import rolit.model.networking.common.PacketArgs;

public class HandshakePacket extends Packet {
    private int supports;
    private String version;
    private String nonce;

    public HandshakePacket(int supports, String version, String nonce) {
        this.supports = supports;
        this.version = version;
        this.nonce = nonce;
    }

    public HandshakePacket(int supports, String version) {
        this(supports, version, null);
    }

    @Override
    protected void readFromArgs(PacketArgs args) {
        this.supports = args.getInt(0);
        this.version = args.getString(1);
        this.nonce = args.getMultiString(2).length == 1 ? args.getMultiString(2)[0] : null;
    }

    @Override
    protected PacketArgs.ArgumentType[] getArgumentTypes() {
        return new PacketArgs.ArgumentType[] { PacketArgs.ArgumentType.Integer, PacketArgs.ArgumentType.String, PacketArgs.ArgumentType.MultiString };
    }

    @Override
    protected Object[] getData() {
        return new Object[] { supports, version, nonce == null ? new String[] {  } : new String[] { nonce } };
    }
}
package rolit.model.networking.server;

import rolit.model.networking.client.StartGamePacket;

public class ChallengerClientHandlerState extends ClientHandlerState {
    public ChallengerClientHandlerState(ClientHandler handler) {
        super(handler);
    }

    @Override
    public ClientHandlerState startGame(StartGamePacket packet) {
        return new GameClientHandlerState();
    }
}
package rolit.model.networking.server;

import rolit.model.networking.common.Packet;
import rolit.model.networking.common.PacketArgs;

public class HighscorePacket extends Packet {
    private String[] data;

    public HighscorePacket(String[] data) {
        this.data = data;
    }

    public String[] getDataField() {
        return data;
    }

    @Override
    protected void readFromArgs(PacketArgs args) {
        this.data = args.getMultiString(0);
    }

    @Override
    protected PacketArgs.ArgumentType[] getArgumentTypes() {
        return new PacketArgs.ArgumentType[] { PacketArgs.ArgumentType.MultiString };
    }

    @Override
    protected Object[] getData() {
        return new Object[] { data };
    }
}
package rolit.model.networking.server;

import rolit.model.networking.client.ChallengePacket;
import rolit.model.networking.client.CreateGamePacket;
import rolit.model.networking.client.JoinGamePacket;

public class GameLobbyClientHandlerState extends ClientHandlerState {
    public GameLobbyClientHandlerState(ClientHandler handler) {
        super(handler);
        getHandler().write(new HandshakePacket(Server.GLOBAL_SUPPORTS, Server.GLOBAL_VERSION));
    }

    @Override
    public ClientHandlerState challenge(ChallengePacket packet) {
        return new ChallengerClientHandlerState(getHandler());
    }

    @Override
    public ClientHandlerState joinGame(JoinGamePacket packet) {
        return new WaitForGameClientHandlerState(getHandler(), packet.getCreator());
    }

    @Override
    public ClientHandlerState createGame(CreateGamePacket packet) {
        return new WaitForGameClientHandlerState(getHandler(), getHandler().getClientName());
    }
}
package rolit.model.networking.server;

import rolit.model.networking.common.Packet;
import rolit.model.networking.common.PacketArgs;

public class MoveDonePacket extends Packet {
    private String user;
    private int x;
    private int y;

    public MoveDonePacket(String user, int x, int y) {
        this.user = user;
        this.x = x;
        this.y = y;
    }

    public String getUser() {
        return user;
    }

    public int getX() {
        return x;
    }

    public int getY() {
        return y;
    }

    @Override
    protected void readFromArgs(PacketArgs args) {
        this.user = args.getString(0);
        this.x = args.getInt(1);
        this.y = args.getInt(2);
    }

    @Override
    protected PacketArgs.ArgumentType[] getArgumentTypes() {
        return new PacketArgs.ArgumentType[] { PacketArgs.ArgumentType.String, PacketArgs.ArgumentType.Integer, PacketArgs.ArgumentType.Integer };
    }

    @Override
    protected Object[] getData() {
        return new Object[] { user, x, y };
    }
}
package rolit.model.networking.client;

import rolit.model.networking.common.CommonProtocol;

/**
 * @author Pieter Bos
 * @author Martijn de Bijl
 *
 * Abstract class met alle constanten en methodes die gebruikt kunnen worden
 */
public abstract class ClientProtocol extends CommonProtocol {
    /**
     * Constante voor het handshake-commando
     */
    public static final String HANDSHAKE = "hello";

    /**
     * Constante voor het auth-commando
     */
    public static final String AUTH = "auth";

    /**
     * Constante voor het create-gamecommando
     */
    public static final String CREATE_GAME = "createGame";

    /**
     * Constante voor het join-gamecommando
     */
    public static final String JOIN_GAME = "joinGame";

    /**
     * Constante voor het start-gamecommando
     */
    public static final String START_GAME = "startGame";

    /**
     * Constante voor het movecommando
     */
    public static final String MOVE = "move";

    /**
     * Constante voor het messagecommando
     */
    public static final String MESSAGE = "message";

    /**
     * Constante voor het challengecommando
     */
    public static final String CHALLENGE = "challenge";

    /**
     * Constante voor het challenge-responsecommando
     */
    public static final String CHALLENGE_RESPONSE = "challengeResponse";

    /**
     * Constante voor het highscorecommando
     */
    public static final String HIGHSCORE = "highscore";

    /**
     * Handshake voor de server. Moet altijd het eerste verzonden pakket zijn, met uitzondering van de errors.
     * @requires Dat de handshake nog niet is ontvangen
     * @requires Dat dit het eerste pakket op de communicatelijn is.
     * @param clientName Naam van de client.
     * @param supports Wat de client ondersteunt.
     * @param version Een beschrijving van wat de client kan.
     */
    public abstract void hello(String clientName, int supports, String version);

    /**
     * Authenticatie van de client.
     * @requires Dat de handshake is gedaan.
     * @requires Dat de client de private key heeft opgehaald bij ss-security.student.utwente.nl met de verstuurde
     * private key en bijbehorend wachtwoord.
     * @requires Dat de nonce die door de server is gestuurd is gesigned met de private key.
     * @param signature De gesignde nonce
     */
    public abstract void auth(String signature);

    /**
     * Maak een spel
     * @requires Dat de handshake is gedaan.
     * @requires Dat de client nog geen spel is begonnen
     */
    public abstract void createGame();

    /**
     * Join een spel
     * @requires Dat de handshake is gedaan.
     * @requires Dat de speler nog niet in een spel zit.
     * @requires Dat het spel nog niet vol zit.
     * @param creator De maker van het spel
     */
    public abstract void joinGame(String creator);

    /**
     * @requires Dat de handshake is gedaan.
     * @requires Dat de speler in een spel zit.
     * @requires Dat de speler de creator van het spel is.
     * @requires Dat het spel nog niet is gestart.
     * Start het spel waarvan de gebruiker de creator is.
     */
    public abstract void startGame();

    /**
     * Doe een zet
     * @requires Dat de handshake is gedaan.
     * @requires Dat de speler in een spel zit
     * @requires Dat de speler een move-commando heeft ontvangen.
     * @param x X-coördinaat
     * @param y Y-coördinaat
     */
    public abstract void move(int x, int y);

    /**
     * @requires Dat de handshake is gedaan.
     * @requires Dat de server chat-berichten ondersteunt.
     * Stuur een bericht naar iedereen in de lobby of iedereen in het spel
     * @param body Het bericht
     */
    public abstract void message(String body);

    /**
     * Daag één ander uit voor een spel
     * @requires Dat de handshake is gedaan.
     * @requires Dat de speler niet in een spel zit.
     * @requires Dat de speler niet een uitdager is.
     * @requires Dat de speler niet al is uitgedaagd.
     * @requires Dat de uitgedaagde(n) kunnen worden uitgedaagd.
     * @param other De ander
     */
    public abstract void challenge(String other);

    /**
     * Daag twee anderen uit voor een spel
     * @requires Dat de requirements bij de andere overload worden voldaan.
     * @param other1 De een
     * @param other2 De ander
     */
    public abstract void challenge(String other1, String other2);

    /**
     * Daag drie anderen uit voor een spel
     * @requires Dat de requirements bij de andere overload worden voldaan.
     * @param other1 De eerste andere
     * @param other2 De tweede andere
     * @param other3 De derder andere
     */
    public abstract void challenge(String other1, String other2, String other3);

    /**
     * Reageer op een uitdaging
     * @requires Dat de handshake is gedaan.
     * @requires Dat de speler is uitgedaagd.
     * @param accept Of de client accepteert
     */
    public abstract void challengeResponse(boolean accept);

    /**
     * Vraag highscores op bij de server
     * @requires Dat de handshake is gedaan
     * @requires Dat wanneer het type één van "date" of "player" is, arg respectievelijk van het volgende formaat is:
     *           * yyyy-[m]m-[d]d
     *           * SpelerNaamZonderSpaties
     * @param type Type highscore (bijv. date, player)
     * @param arg Een argument (bijv. 2014-01-01)
     */
    public abstract void highscore(String type, String arg);
}
package rolit.model.networking.client;

import rolit.model.networking.common.Packet;
import rolit.model.networking.common.PacketArgs;

public class StartGamePacket extends Packet {
    public StartGamePacket() {

    }

    @Override
    protected void readFromArgs(PacketArgs args) {

    }

    @Override
    protected PacketArgs.ArgumentType[] getArgumentTypes() {
        return new PacketArgs.ArgumentType[] {  };
    }

    @Override
    protected Object[] getData() {
        return new Object[] {  };
    }
}
package rolit.model.networking.client;

import rolit.model.networking.common.Packet;
import rolit.model.networking.common.PacketArgs;

public class MessagePacket extends Packet {
    private String message;

    public MessagePacket(String message) {

        this.message = message;
    }

    public String getMessage() {
        return message;
    }

    @Override
    protected void readFromArgs(PacketArgs args) {
        this.message = args.getString(0);
    }

    @Override
    protected PacketArgs.ArgumentType[] getArgumentTypes() {
        return new PacketArgs.ArgumentType[] { PacketArgs.ArgumentType.String };
    }

    @Override
    protected Object[] getData() {
        return new Object[] { message };
    }
}
package rolit.model.networking.client;

import rolit.model.networking.common.Packet;
import rolit.model.networking.common.PacketArgs;

public class ChallengeResponsePacket extends Packet {
    private boolean response;

    public ChallengeResponsePacket(boolean response) {
        this.response = response;
    }

    public boolean isResponse() {
        return response;
    }

    @Override
    protected void readFromArgs(PacketArgs args) {
        this.response = args.getBool(0);
    }

    @Override
    protected PacketArgs.ArgumentType[] getArgumentTypes() {
        return new PacketArgs.ArgumentType[] { PacketArgs.ArgumentType.Boolean };
    }

    @Override
    protected Object[] getData() {
        return new Object[] { response };
    }
}
package rolit.model.networking.client;

import rolit.model.networking.common.Packet;
import rolit.model.networking.common.PacketArgs;

public class MovePacket extends Packet {
    private int x;
    private int y;

    public MovePacket(int x, int y) {
        this.x = x;
        this.y = y;
    }

    public int getX() {
        return x;
    }

    public int getY() {
        return y;
    }

    @Override
    protected void readFromArgs(PacketArgs args) {
        this.x = args.getInt(0);
        this.y = args.getInt(1);
    }

    @Override
    protected PacketArgs.ArgumentType[] getArgumentTypes() {
        return new PacketArgs.ArgumentType[] { PacketArgs.ArgumentType.Integer, PacketArgs.ArgumentType.Integer };
    }

    @Override
    protected Object[] getData() {
        return new Object[] { x, y };
    }
}
package rolit.model.networking.client;

import rolit.model.networking.common.Packet;
import rolit.model.networking.common.PacketArgs;

public class CreateGamePacket extends Packet {
    public CreateGamePacket() {

    }

    @Override
    protected void readFromArgs(PacketArgs args) {

    }

    @Override
    protected PacketArgs.ArgumentType[] getArgumentTypes() {
        return new PacketArgs.ArgumentType[] {  };
    }

    @Override
    protected Object[] getData() {
        return new Object[] {  };
    }
}
package rolit.model.networking.client;

import rolit.model.networking.common.Packet;
import rolit.model.networking.common.PacketArgs;

public class ChallengePacket extends Packet {

    private String[] challenged;

    public ChallengePacket(String[] challenged) {
        this.challenged = challenged;
    }

    public String[] getChallenged() {
        return challenged;
    }

    @Override
    protected void readFromArgs(PacketArgs args) {
        this.challenged = args.getMultiString(0);
    }

    @Override
    protected PacketArgs.ArgumentType[] getArgumentTypes() {
        return new PacketArgs.ArgumentType[] { PacketArgs.ArgumentType.MultiString };
    }

    @Override
    protected Object[] getData() {
        return new Object[] { challenged };
    }
}
package rolit.model.networking.client;

import rolit.model.networking.common.Packet;
import rolit.model.networking.common.PacketArgs;

public class JoinGamePacket extends Packet {

    private String creator;

    public JoinGamePacket(String creator) {
        this.creator = creator;
    }

    public String getCreator() {
        return creator;
    }

    @Override
    protected void readFromArgs(PacketArgs args) {
        this.creator = args.getString(0);
    }

    @Override
    protected PacketArgs.ArgumentType[] getArgumentTypes() {
        return new PacketArgs.ArgumentType[] { PacketArgs.ArgumentType.String };
    }

    @Override
    protected Object[] getData() {
        return new Object[] { creator };
    }
}
package rolit.model.networking.client;

import rolit.model.networking.common.Packet;
import rolit.model.networking.common.PacketArgs;

public class HandshakePacket extends Packet {
    private String name;
    private int supports;
    private String version;

    public HandshakePacket(String name, int supports, String version) {

        this.name = name;
        this.supports = supports;
        this.version = version;
    }

    @Override
    protected void readFromArgs(PacketArgs args) {
        this.name = args.getString(0);
        this.supports = args.getInt(1);
        this.version = args.getString(2);
    }

    @Override
    protected PacketArgs.ArgumentType[] getArgumentTypes() {
        return new PacketArgs.ArgumentType[] { PacketArgs.ArgumentType.Integer, PacketArgs.ArgumentType.String };
    }

    @Override
    protected Object[] getData() {
        return new Object[] { name, supports, version };
    }

    public String getName() {
        return name;
    }

    public int getSupports() {
        return supports;
    }

    public String getVersion() {
        return version;
    }
}
package rolit.model.networking.client;

import rolit.model.networking.common.Packet;
import rolit.model.networking.common.PacketArgs;

public class AuthPacket extends Packet {
    private String cypherText;

    public AuthPacket(String cypherText) {
        this.cypherText = cypherText;
    }

    public String getCypherText() {
        return cypherText;
    }

    @Override
    protected void readFromArgs(PacketArgs args) {
        this.cypherText = args.getString(0);
    }

    @Override
    protected PacketArgs.ArgumentType[] getArgumentTypes() {
        return new PacketArgs.ArgumentType[] { PacketArgs.ArgumentType.String };
    }

    @Override
    protected Object[] getData() {
        return new Object[] { cypherText };
    }
}
package rolit.model.networking.client;

import rolit.model.networking.common.Packet;
import rolit.model.networking.common.PacketArgs;

public class HighscorePacket extends Packet {
    private String type;
    private String arg;

    public HighscorePacket(String type, String arg) {
        this.type = type;
        this.arg = arg;
    }

    public String getType() {
        return type;
    }

    public String getArg() {
        return arg;
    }

    @Override
    protected void readFromArgs(PacketArgs args) {
        this.type = args.getString(0);
        this.arg = args.getString(1);
    }

    @Override
    protected PacketArgs.ArgumentType[] getArgumentTypes() {
        return new PacketArgs.ArgumentType[] { PacketArgs.ArgumentType.String, PacketArgs.ArgumentType.String };
    }

    @Override
    protected Object[] getData() {
        return new Object[] { type, arg };
    }
}
package rolit.model.game;

/**
 * Created by Martijn on 20-1-14.
 */
public class Player {

    private final int color;

    public Player(int nummer) {
        this.color = nummer;
    }


    public int getColor() {
        return color;
    }
}
package rolit.model.game;

/**
 * Created by Martijn on 20-1-14.
 */
public class Position {

    private int y;
    private int x;

    public Position(int x, int y){
        this.x = x;
        this.y = y;
    }

    public int getX(){
        return x;
    }

    public int getY(){
        return y;
    }


    public Position add(Position direction) {
        Position result = new Position(this.getX() + direction.getX(), this.getY() + direction.getY());
        return result;
    }

    public Position runVector(Position position){
        int x = position.getX();
        int y = position.getY();
        return new Position(x,y);
    }
}
package rolit.model.game;

public class Game {

    private final int players;
    private final Board board;
    private int currentPlayer;

    public Game(int players){
        this.players = players;
        board = new Board();
        currentPlayer = 0;
    }

    public int getPlayers() {
        return players;
    }

    public Board getBoard() {
        return board;
    }

    public int getCurrentPlayer() {
        return currentPlayer;
    }

    public boolean legalMove(Board board){
        return true;
    }



}
package rolit.model.game;

import java.util.LinkedList;

/**
 * The board class
 *
 * @author Martijn de Bijl
 */
public class Board {
    /**
     * De standaard hoogte voor het bord.
     */
    public static final int BOARD_WIDTH = 8;
    /**
     * De standaard breedte van het bord.
     */
    public static final int BOARD_HEIGHT = 8;
    /**
     * De variabele die een leeg veld aangeeft.
     */
    public static final int EMPTY_FIELD = 9;

    /**
     * De array waarin de informatie van het bord is opgeslagen.
     */
    private int[][] array;

    /**
     * Alle richtingen waarin gekeken moet worden naar aanliggende kleuren
     */
    private static Position[] DIRECTIONS = {
            new Position(-1, -1),
            new Position(-1, 0),
            new Position(-1, 1),
            new Position(1, 0),
            new Position(1, -1),
            new Position(1, 1),
            new Position(0, 1),
            new Position(0, -1)
    };

    /**
     * Constructor voor klasse bord. Hierin wordt de array aangemaakt en gevuld met legen velden en de 4 balletje in
     * het midden.
     */
    public Board() {
        array = new int[BOARD_WIDTH][BOARD_HEIGHT];
        for (int x = 0; x < BOARD_WIDTH; x++) {
            for (int y = 0; y < BOARD_HEIGHT; y++) {
                array[x][y] = EMPTY_FIELD;
                array[x][y] = EMPTY_FIELD;
            }
        }
        array[3][3] = 0;
        array[4][3] = 1;
        array[4][4] = 2;
        array[3][4] = 3;

    }

    /**
     * Geeft terug waarmee een bepaald veld gevuld is.
     *
     * @param x de x-coördinaat, oftewel horizontale positie op het bord.
     * @param y de y-coördinaat, oftwel vericale positie op het bord.
     * @return geeft een integer terug die de kleur van de speler, of een leeg veld aangeeft.
     */
    public int getField(int x, int y) {
        return array[x][y];
    }

    /**
     * Geeft terug waarmee een bepaald veld gevuld is.
     *
     * @param position de positie van het veld, gegeven in een vector met een x en y coördinaat.
     * @return geeft een integer terug die de kleur van de speler, of een leeg veld aangeeft.
     */
    public int getField(Position position) {
        int x = (position.getX());
        int y = (position.getY());
        return array[x][y];
    }

    /**
     * Vult een bepaald veld met een kleur van een speler.
     * @param x     de x-coördinaat, oftewel horizontale positie op het bord.
     * @param y     de y-coördinaat, oftwel vericale positie op het bord.
     * @param field de integer die de kleur van de speler aangeeft.
     */
    public void setField(int x, int y, int field) {
        array[x][y] = field;
    }

    /**
     * Vult een bepaald veld met een kleur van een speler.
     * @param position de positie van het veld, gegeven in een vector met een x en y coördinaat.
     * @param field de integer die de kleur van de speler aangeeft.
     */
    public void setField(Position position, int field){
        array[position.getX()][position.getY()] = field;
    }

    /**
     * Geeft terug of een veld leeg is.
     * @param x de x-coördinaat, oftewel horizontale positie op het bord.
     * @param y de y-coördinaat, oftwel vericale positie op het bord.
     * @return een boolean of het veld leeg is.
     */
    public boolean isEmpty(int x, int y) {
        if (array[x][y] == EMPTY_FIELD) {
            return true;
        } else {
            return false;
        }
    }

    /**
     * Geeft terug of een veld leeg is.
     * @param position de positie van het veld, gegeven in een vector met een x en y coördinaat.
     * @return een boolean of het veld leeg is.
     */
    public boolean isEmpty(Position position) {
        if (array[position.getX()][position.getY()] == EMPTY_FIELD) {
            return true;
        } else {
            return false;
        }
    }

    /**
     * Maakt een kopie van het huidige bord.
     * @return een nieuw bord met alle informatie van het huidige bord.
     */
    public Board copy() {
        Board copy = new Board();
        for (int x = 0; x <= BOARD_WIDTH; x++) {
            for (int y = 0; y <= BOARD_HEIGHT; y++) {
                copy.setField(x, y, getField(x, y));
            }
        }
        return copy;
    }

    /**
     * Kijkt op een bepaald veld in alle richtingen welke slagen mogelijk zijn.
     *
     * @param player       de speler die de zet wil doen.
     * @param movePosition het veld waarop de speler de zet wil doen.
     * @return een array met alle slagen die mogelijk zijn.
     */
    public Capture[] getCapture(Player player, Position movePosition) {
        Position position = new Position(movePosition.getX(), movePosition.getY());
        LinkedList<Capture> captures = new LinkedList<Capture>();
        int length = 0;

        if (this.isEmpty(position) == false) {
            Capture[] capture = new Capture[0];
            return capture;
        } else {
            for (Position direction : DIRECTIONS) {
                Position checkField = new Position(position.add(direction).getX(), position.add(direction).getY());
                while (this.getField(checkField) != player.getColor() && this.getField(checkField) != EMPTY_FIELD) {
                    checkField = checkField.add(direction);
                    length++;
                }
                if (this.getField(checkField.add(direction)) == player.getColor() && length > 1) {
                    captures.add(new Capture(checkField, length));
                }
            }

            Capture[] result = new Capture[captures.size()];
            captures.toArray(result);
            return result;
        }
    }

    /**
     * Kijkt of een zet legaal is.
     *
     * @param player       de speler die de zet wil doen.
     * @param movePosition het veld waarop de speler de zet wil doen.
     * @return een boolean of de zet legaal is.
     */
    public boolean isLegalMove(Player player, Position movePosition) {
        Position position = new Position(movePosition.getX(), movePosition.getY());
        Capture[] captures = getCapture(player, position);

        if (captures.length != 0) {
            return true;
        }

        for (Position directions : DIRECTIONS) {
            if (this.getField(position.add(directions)) == EMPTY_FIELD) {
                return false;
            }
        }

        for (int y = 0; y < BOARD_HEIGHT; y++) {
            for (int x = 0; x < BOARD_WIDTH; x++) {
                Position checkField = new Position(x, y);
                if (getCapture(player, checkField).length > 0) {
                    return false;
                }
            }
        }
        return true;
    }

    /**
     * Doet de zet van een speler, en verandert alle kleuren naar zijn kleur van de geslagen balletjes.
     * @param player de speler die de zet doet.
     * @param movePosition het veld waarop de speler de zet wil doen.
     * @return een boolean of de zet gelukt is.
     */
    public boolean doMove(Player player, Position movePosition){
        if (isLegalMove(player,movePosition) == true){
            Capture[] captures = getCapture(player, movePosition);
            setField(movePosition, player.getColor());

            for(Capture capture : captures){
                for (int i = 0; i < captures.length; i++){
                    int x = (capture.getDirection().getX() + i * (capture.getDirection().getX()));
                    int y = (capture.getDirection().getY() + i * (capture.getDirection().getY()));
                    Position seize = new Position(x,y);
                    setField(seize, player.getColor());
                }
            }
            return true;
        }
        else {
            return false;
        }
    }

    /**
     * Maakt een visuele representatie van het huidige bord.
     *
     * @return een string zo geformat dat het bord leesbaar is.
     */
    public String toString() {
        String result = "+-+-+-+-+-+-+-+-+\n";
        for (int y = 0; y < BOARD_HEIGHT; y++) {
            boolean first = true;

            for (int x = 0; x < BOARD_WIDTH; x++) {
                if (first) {
                    result += "|";
                }

                first = false;

                result += getField(x, y) == EMPTY_FIELD ? " " : getField(x, y);

                result += "|";
            }

            result += "\n+-+-+-+-+-+-+-+-+\n";
        }
        return result;
    }

}
package rolit.model.game;

/**
 * Created by Martijn on 20-1-14.
 */
public class Capture {

    private int length;
    private Position direction;

    public Capture(Position direction, int length){
        this.length = length;
        this.direction = direction;
    }

    public int getLength(){
        return length;
    }

    public Position getDirection(){
        return direction;
    }


}
package rolit.model.game;

/**
 * Created by Martijn on 20-1-14.
 */
public class Vector {

    private int y;
    private int x;

    public Vector(int x, int y){
        this.x = x;
        this.y = y;
    }

    public int getX(){
        return x;
    }

    public int getY(){
        return y;
    }


    public Vector add(Vector direction) {
        Vector result = new Vector(this.getX() + direction.getX(), this.getY() + direction.getY());
        return result;
    }

    public Vector runVector(Vector vector){
        int x = vector.getX();
        int y = vector.getY();
        return new Vector(x,y);
    }
}
package rolit.model.event;

import rolit.model.networking.server.ClientHandler;

public interface ServerListener {
    public void serverError(String reason);
    public void newClient(ClientHandler handler);
    public void clientError(String reason);
}
package rolit.model.pietergame;

/**
 * Created by Martijn on 20-1-14.
 */
public class Position {
    public Position(int x, int y) {

    }
}
package rolit.model.pietergame;

import rolit.common.Position;

import java.util.LinkedList;

public class Board {
    public static int WIDTH = 8;
    public static int HEIGHT = 8;

    public static int NO_PLAYER = -1;

    private static Position[] DIRECTIONS = {
        new Position(-1, -1),
        new Position(0, -1),
        new Position(1, -1),
        new Position(-1, 0),
        new Position(1, 0),
        new Position(-1, 1),
        new Position(0, 1),
        new Position(1, 1),
    };

    private int[][] board = new int[WIDTH][HEIGHT];

    public Board() {
        for(int x = 0; x < WIDTH; x++) {
            for(int y = 0; y < HEIGHT; y++) {
                board[x][y] = NO_PLAYER;
            }
        }

        int middleX = WIDTH / 2 - 1;
        int middleY = HEIGHT / 2 - 1;

        board[middleX][middleY] = 0;
        board[middleX + 1][middleY] = 1;
        board[middleX][middleY + 1] = 2;
        board[middleX + 1][middleY + 1] = 3;
    }

    public int get(Position position) {
        return board[position.getX()][position.getY()];
    }

    private void set(Position position, int player) {
        board[position.getX()][position.getY()] = player;
    }

    public Capture[] getCaptures(int player, Position movePosition) {
        LinkedList<Capture> captures = new LinkedList<Capture>();

        for(Position direction : DIRECTIONS) {
            for(int length = Math.max(WIDTH, HEIGHT); length >= 2; length--) {
                Position position = movePosition.add(direction.scalarMultiply(length));

                if(position.inRectangle(WIDTH, HEIGHT) && get(position) == player) {
                    boolean anyOther = false;
                    boolean filled = true;

                    for(int i = 1; i < length; i++) {
                        Position innerPosition = movePosition.add(direction.scalarMultiply(i));

                        if(innerPosition.inRectangle(WIDTH, HEIGHT)) {
                            if(get(innerPosition) == NO_PLAYER) {
                                filled = false;
                            } else if(get(innerPosition) != player) {
                                anyOther = true;
                            }
                        }
                    }

                    if(filled && anyOther) {
                        captures.add(new Capture(direction, length));
                        break;
                    }
                }
            }
        }

        Capture[] result = new Capture[captures.size()];
        captures.toArray(result);
        return result;
    }

    public boolean isValidMove(int player, Position movePosition) {
        boolean adjacent = false;

        for(Position direction : DIRECTIONS) {
            Position position = movePosition.add(direction);

            if(position.inRectangle(WIDTH, HEIGHT) && get(position) != NO_PLAYER) {
                adjacent = true;
                break;
            }
        }

        if(!adjacent) {
            return false;
        }

        // Ensured that the move is adjacent to any other ball

        if(getCaptures(player, movePosition).length > 0) {
            return true;
        }

        // Player didn't do a block and capture

        for(int x = 0; x < WIDTH; x++) {
            for(int y = 0; y < HEIGHT; y++) {
                Position currentPosition = new Position(x, y);

                if(get(currentPosition) != NO_PLAYER) {
                    continue;
                }

                if(getCaptures(player, movePosition).length > 0) {
                    // Block and capture was possible, but player didn't do it
                    return false;
                }
            }
        }

        // Block and capture impossible, so the move is valid
        return true;
    }

    public boolean doMove(int player, Position movePosition) {
        if(isValidMove(player, movePosition)) {
            Capture[] captures = getCaptures(player, movePosition);

            set(movePosition, player);

            for(Capture capture : captures) {
                for(int i = 1; i < capture.getLength(); i++) {
                    Position position = movePosition.add(capture.getDirection().scalarMultiply(i));
                    set(position, player);
                }
            }

            return true;
        } else {
            return false;
        }
    }

    @Override
    public String toString() {
        String result = "";

        for(int y = 0; y < HEIGHT; y++) {
            for(int x = 0; x < WIDTH; x++) {
                result += " 0123".charAt(board[x][y] + 1);
            }

            result += "\n";
        }

        return result;
    }

    public static void main(String[] args) {
        Board b = new Board();

        System.out.print(b);

        System.out.println(b.doMove(2, new Position(5, 2)));

        System.out.print(b);
    }
}
import rolit.common.Position;

public class Capture {

    private final int length;
    private final Position direction;

    public Capture(Position direction, int length) {
        this.length = length;
        this.direction = direction;
    }

    public int getLength() {
        return length;
    }

    public Position getDirection() {
        return direction;
    }

}
package rolit.util;

public class Strings {
    public static String join(String delimiter, String[] strings) {
        String result = "";
        boolean first = true;

        for(String string : strings) {
            if(!first) {
                result += delimiter;
            }

            first = false;

            result += string;
        }

        return result;
    }
}
