package rolit.view.layout;

import java.awt.*;

/**
 * @author Pieter Bos
 *
 * Lays out exactly two components stacked vertically, splitting at a given distance from the top or bottom.
 */
public class VSplitLayoutManager implements LayoutManager {
    public enum VSplitType {
        Top,
        Bottom
    }

    private static final int DEFAULT_SPLIT = 24;
    private static final VSplitType DEFAULT_TYPE = VSplitType.Top;

    private VSplitType splitType;
    private int split;

    public VSplitLayoutManager(int split, VSplitType type) {
        this.splitType = type;
        this.split = split;
    }

    public VSplitLayoutManager(int split) {
        this(split, DEFAULT_TYPE);
    }

    public VSplitLayoutManager(VSplitType type) {
        this(DEFAULT_SPLIT, type);
    }

    public VSplitLayoutManager() {
        this(DEFAULT_TYPE);
    }

    @Override
    public void addLayoutComponent(String name, Component comp) {
    }

    @Override
    public void removeLayoutComponent(Component comp) {
    }

    @Override
    public Dimension preferredLayoutSize(Container parent) {
        return parent.getParent().getMinimumSize();
    }

    @Override
    public Dimension minimumLayoutSize(Container parent) {
        Dimension size1 = parent.getComponent(0).getMinimumSize();
        Dimension size2 = parent.getComponent(1).getMinimumSize();
        return new Dimension(Math.max(size1.width, size2.width), size1.height + size2.height);
    }

    @Override
    public void layoutContainer(Container parent) {
        Dimension parentSize = parent.getSize();
        Dimension size1 = parent.getComponent(0).getPreferredSize();
        Dimension size2 = parent.getComponent(1).getPreferredSize();

        if(splitType == VSplitType.Top) {
            parent.getComponent(0).setBounds(0, 0, parentSize.width, split);
            parent.getComponent(1).setBounds(0, split, parentSize.width, parentSize.height - split);
        } else {
            parent.getComponent(0).setBounds(0, 0, parentSize.width, parentSize.height - split);
            parent.getComponent(1).setBounds(0, parentSize.height - split, parentSize.width, split);
        }
    }
}
package rolit.view.layout;

import java.awt.*;

/**
 * @author Pieter Bos
 *
 * Lays out all components horizontally with a given gap, aligned to the top.
 */
public class HBoxLayoutManager implements LayoutManager {
    private static final int DEFAULT_GAP = 8;

    private int gap;

    public HBoxLayoutManager(int gap) {
        this.gap = gap;
    }

    public HBoxLayoutManager() {
        this(DEFAULT_GAP);
    }

    @Override
    public void addLayoutComponent(String name, Component comp) {
    }

    @Override
    public void removeLayoutComponent(Component comp) {
    }

    @Override
    public Dimension preferredLayoutSize(Container parent) {
        int max = 0;
        int totalWidth = 0;

        for(int i = parent.getComponentCount() - 1; i >= 0; i--) {
            if(parent.getComponent(i).getMinimumSize().height > max) {
                max = parent.getComponent(i).getMinimumSize().height;
            }

            totalWidth += parent.getComponent(i).getMinimumSize().width;
        }

        return new Dimension(totalWidth + (parent.getComponentCount() - 1) * gap, max);
    }

    @Override
    public Dimension minimumLayoutSize(Container parent) {
        return preferredLayoutSize(parent);
    }

    @Override
    public void layoutContainer(Container parent) {
        int currentX = 0;

        int components = parent.getComponentCount();

        for(int i = 0; i < components; i++) {
            Component component = parent.getComponent(i);
            component.setBounds(currentX, 0, component.getPreferredSize().width, component.getPreferredSize().height);

            currentX += component.getPreferredSize().width + gap;
        }
    }
}
package rolit.view.layout;

import java.awt.*;

/**
 * @author Pieter Bos
 *
 * Always centers a single component.
 */
public class CenterLayoutManager implements LayoutManager {
    @Override
    public void addLayoutComponent(String name, Component comp) {
    }

    @Override
    public void removeLayoutComponent(Component comp) {
    }

    @Override
    public Dimension preferredLayoutSize(Container parent) {
        Component component = parent.getComponent(0);
        return component.getMinimumSize();
    }

    @Override
    public Dimension minimumLayoutSize(Container parent) {
        return preferredLayoutSize(parent);
    }

    @Override
    public void layoutContainer(Container parent) {
        Dimension parentSize = parent.getSize();
        Component component = parent.getComponent(0);
        Dimension componentSize = component.getPreferredSize();
        component.setBounds((parentSize.width - componentSize.width) / 2, (parentSize.height - componentSize.height) / 2, componentSize.width, componentSize.height);
    }
}
package rolit.view.layout;

import java.awt.*;

/**
 * @author Pieter Bos
 *
 * Stacks all components vertically with a given gap. The components are left-aligned.
 */
public class VBoxLayoutManager implements LayoutManager {
    private static final int DEFAULT_GAP = 8;

    private int gap;

    public VBoxLayoutManager(int gap) {
        this.gap = gap;
    }

    public VBoxLayoutManager() {
        this(DEFAULT_GAP);
    }

    @Override
    public void addLayoutComponent(String name, Component comp) {
    }

    @Override
    public void removeLayoutComponent(Component comp) {
    }

    @Override
    public Dimension preferredLayoutSize(Container parent) {
        int max = 0;
        int totalHeight = 0;

        for(int i = parent.getComponentCount() - 1; i >= 0; i--) {
            if(parent.getComponent(i).getMinimumSize().width > max) {
                max = parent.getComponent(i).getMinimumSize().width;
            }

            totalHeight += parent.getComponent(i).getMinimumSize().height;
        }

        return new Dimension(max, totalHeight + (parent.getComponentCount() - 1) * gap);
    }

    @Override
    public Dimension minimumLayoutSize(Container parent) {
        return preferredLayoutSize(parent);
    }

    @Override
    public void layoutContainer(Container parent) {
        int currentY = 0;

        int components = parent.getComponentCount();

        for(int i = 0; i < components; i++) {
            Component component = parent.getComponent(i);
            component.setBounds(0, currentY, component.getPreferredSize().width, component.getPreferredSize().height);

            currentY += component.getPreferredSize().height + gap;
        }
    }
}
package rolit.view.layout;

import java.awt.*;

public class HSplitLayoutManager implements LayoutManager {
    public enum HSplitType {
        Left,
        Right
    }

    private static final int DEFAULT_SPLIT = 24;
    private static final HSplitType DEFAULT_TYPE = HSplitType.Left;

    private HSplitType splitType;
    private int split;

    public HSplitLayoutManager(int split, HSplitType type) {
        this.splitType = type;
        this.split = split;
    }

    public HSplitLayoutManager(int split) {
        this(split, DEFAULT_TYPE);
    }

    public HSplitLayoutManager(HSplitType type) {
        this(DEFAULT_SPLIT, type);
    }

    public HSplitLayoutManager() {
        this(DEFAULT_TYPE);
    }

    @Override
    public void addLayoutComponent(String name, Component comp) {
    }

    @Override
    public void removeLayoutComponent(Component comp) {
    }

    @Override
    public Dimension preferredLayoutSize(Container parent) {
        return parent.getParent().getMinimumSize();
    }

    @Override
    public Dimension minimumLayoutSize(Container parent) {
        Dimension size1 = parent.getComponent(0).getMinimumSize();
        Dimension size2 = parent.getComponent(1).getMinimumSize();
        return new Dimension(size1.width + size2.width, Math.max(size1.height, size2.height));
    }

    @Override
    public void layoutContainer(Container parent) {
        Dimension parentSize = parent.getSize();
        Dimension size1 = parent.getComponent(0).getPreferredSize();
        Dimension size2 = parent.getComponent(1).getPreferredSize();

        if(splitType == HSplitType.Left) {
            parent.getComponent(0).setBounds(0, 0, split, parentSize.height);
            parent.getComponent(1).setBounds(split, 0, parentSize.width - split, parentSize.height);
        } else {
            parent.getComponent(0).setBounds(0, 0, parentSize.width - split, parentSize.height);
            parent.getComponent(1).setBounds(parentSize.width - split, 0, split, parentSize.height);
        }
    }
}
package rolit.view.layout;

import java.awt.*;

/**
 * @author Pieter Bos
 *
 * Lays out exactly two components left and right, with a given minimum gap.
 */
public class LeftRightLayoutManager implements LayoutManager {
    private static final int DEFAULT_MINIMUM_GAP = 8;

    private int minimumGap;

    public LeftRightLayoutManager(int minimumGap) {
        this.minimumGap = minimumGap;
    }

    public LeftRightLayoutManager() {
        this(DEFAULT_MINIMUM_GAP);
    }

    @Override
    public void addLayoutComponent(String name, Component comp) {
    }

    @Override
    public void removeLayoutComponent(Component comp) {
    }

    @Override
    public Dimension preferredLayoutSize(Container parent) {
        int width = Math.max(minimumLayoutSize(parent).width, parent.getParent().getPreferredSize().width);
        int height = minimumLayoutSize(parent).height;
        return new Dimension(width, height);
    }

    @Override
    public Dimension minimumLayoutSize(Container parent) {
        Dimension size1 = parent.getComponent(0).getPreferredSize();
        Dimension size2 = parent.getComponent(1).getPreferredSize();
        return new Dimension(size1.width + size2.width + minimumGap, Math.max(size1.height, size2.height));
    }

    @Override
    public void layoutContainer(Container parent) {
        int height = minimumLayoutSize(parent).height;
        Dimension size1 = parent.getComponent(0).getPreferredSize();
        Dimension size2 = parent.getComponent(1).getPreferredSize();
        parent.getComponent(0).setBounds(0, (height - size1.height) / 2, size1.width, size1.height);
        parent.getComponent(1).setBounds(parent.getSize().width - size2.width, (height - size2.height) / 2, size2.width, size2.height);
    }
}
package rolit.view.layout;

import java.awt.*;

public class GridLayoutManager implements LayoutManager {
    private static final int DEFAULT_GAP = 8;

    private int width;
    private int height;
    private int gap;

    public GridLayoutManager(int width, int height, int gap) {
        this.width = width;
        this.height = height;
        this.gap = gap;
    }

    public GridLayoutManager(int width, int height) {
        this(width, height, DEFAULT_GAP);
    }

    @Override
    public void addLayoutComponent(String name, Component comp) {
    }

    @Override
    public void removeLayoutComponent(Component comp) {
    }

    @Override
    public Dimension preferredLayoutSize(Container parent) {
        int[] x = new int[width + 1];
        int[] y = new int[height + 1];

        for(int i = 0; i < height; i++) {
            int maxHeight = 0;

            for(int j = 0; j < width; j++) {
                Dimension size = parent.getComponent(j + i * width).getPreferredSize();
                if(size.height > maxHeight) {
                    maxHeight = size.height;
                }
            }

            y[i + 1] = y[i] + maxHeight;
        }

        for(int i = 0; i < width; i++) {
            int maxWidth = 0;

            for(int j = 0; j < height; j++) {
                Dimension size = parent.getComponent(i + j * width).getPreferredSize();
                if(size.width > maxWidth) {
                    maxWidth = size.width;
                }
            }

            x[i + 1] = x[i] + maxWidth;
        }

        return new Dimension(x[width] + (width - 1) * gap, y[height] + (height - 1) * gap);
    }

    @Override
    public Dimension minimumLayoutSize(Container parent) {
        return preferredLayoutSize(parent);
    }

    @Override
    public void layoutContainer(Container parent) {
        int[] x = new int[width + 1];
        int[] y = new int[height + 1];

        for(int i = 0; i < height; i++) {
            int maxHeight = 0;

            for(int j = 0; j < width; j++) {
                Dimension size = parent.getComponent(j + i * width).getPreferredSize();
                if(size.height > maxHeight) {
                    maxHeight = size.height;
                }
            }

            y[i + 1] = y[i] + maxHeight + gap;
        }

        for(int i = 0; i < width; i++) {
            int maxWidth = 0;

            for(int j = 0; j < height; j++) {
                Dimension size = parent.getComponent(i + j * width).getPreferredSize();
                if(size.width > maxWidth) {
                    maxWidth = size.width;
                }
            }

            x[i + 1] = x[i] + maxWidth + gap;
        }

        for(int i = 0; i < width; i++) {
            for(int j = 0; j < height; j++) {
                parent.getComponent(i + j * width).setBounds(x[i], y[j], x[i + 1] - x[i] - gap, y[j + 1] - y[j] - gap);
            }
        }
    }
}
package rolit.view.client;

import rolit.view.layout.VSplitLayoutManager;

import javax.swing.*;

public class ChatPanel extends JPanel {
    private JTextArea textArea;
    private JTextField textField;

    public ChatPanel() {
        setLayout(new VSplitLayoutManager(VSplitLayoutManager.VSplitType.Bottom));

        textArea = new JTextArea();
        textField = new JTextField();

        add(textArea);
        add(textField);
    }
}
package rolit.view.client;

import rolit.view.layout.*;

import javax.swing.*;
import java.awt.*;

public class GameListPanel extends JPanel {
    public GameListPanel() {
        setLayout(new VSplitLayoutManager(VSplitLayoutManager.VSplitType.Top));

        JPanel mainPanel = new JPanel();
        mainPanel.setLayout(new HSplitLayoutManager(200, HSplitLayoutManager.HSplitType.Right));

        JPanel gamesPanel = new JPanel();
        gamesPanel.setLayout(new VSplitLayoutManager(VSplitLayoutManager.VSplitType.Bottom));

        JPanel listPanel = new JPanel();
        listPanel.setLayout(new GridLayoutManager(3, 3));

        listPanel.add(new JLabel("Spelmaker"));
        listPanel.add(new JLabel("Aantal spelers"));
        listPanel.add(Box.createGlue());
        listPanel.add(new JLabel("Pieter"));
        listPanel.add(new JLabel("2"));
        listPanel.add(new JButton("Meedoen"));
        listPanel.add(new JLabel("Martijn"));
        listPanel.add(new JLabel("4"));
        JButton joinGameButton = new JButton("Meedoen");
        joinGameButton.setEnabled(false);
        listPanel.add(joinGameButton);


        JPanel buttonsArrayPanel = new JPanel();
        buttonsArrayPanel.setLayout(new HBoxLayoutManager());

        JButton createGameButton = new JButton("Maak spel");
        JButton challengeButton = new JButton("Daag een speler uit");

        buttonsArrayPanel.add(createGameButton);
        buttonsArrayPanel.add(challengeButton);

        gamesPanel.add(listPanel);
        gamesPanel.add(buttonsArrayPanel);

        mainPanel.add(gamesPanel);
        mainPanel.add(new ChatPanel());

        add(new ServerPanel());
        add(mainPanel);
    }

    public static void main(String[] args) throws ClassNotFoundException, UnsupportedLookAndFeelException, InstantiationException, IllegalAccessException {
        UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
        JFrame frame = new JFrame();
        frame.getContentPane().add(new GameListPanel());
        frame.setSize(640, 480);
        frame.setMinimumSize(new Dimension(640, 480));
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.setVisible(true);
    }
}
package rolit.view.client;

import rolit.view.layout.CenterLayoutManager;
import rolit.view.layout.LeftRightLayoutManager;
import rolit.view.layout.VBoxLayoutManager;

import javax.swing.*;
import java.awt.*;

/**
 * @author Pieter Bos
 *
 * Panel to connect to a server.
 */
public class ConnectPanel extends JPanel {
    private static final int DEFAULT_TEXT_FIELD_WIDTH = 200;
    private static final int DEFAULT_TEXT_FIELD_HEIGHT = 24;

    private JTextField hostname;
    private JTextField userName;
    private JButton loginButton;

    public ConnectPanel() {
        setLayout(new CenterLayoutManager());

        JPanel panel = new JPanel();
        panel.setLayout(new VBoxLayoutManager());

        JLabel logInLabel = new JLabel("Verbinden met server");
        panel.add(logInLabel);

        JPanel panel1 = new JPanel();
        panel1.setLayout(new LeftRightLayoutManager());

        JLabel hostnameLabel = new JLabel("Hostname");
        hostname = new JTextField();
        hostname.setPreferredSize(new Dimension(DEFAULT_TEXT_FIELD_WIDTH, DEFAULT_TEXT_FIELD_HEIGHT));
        panel1.add(hostnameLabel);
        panel1.add(hostname);
        panel.add(panel1);

        JPanel panel2 = new JPanel();
        panel2.setLayout(new LeftRightLayoutManager());

        JLabel userNameLabel = new JLabel("Gebruikersnaam");
        userName = new JTextField();
        userName.setPreferredSize(new Dimension(DEFAULT_TEXT_FIELD_WIDTH, DEFAULT_TEXT_FIELD_HEIGHT));
        panel2.add(userNameLabel);
        panel2.add(userName);
        panel.add(panel2);

        JPanel panel3 = new JPanel();
        panel3.setLayout(new LeftRightLayoutManager());


        loginButton = new JButton("Inloggen");
        panel3.add(Box.createGlue());
        panel3.add(loginButton);
        panel.add(panel3);

        add(panel);
    }

    public static void main(String[] args) throws ClassNotFoundException, UnsupportedLookAndFeelException, InstantiationException, IllegalAccessException {
        UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
        JFrame window = new JFrame();
        window.getContentPane().add(new ConnectPanel());
        window.setSize(640, 480);
        window.setMinimumSize(new Dimension(640, 480));
        window.setVisible(true);
    }
}
package rolit.view.client;

import rolit.view.layout.HBoxLayoutManager;
import rolit.view.layout.LeftRightLayoutManager;

import javax.swing.*;

public class ServerPanel extends JPanel {
    JLabel serverConnectionLabel;
    JLabel userNameLabel;
    JButton logoutButton;

    public ServerPanel() {
        setLayout(new LeftRightLayoutManager());

        serverConnectionLabel = new JLabel("Verbonden met pieterbos.me:667");
        add(serverConnectionLabel);

        JPanel rightPanel = new JPanel();
        rightPanel.setLayout(new HBoxLayoutManager());

        userNameLabel = new JLabel("Ingelogd als Pieter");
        logoutButton = new JButton("Uitloggen");

        rightPanel.add(userNameLabel);
        rightPanel.add(logoutButton);

        add(rightPanel);
    }
}
package rolit.view.client;

import javax.swing.*;

public class MainView extends JFrame {
    
}
package rolit.view.client;

import rolit.view.layout.CenterLayoutManager;
import rolit.view.layout.GridLayoutManager;
import rolit.view.layout.HBoxLayoutManager;
import rolit.view.layout.VBoxLayoutManager;

import javax.swing.*;
import java.awt.*;

public class ChallengePanel extends JPanel {
    public ChallengePanel() {
        setLayout(new CenterLayoutManager());
        setSize(new Dimension(300, 1));

        JPanel mainPanel = new JPanel();
        mainPanel.setLayout(new VBoxLayoutManager());

        JLabel challengeLabel = new JLabel("Daag mensen uit:");

        JPanel challengePanel = new JPanel();
        challengePanel.setLayout(new HBoxLayoutManager());

        JComboBox players = new JComboBox<String>();
        players.addItem("Pieter");
        players.addItem("Martijn");

        JButton challengeButton = new JButton("Uitdagen");

        challengePanel.add(players);
        challengePanel.add(challengeButton);

        JLabel challengedPeople = new JLabel("Uitgedaagde mensen:");

        JPanel challengedPanel = new JPanel();
        challengedPanel.setLayout(new GridLayoutManager(2, 2));
        challengedPanel.add(new JLabel("Laurens"));
        challengedPanel.add(new JButton("Verwijder"));
        challengedPanel.add(new JLabel("Sophie"));
        challengedPanel.add(new JButton("Verwijder"));

        mainPanel.add(challengeLabel);
        mainPanel.add(challengePanel);
        mainPanel.add(Box.createGlue());
        mainPanel.add(challengedPeople);
        mainPanel.add(challengedPanel);

        add(mainPanel);
    }

    public static void main(String[] args) throws ClassNotFoundException, UnsupportedLookAndFeelException, InstantiationException, IllegalAccessException {
        UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
        JFrame frame = new JFrame();
        frame.getContentPane().add(new ChallengePanel());
        frame.setSize(640, 480);
        frame.setMinimumSize(new Dimension(640, 480));
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.setVisible(true);
    }
}
package rolit.view.client;

import rolit.view.layout.VBoxLayoutManager;
import rolit.view.layout.VSplitLayoutManager;

import javax.swing.*;
import java.awt.*;

public class WaitPanel extends JPanel {
    public WaitPanel() {
        setLayout(new VSplitLayoutManager(VSplitLayoutManager.VSplitType.Top));

        JPanel mainPanel = new JPanel();
        mainPanel.setLayout(new VBoxLayoutManager());

        JLabel status = new JLabel("Het spel van Pieter is nog niet begonnen. Er zitten nu 3 mensen in het spel.");
        JButton actionButton = new JButton("Beginnen");
        actionButton.setEnabled(false);

        mainPanel.add(status);
        mainPanel.add(actionButton);

        add(new ServerPanel());
        add(mainPanel);
    }

    public static void main(String[] args) throws ClassNotFoundException, UnsupportedLookAndFeelException, InstantiationException, IllegalAccessException {
        UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
        JFrame frame = new JFrame();
        frame.getContentPane().add(new WaitPanel());
        frame.setSize(640, 480);
        frame.setMinimumSize(new Dimension(640, 480));
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.setVisible(true);
    }
}
package rolit.view.client;

import rolit.view.layout.GridLayoutManager;
import rolit.view.layout.HSplitLayoutManager;
import rolit.view.layout.VSplitLayoutManager;

import javax.swing.*;
import java.awt.*;

public class GamePanel extends JPanel {
    public GamePanel() {
        setLayout(new VSplitLayoutManager(VSplitLayoutManager.VSplitType.Top));

        JPanel mainPanel = new JPanel();
        mainPanel.setLayout(new HSplitLayoutManager(200, HSplitLayoutManager.HSplitType.Right));

        JPanel gamePanel = new JPanel();
        gamePanel.setLayout(new GridLayout(8, 8));

        JButton[][] buttons = new JButton[8][8];

        for(int y = 0; y < 8; y++) {
            for(int x = 0; x < 8; x++) {
                buttons[x][y] = new JButton("(" + x + "; " + y + ")");
                gamePanel.add(buttons[x][y]);
            }
        }

        JPanel sideBarPanel = new JPanel();
        sideBarPanel.setLayout(new VSplitLayoutManager(100, VSplitLayoutManager.VSplitType.Top));

        JPanel scorePanel = new JPanel();
        scorePanel.setLayout(new GridLayoutManager(2, 4));

        scorePanel.add(new JLabel("Pieter"));
        scorePanel.add(new JLabel("0"));
        scorePanel.add(new JLabel("Martijn"));
        scorePanel.add(new JLabel("0"));
        scorePanel.add(new JLabel("Laurens"));
        scorePanel.add(new JLabel("0"));
        scorePanel.add(new JLabel("Sophie"));
        scorePanel.add(new JLabel("0"));

        sideBarPanel.add(scorePanel);
        sideBarPanel.add(new ChatPanel());

        mainPanel.add(gamePanel);
        mainPanel.add(sideBarPanel);

        add(new ServerPanel());
        add(mainPanel);
    }

    public static void main(String[] args) throws ClassNotFoundException, UnsupportedLookAndFeelException, InstantiationException, IllegalAccessException {
        UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
        JFrame frame = new JFrame();
        frame.getContentPane().add(new GamePanel());
        frame.setSize(640, 480);
        frame.setMinimumSize(new Dimension(640, 480));
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.setVisible(true);
    }
}
package rolit.model.networking.common;

import java.io.*;
import java.security.*;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.PKCS8EncodedKeySpec;
import java.util.Arrays;

/**
 * @author Pieter Bos
 * @author Martijn de Bijl
 *
 *
 */
public class CommonProtocol {
    /**
     * Constante om aan te geven dat de client of server alleen de basisdingen kan doen.
     */
    public static final int SUPPORTS_BAREBONE = 0;

    /**
     * Constante om aan te geven dat de client of server ook kan chatten.
     */
    public static final int SUPPORTS_CHAT = 1;

    /**
     * Constante om aan te geven dat de client of server ook kan uitdagen / uitgedaagd worden.
     */
    public static final int SUPPORTS_CHALLENGE = 2;

    /**
     * SUPPORTS_CHAT | SUPPORTS_CHALLENGE
     */
    public static final int SUPPORTS_CHAT_CHALLENGE = 3;

    /**
     * String-waarde voor true in het protocol
     */
    public static final String T_BOOLEAN_TRUE = "true";

    /**
     * String-waarde voor false in het protocol
     */
    public static final String T_BOOLEAN_FALSE = "false";

    /**
     * Versie in de handshake voor een standaardimplementatie
     */
    public static final String VERSION_NONE = "Standaard";

    /**
     * Einde van regels
     */
    public static final String LINE_ENDING = "\r\n";

    /**
     * Delimiter van commando's
     */
    public static final String COMMAND_DELIMITER = " ";

    /**
     * Alle characters van base64 in volgorde.
     */
    private static final String BASE64_CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

    private static final char BASE64_PADDING = '=';

    /**
     * Methode om van een {@code OutputStream} een correcte {@code PrintStream} te maken.
     * @param output De {@code OutputStream}
     * @return de {@code PrintStream}
     */
    public PrintStream getPrintStream(OutputStream output) {
        try {
            return new PrintStream(output, true, "UTF-8");
        } catch (UnsupportedEncodingException e) {
            return null;
        }
    }

    /**
     * Methode om van een {@code InputStream} een correcte {@code BufferedReader} te maken.
     * @param input De {@code InputStream}
     * @return De {@code BufferedReader}
     */
    public BufferedReader getBufferedReader(InputStream input) {
        try {
            return new BufferedReader(new InputStreamReader(input, "UTF-8"));
        } catch (UnsupportedEncodingException e) {
            return null;
        }
    }

    /**
     * Methode om een commando naar een {@code PrintStream} te schrijven.
     * @param commandParts De gedeeltes van het commando.
     * @param output De {@code PrintStream}
     */
    public void writeCommandTo(String[] commandParts, PrintStream output) {
        boolean first = true;
        String command = "";

        for(String argument : commandParts) {
            if(!first) {
                command += " ";
            }

            first = false;

            command += argument;
        }

        output.print(command);
        output.print("\r\n");
    }

    /**
     * Methode om een commando van een {@code BufferedReader} te lezen.
     * @param input De {@code BufferedReader}
     * @return De array van {@code String}s
     * @throws IOException
     */
    public String[] readCommandFrom(BufferedReader input) throws IOException {
        String line = input.readLine();

        return line.split(" ");
    }

    /**
     * Converteert bytes naar een Base64-String. Er is namelijk geen standaardmethode in Java om dit te doen.
     * @param data De bytes
     * @return De String
     */
    public String base64Encode(byte[] data) {
        String result = "";

        for(int i = 0; i < data.length / 3; i++) {
            byte byte1 = data[i * 3], byte2 = data[i * 3 + 1], byte3 = data[i * 3 + 2];

            result += BASE64_CHARS.charAt(byte1 / 4);
            result += BASE64_CHARS.charAt((byte1 % 4) * 16 + byte2 / 16);
            result += BASE64_CHARS.charAt((byte2 % 16) * 4 + byte3 / 64);
            result += BASE64_CHARS.charAt(byte3 % 64);
        }

        if(data.length % 3 == 1) {
            byte byte1 = data[data.length - 1];

            result += BASE64_CHARS.charAt(byte1 / 4);
            result += BASE64_CHARS.charAt((byte1 % 4) * 16);
            result += BASE64_PADDING;
            result += BASE64_PADDING;
        } else if(data.length % 3 == 2) {
            byte byte1 = data[data.length - 2], byte2 = data[data.length - 1];

            result += BASE64_CHARS.charAt(byte1 / 4);
            result += BASE64_CHARS.charAt((byte1 % 4) * 16 + byte2 / 16);
            result += BASE64_CHARS.charAt((byte2 % 16) * 4);
            result += BASE64_PADDING;
        }

        return result;
    }

    /**
     * Converteert een Bas64-String naar bytes.
     * @param data De String
     * @return De bytes
     */
    public byte[] base64Decode(String data) {
        byte[] result = new byte[data.length() / 4 * 3];

        for(int i = 0; i < data.length() / 4; i++) {
            char char1 = data.charAt(i * 4), char2 = data.charAt(i * 4 + 1),
                    char3 = data.charAt(i * 4 + 2), char4 = data.charAt(i * 4 + 3);

            result[i * 3] = (byte) (BASE64_CHARS.indexOf(char1) * 4 + BASE64_CHARS.indexOf(char2) / 16);
            result[i * 3 + 1] = (byte) ((BASE64_CHARS.indexOf(char2) % 16) * 16 + BASE64_CHARS.indexOf(char3) / 4);
            result[i * 3 + 2] = (byte) (((BASE64_CHARS.indexOf(char3) + 4) % 4) * 64 + BASE64_CHARS.indexOf(char4));
        }

        if(data.charAt(data.length() - 2) == '=') {
            return Arrays.copyOfRange(result, 0, result.length - 2);
        } else if(data.charAt(data.length() - 1) == '=') {
            return Arrays.copyOfRange(result, 0, result.length - 1);
        } else {
            return result;
        }
    }

    /**
     * Converteert een String van de ss-security-server naar een {@code PrivateKey}
     * @param data De data van de ss-security-server
     * @return De {@code PrivateKey}
     * @throws InvalidKeySpecException Als de data van de ss-security-server niet klopt.
     */
    public PrivateKey stringToPrivateKey(String data) throws InvalidKeySpecException {
        try {
            PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(data.getBytes());
            KeyFactory keyFactory = KeyFactory.getInstance("RSA");
            return keyFactory.generatePrivate(keySpec);
        } catch (NoSuchAlgorithmException e) {
            return null;
        }
    }

    /**
     * Signt een bericht met een {@code PrivateKey} en retourneert het resultaat in Base64
     * @param message Het bericht
     * @param key De {@code PrivateKey}
     * @return Het resultaat in Base64
     * @throws InvalidKeyException
     */
    public String sign(String message, PrivateKey key) throws InvalidKeyException {
        try {
            Signature signature = Signature.getInstance("SHA1withRSA");
            signature.initSign(key);
            signature.update(message.getBytes());
            return base64Encode(signature.sign());
        } catch (NoSuchAlgorithmException e) {
            return null;
        } catch (SignatureException e) {
            return null;
        }
    }

    /**
     * Converteert een String van de ss-security-server naar een {@code PublicKey}
     * @param data De data van de ss-security-server
     * @return De {@code PublicKey}
     * @throws InvalidKeySpecException
     */
    public PublicKey stringToPublicKey(String data) throws InvalidKeySpecException {
        try {
            PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(data.getBytes());
            KeyFactory keyFactory = KeyFactory.getInstance("RSA");
            return keyFactory.generatePublic(keySpec);
        } catch (NoSuchAlgorithmException e) {
            return null;
        }
    }

    /**
     * Verifieert een gesignd bericht voor een {@code PublicKey}.
     * @param message Het bericht
     * @param signedMessage Het gesignde bericht
     * @param key De {@code PublicKey}
     * @return Of het signen goed is gegaan
     * @throws InvalidKeyException
     */
    public boolean verify(String message, String signedMessage, PublicKey key) throws InvalidKeyException {
        try {
            Signature signature = Signature.getInstance("SHA1withRSA");
            signature.initVerify(key);
            signature.update(message.getBytes());
            return signature.verify(base64Decode(signedMessage));
        } catch (NoSuchAlgorithmException e) {
            return false;
        } catch (SignatureException e) {
            return false;
        }
    }
}
package rolit.model.networking.common;

import rolit.model.networking.client.*;
import rolit.model.networking.client.ChallengePacket;
import rolit.model.networking.client.HandshakePacket;
import rolit.model.networking.client.HighscorePacket;
import rolit.model.networking.client.MessagePacket;
import rolit.model.networking.client.MovePacket;
import rolit.model.networking.server.*;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintStream;
import java.util.Arrays;
import java.util.LinkedHashMap;

public abstract class Packet {
    private static final LinkedHashMap<String, Class<? extends Packet>> CLIENT_PACKETS = new LinkedHashMap<String, Class<? extends Packet>>();
    private static final LinkedHashMap<String, Class<? extends Packet>> SERVER_PACKETS = new LinkedHashMap<String, Class<? extends Packet>>();

    static {
        CLIENT_PACKETS.put(ClientProtocol.HANDSHAKE, HandshakePacket.class);
        CLIENT_PACKETS.put(ClientProtocol.AUTH, AuthPacket.class);
        CLIENT_PACKETS.put(ClientProtocol.CREATE_GAME, CreateGamePacket.class);
        CLIENT_PACKETS.put(ClientProtocol.JOIN_GAME, JoinGamePacket.class);
        CLIENT_PACKETS.put(ClientProtocol.START_GAME, StartGamePacket.class);
        CLIENT_PACKETS.put(ClientProtocol.MOVE, MovePacket.class);
        CLIENT_PACKETS.put(ClientProtocol.MESSAGE, rolit.model.networking.client.MessagePacket.class);
        CLIENT_PACKETS.put(ClientProtocol.CHALLENGE, rolit.model.networking.client.ChallengePacket.class);
        CLIENT_PACKETS.put(ClientProtocol.CHALLENGE_RESPONSE, rolit.model.networking.client.ChallengeResponsePacket.class);
        CLIENT_PACKETS.put(ClientProtocol.HIGHSCORE, rolit.model.networking.client.HighscorePacket.class);

        SERVER_PACKETS.put(ServerProtocol.HANDSHAKE, HandshakePacket.class);
        SERVER_PACKETS.put(ServerProtocol.ERROR, ErrorPacket.class);
        SERVER_PACKETS.put(ServerProtocol.GAME, GamePacket.class);
        SERVER_PACKETS.put(ServerProtocol.START, StartGamePacket.class);
        SERVER_PACKETS.put(ServerProtocol.MOVE, MovePacket.class);
        SERVER_PACKETS.put(ServerProtocol.MOVE_DONE, MoveDonePacket.class);
        SERVER_PACKETS.put(ServerProtocol.GAME_OVER, GameOverPacket.class);
        SERVER_PACKETS.put(ServerProtocol.MESSAGE, rolit.model.networking.server.MessagePacket.class);
        SERVER_PACKETS.put(ServerProtocol.CHALLENGE, rolit.model.networking.server.ChallengePacket.class);
        SERVER_PACKETS.put(ServerProtocol.CHALLENGE_RESPONSE, rolit.model.networking.server.ChallengeResponsePacket.class);
        SERVER_PACKETS.put(ServerProtocol.CAN_BE_CHALLENGED, CanBeChallengedPacket.class);
        SERVER_PACKETS.put(ServerProtocol.HIGHSCORE, rolit.model.networking.server.HighscorePacket.class);
        SERVER_PACKETS.put(ServerProtocol.ONLINE, OnlinePacket.class);
    }

    protected abstract void readFromArgs(PacketArgs args);

    protected abstract PacketArgs.ArgumentType[] getArgumentTypes();

    protected abstract Object[] getData();

    private static Packet readFrom(BufferedReader input, LinkedHashMap<String, Class<? extends Packet>> packets) throws IOException, ProtocolException {
        String[] parts = input.readLine().split(CommonProtocol.COMMAND_DELIMITER);
        String command = parts[0];
        parts = Arrays.copyOfRange(parts, 1, parts.length);

        Packet result = null;

        try {
            Class<? extends Packet> packetClass = packets.get(command);

            if(packetClass == null) {
                throw new ProtocolException("Can't parse unregistered command " + command, ServerProtocol.ERROR_GENERIC);
            } else {
                result = packetClass.newInstance();
            }
        } catch (InstantiationException e) {

        } catch (IllegalAccessException e) {

        }

        PacketArgs.ArgumentType[] args = result.getArgumentTypes();

        result.readFromArgs(PacketArgs.fromParts(parts, args));

        return result;
    }

    public static Packet readClientPacketFrom(BufferedReader input) throws IOException, ProtocolException {
        return readFrom(input, CLIENT_PACKETS);
    }

    public static Packet readServerPacketFrom(BufferedReader input) throws IOException, ProtocolException {
        return readFrom(input, SERVER_PACKETS);
    }

    public void writeTo(PrintStream output) {
        output.print(new PacketArgs(getData()).toString());
        output.print(CommonProtocol.LINE_ENDING);
    }
}
package rolit.model.networking.common;

public class ProtocolException extends Exception {
    private final int code;

    public ProtocolException(String message, int code) {
        super(message);
        this.code = code;
    }

    public int getCode() {
        return code;
    }
}
package rolit.model.networking.common;

import rolit.model.networking.client.ClientProtocol;
import rolit.model.networking.server.ServerProtocol;
import rolit.util.Strings;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintStream;
import java.util.Arrays;
import java.util.HashMap;
import java.util.LinkedHashMap;

public class Command {
    private final static HashMap<String, ArgumentType[]> serverArgumentTypes = new LinkedHashMap<String, ArgumentType[]>();
    private final static HashMap<String, ArgumentType[]> clientArgumentTypes = new LinkedHashMap<String, ArgumentType[]>();

    static {
        serverArgumentTypes.put(ServerProtocol.HANDSHAKE, new ArgumentType[] { ArgumentType.Integer, ArgumentType.String });
        serverArgumentTypes.put(ServerProtocol.ERROR, new ArgumentType[] { ArgumentType.Integer });
        serverArgumentTypes.put(ServerProtocol.GAME, new ArgumentType[] { ArgumentType.String, ArgumentType.Boolean, ArgumentType.Integer });
        serverArgumentTypes.put(ServerProtocol.START, new ArgumentType[] { ArgumentType.MultiString });
        serverArgumentTypes.put(ServerProtocol.MOVE, new ArgumentType[] {  });
        serverArgumentTypes.put(ServerProtocol.MOVE_DONE, new ArgumentType[] { ArgumentType.String, ArgumentType.Integer, ArgumentType.Integer });
        serverArgumentTypes.put(ServerProtocol.GAME_OVER, new ArgumentType[] { ArgumentType.Integer, ArgumentType.MultiString });
        serverArgumentTypes.put(ServerProtocol.MESSAGE, new ArgumentType[] { ArgumentType.String, ArgumentType.String });
        serverArgumentTypes.put(ServerProtocol.CHALLENGE, new ArgumentType[] { ArgumentType.MultiString } );
        serverArgumentTypes.put(ServerProtocol.CHALLENGE_RESPONSE, new ArgumentType[] { ArgumentType.String, ArgumentType.Boolean });
        serverArgumentTypes.put(ServerProtocol.CAN_BE_CHALLENGED, new ArgumentType[] { ArgumentType.String, ArgumentType.Boolean });
        serverArgumentTypes.put(ServerProtocol.HIGHSCORE, new ArgumentType[] { ArgumentType.MultiString });
        serverArgumentTypes.put(ServerProtocol.ONLINE, new ArgumentType[] { ArgumentType.String, ArgumentType.Boolean });

        clientArgumentTypes.put(ClientProtocol.HANDSHAKE, new ArgumentType[] { ArgumentType.String, ArgumentType.Integer, ArgumentType.String });
        clientArgumentTypes.put(ClientProtocol.CREATE_GAME, new ArgumentType[] {  });
        clientArgumentTypes.put(ClientProtocol.JOIN_GAME, new ArgumentType[] { ArgumentType.String });
        clientArgumentTypes.put(ClientProtocol.START_GAME, new ArgumentType[] {  });
        clientArgumentTypes.put(ClientProtocol.MOVE, new ArgumentType[] { ArgumentType.Integer, ArgumentType.Integer });
        clientArgumentTypes.put(ClientProtocol.MESSAGE, new ArgumentType[] { ArgumentType.String });
        clientArgumentTypes.put(ClientProtocol.CHALLENGE, new ArgumentType[] { ArgumentType.MultiString });
        clientArgumentTypes.put(ClientProtocol.CHALLENGE_RESPONSE, new ArgumentType[] { ArgumentType.Boolean });
        clientArgumentTypes.put(ClientProtocol.HIGHSCORE, new ArgumentType[] { ArgumentType.String, ArgumentType.String });
    }

    private final Object[] arguments;
    private final String command;



    public Command(String command, Object... arguments) {
        this.command = command;
        this.arguments = arguments;
    }

    public String getCommand() {
        return command;
    }

    public Object getArgument(int i) {
        return arguments[i];
    }

    public int getArgumentCount() {
        return arguments.length;
    }

    public void writeTo(PrintStream output) throws IOException {
        output.print(this.command);

        for(Object argument : arguments) {
            output.print(CommonProtocol.COMMAND_DELIMITER);

            if(argument instanceof String[]) {
                output.print(Strings.join(CommonProtocol.COMMAND_DELIMITER, (String[]) argument));
            } else {
                output.print(argument);
            }
        }

        output.print(CommonProtocol.LINE_ENDING);
        output.flush();

        if(output.checkError()) {
            throw new IOException("Write failed");
        }
    }

    private static Object parse(String data, ArgumentType arg) throws ProtocolException {
        switch(arg) {
            case Integer:
                return Integer.parseInt(data);
            case Boolean:
                if(!data.equals(CommonProtocol.T_BOOLEAN_TRUE) && !data.equals(CommonProtocol.T_BOOLEAN_FALSE)) {
                    throw new ProtocolException("Boolean must be true or false.", ServerProtocol.ERROR_GENERIC);
                }

                return data.equals(CommonProtocol.T_BOOLEAN_TRUE);
            case String:
                return data;
            case MultiString:
                throw new ProtocolException("Cannot parse a MultiString as a singular argument.", ServerProtocol.ERROR_GENERIC);
        }

        // Impossible
        return null;
    }

    public static Command readFromClient(BufferedReader input) throws IOException, ProtocolException {
        return readFrom(input, clientArgumentTypes);
    }

    public static Command readFromServer(BufferedReader input) throws IOException, ProtocolException {
        return readFrom(input, serverArgumentTypes);
    }

    private static Command readFrom(BufferedReader input, HashMap<String, ArgumentType[]> argumentTypes) throws IOException, ProtocolException {
        String[] parts = input.readLine().split(CommonProtocol.COMMAND_DELIMITER);
        String command = parts[0];
        parts = Arrays.copyOfRange(parts, 1, parts.length);

        ArgumentType[] args = argumentTypes.get(command);

        if(args == null) {
            throw new ProtocolException("Can't parse unregistered command " + command, ServerProtocol.ERROR_GENERIC);
        }

        boolean multiString = false;
        int multiStringLocation = -1;

        for(int i = 0; i < args.length; i++) {
            if(args[i] == ArgumentType.MultiString) {
                multiString = true;
                multiStringLocation = i;
                break;
            }
        }

        Object[] result = new Object[args.length];

        if(multiString) {
            for(int i = 0; i < multiStringLocation; i++) {
                result[i] = parse(parts[i], args[i]);
            }

            int left = args.length - multiStringLocation - 1;

            for(int i = parts.length - left, resultI = multiStringLocation + 1; i < parts.length; i++, resultI++) {
                result[resultI] = parse(parts[i], args[resultI]);
            }

            result[multiStringLocation] = Arrays.copyOfRange(parts, multiStringLocation, multiStringLocation + parts.length - args.length + 1);
        } else {
            if(parts.length > args.length) {
                throw new ProtocolException("Length of parts exceeds argument count.", ServerProtocol.ERROR_GENERIC);
            }

            for(int i = 0; i < parts.length; i++) {
                result[i] = parse(parts[i], args[i]);
            }
        }

        return new Command(command, result);
    }
}
package rolit.model.networking.common;

import rolit.model.networking.server.ServerProtocol;
import rolit.util.Strings;

import java.util.Arrays;

public class PacketArgs {
    public enum ArgumentType {
        Integer,
        Boolean,
        String,
        MultiString
    }

    private Object[] data;

    public PacketArgs(Object[] data) {
        this.data = data;
    }

    private static Object parse(String data, ArgumentType arg) throws ProtocolException {
        switch(arg) {
            case Integer:
                return Integer.parseInt(data);
            case Boolean:
                if(!data.equals(CommonProtocol.T_BOOLEAN_TRUE) && !data.equals(CommonProtocol.T_BOOLEAN_FALSE)) {
                    throw new ProtocolException("Boolean must be true or false.", ServerProtocol.ERROR_GENERIC);
                }

                return data.equals(CommonProtocol.T_BOOLEAN_TRUE);
            case String:
                return data;
            case MultiString:
                throw new ProtocolException("Cannot parse a MultiString as a singular argument.", ServerProtocol.ERROR_GENERIC);
        }

        // Impossible
        return null;
    }

    public int getInt(int i) {
        return (Integer) data[i];
    }

    public boolean getBool(int i) {
        return (Boolean) data[i];
    }

    public String getString(int i) {
        return (String) data[i];
    }

    public String[] getMultiString(int i) {
        return (String[]) data[i];
    }

    public String getSpacedString(int i) {
        return Strings.join(CommonProtocol.COMMAND_DELIMITER, getMultiString(i));
    }

    public static PacketArgs fromParts(String[] parts, ArgumentType[] args) throws ProtocolException {
        boolean multiString = false;
        int multiStringLocation = -1;

        for(int i = 0; i < args.length; i++) {
            if(args[i] == ArgumentType.MultiString) {
                multiString = true;
                multiStringLocation = i;
                break;
            }
        }

        Object[] result = new Object[args.length];

        if(multiString) {
            for(int i = 0; i < multiStringLocation; i++) {
                result[i] = parse(parts[i], args[i]);
            }

            int left = args.length - multiStringLocation - 1;

            for(int i = parts.length - left, resultI = multiStringLocation + 1; i < parts.length; i++, resultI++) {
                result[resultI] = parse(parts[i], args[resultI]);
            }

            result[multiStringLocation] = Arrays.copyOfRange(parts, multiStringLocation, multiStringLocation + parts.length - args.length + 1);
        } else {
            if(parts.length > args.length) {
                throw new ProtocolException("Length of parts exceeds argument count.", ServerProtocol.ERROR_GENERIC);
            }

            for(int i = 0; i < parts.length; i++) {
                result[i] = parse(parts[i], args[i]);
            }
        }

        return new PacketArgs(result);
    }

    @Override
    public String toString() {
        String result = "";
        boolean first = true;

        for(Object unit : data) {
            if(!first) {
                result += CommonProtocol.COMMAND_DELIMITER;
            }

            first = false;

            if(unit instanceof Integer) {
                result += Integer.toString((Integer) unit);
            } else if(unit instanceof Boolean) {
                result += Boolean.toString((Boolean) unit);
            } else if(unit instanceof String) {
                result += (String) unit;
            } else {
                result += Strings.join(CommonProtocol.COMMAND_DELIMITER, (String[]) unit);
            }
        }

        return result;
    }

    public static String[] spacedToMulti(String s) {
        return s.split(CommonProtocol.COMMAND_DELIMITER);
    }
}
package rolit.model.networking.extensions;

import rolit.model.networking.client.ClientProtocol;

public abstract class WebSocketClientProtocol extends ClientProtocol {
    public static final String GET = "GET";

    /**
     * Bij wijze van spreke een methode van de client.
     * @param path Moet altijd / zijn
     * @param version Moet altijd HTTP/1.1 zijn;
     */
    public abstract void get(String path, String version);
}
package rolit.model.networking.extensions;

import rolit.model.networking.server.ServerProtocol;

/**
 * @author Pieter Bos
 *
 * Abstract class voor het protocol van een rolit WebSocket server.
 *
 * Dit type server kan een extra commando ontvangen, GET. Deze moet als eerste worden verstuurd in plaats van de
 * handshake, of helemaal niet. Als dit commando wordt verstuurd wordt de connectie omgezet naar een HTTP-verbinding.
 * De server verwacht dan een "Upgrade: websocket" header en verder alle andere headers zoals gespecificeerd in
 * rfc #6455. Daarna reageert de server of met een 501 Not Implemented of een 101 Switching Protocols, afhankelijk van
 * of de request correct is. In het tweede geval wordt de connectie verheven naar een JSON-RPC 2.0 WebSocket server,
 * zoals hier gespecificeerd: http://www.jsonrpc.org/specification.
 * Elk commando is dan een JSON-RPC methode, met als argumenten gewoon de argumenten. Uitzondering is het chat-bericht,
 * die als één argument wordt verzonden. Daarnaast zijn de typen gewoon native JSON typen, namelijk strings, numbers en
 * booleans.
 *
 * Redenen voor dit protocol:
 * - Webstandaard die geïmplementeerd is in alle moderne browsers: IE10+, FF4+, Chrome14+, Safari5+, Opera11+ en deze
 *   browsers voor mobiele platforms.
 * - Heeft libraries voor bijna alle talen
 * - Is tekst-gebaseerd in het begin, zodat het redelijk vloeiend gaat tussen een WebSocket client en een gewone
 *   server.
 */
public abstract class WebSocketServerProtocol extends ServerProtocol {

}
package rolit.model.networking.server;

import rolit.model.networking.common.Packet;
import rolit.model.networking.common.PacketArgs;

public class CanBeChallengedPacket extends Packet {
    private String user;
    private boolean canBeChallenged;

    public CanBeChallengedPacket(String user, boolean canBeChallenged) {
        this.user = user;
        this.canBeChallenged = canBeChallenged;
    }

    public String getUser() {
        return user;
    }

    public boolean isCanBeChallenged() {
        return canBeChallenged;
    }

    @Override
    protected void readFromArgs(PacketArgs args) {
        this.user = args.getString(0);
        this.canBeChallenged = args.getBool(1);
    }

    @Override
    protected PacketArgs.ArgumentType[] getArgumentTypes() {
        return new PacketArgs.ArgumentType[] { PacketArgs.ArgumentType.String, PacketArgs.ArgumentType.Boolean };
    }

    @Override
    protected Object[] getData() {
        return new Object[] { user, canBeChallenged };
    }
}
package rolit.model.networking.server;

import rolit.model.networking.common.Packet;
import rolit.model.networking.common.PacketArgs;

public class ErrorPacket extends Packet {
    private int code;

    public ErrorPacket(int code) {
        this.code = code;
    }

    public int getCode() {
        return code;
    }

    @Override
    protected void readFromArgs(PacketArgs args) {
        this.code = args.getInt(0);
    }

    @Override
    protected PacketArgs.ArgumentType[] getArgumentTypes() {
        return new PacketArgs.ArgumentType[] { PacketArgs.ArgumentType.Integer };
    }

    @Override
    protected Object[] getData() {
        return new Object[] { this.code };
    }
}
package rolit.model.networking.server;

import rolit.model.networking.client.StartGamePacket;

public class WaitForGameClientHandlerState extends ClientHandlerState {
    private final String creator;

    public WaitForGameClientHandlerState(ClientHandler handler, String creator) {
        super(handler);
        this.creator = creator;
    }

    public String getCreator() {
        return creator;
    }

    @Override
    public ClientHandlerState startGame(StartGamePacket packet) {
        return new GameClientHandlerState(getHandler(), getCreator());
    }
}
package rolit.model.networking.server;

import rolit.model.networking.client.ClientProtocol;
import rolit.model.networking.client.HandshakePacket;
import rolit.model.networking.common.CommonProtocol;
import rolit.model.networking.common.ProtocolException;

public class InitialClientHandlerState extends ClientHandlerState {
    public InitialClientHandlerState(ClientHandler handler) {
        super(handler);
    }

    @Override
    public ClientHandlerState handshake(HandshakePacket packet) throws ProtocolException {
        if(packet.getSupports() < CommonProtocol.SUPPORTS_BAREBONE || packet.getSupports() > CommonProtocol.SUPPORTS_CHAT_CHALLENGE) {
            throw new ProtocolException("Invalid supports integer", ServerProtocol.ERROR_GENERIC);
        }

        if(packet.getName().length() < 2 || packet.getName().length() > 32) {
            throw new ProtocolException("Invalid name length or format", ServerProtocol.ERROR_INVALID_LOGIN);
        }

        getHandler().setClientName(packet.getName());
        getHandler().setClientSupports(packet.getSupports());

        if(packet.getName().startsWith("player_")) {
            return new AuthClientHandlerState(getHandler());
        } else {
            return new GameLobbyClientHandlerState(getHandler());
        }
    }
}
package rolit.model.networking.server;

import rolit.model.event.ServerListener;
import rolit.model.game.Game;
import rolit.model.networking.common.CommonProtocol;

import java.io.IOException;
import java.net.InetAddress;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.LinkedList;

public class Server extends ServerSocket implements Runnable {
    private static final int DEFAULT_BACKLOG = 5;
    public static final int GLOBAL_SUPPORTS = CommonProtocol.SUPPORTS_CHAT_CHALLENGE;
    public static final String GLOBAL_VERSION = "PieterMartijn_Alpha1";

    private Thread serverThread;
    private LinkedList<ServerListener> listeners = new LinkedList<ServerListener>();
    private LinkedList<ClientHandler> clients = new LinkedList<ClientHandler>();
    private LinkedList<User> users = new LinkedList<User>();
    private LinkedList<ServerGame> games = new LinkedList<ServerGame>();

    public Server(String bindAddress, int port) throws IOException {
        super(port, DEFAULT_BACKLOG, InetAddress.getByName(bindAddress));
        serverThread = new Thread(this);
    }

    public Thread getServerThread() {
        return serverThread;
    }

    public void addListener(ServerListener listener) {
        listeners.add(listener);
    }

    public void removeListener(ServerListener listener) {
        listeners.remove(listener);
    }

    public void serveForever() {
        serverThread.start();
    }

    public void fireServerError(String reason) {
        for(ServerListener listener : listeners) {
            listener.serverError(reason);
        }
    }

    private void fireNewClient(ClientHandler handler) {
        for(ServerListener listener : listeners) {
            listener.newClient(handler);
        }
    }

    public void fireClientError(String reason) {
        for(ServerListener listener : listeners) {
            listener.clientError(reason);
        }
    }

    public synchronized User authenticateUser(String username) {
        boolean exists = false;
        User theUser = null;

        for(User user : users) {
            if(user.getUsername().equals(username)) {
                exists = true;
                theUser = user;
                break;
            }
        }

        if(!exists) {
            User user = new User(username);
            users.add(user);
            return user;
        } else {
            for(ClientHandler client : clients) {
                if(client.getUser() == theUser) {
                    return null;
                }
            }

            return theUser;
        }
    }

    public synchronized void addGame(ServerGame game) {
        games.add(game);
    }

    public synchronized ServerGame getGame(String creator) {
        for(ServerGame game : games) {
            if(game.getCreator().getUsername().equals(creator)) {
                return game;
            }
        }

        return null;
    }

    public synchronized void broadcastMessage(User user, String message) {
        for(ClientHandler client : clients) {
            try {
                client.message(user.getUsername(), message);
            } catch(IOException e) {
                // Wait for client to be removed by ClientHandler
            }
        }
    }

    public synchronized void gameMessage(User user, String join, ServerGame game) {
//        for(User gameUser : game.getPlayers()) {
//            for(ClientHandler client : clients) {
//                if(client.getUser() == gameUser) {
//                    try {
//                        client.message(user.getUsername(), join);
//                    } catch (IOException e) {
//
//                    }
//                }
//            }
//        }
    }

    public void challenge(User user, String[] others) {
        for(String userName : others) {
            for(ClientHandler client : clients) {
                if(client.getUser().getUsername().equals(userName)) {
                    try {
                        switch(others.length) {
                            case 1:
                                client.challenge(user.getUsername(), others[0]);
                                break;
                            case 2:
                                client.challenge(user.getUsername(), others[0], others[1]);
                                break;
                            case 3:
                                client.challenge(user.getUsername(), others[0], others[1], others[2]);
                        }
                    } catch (IOException e) {

                    }
                }
            }
        }

    }

    @Override
    public void run() {
        try {
            while(true) {
                Socket client = accept();
                ClientHandler handler = new ClientHandler(this, client);
                fireNewClient(handler);
            }
        } catch(IOException e) {
            fireServerError("IOException: " + e.getMessage());
        }
    }
}
package rolit.model.networking.server;

import rolit.model.networking.common.Packet;
import rolit.model.networking.common.PacketArgs;

public class StartPacket extends Packet {
    private String[] players;

    public StartPacket(String[] players) {
        this.players = players;
    }

    public String[] getPlayers() {
        return players;
    }

    @Override
    protected void readFromArgs(PacketArgs args) {
        this.players = args.getMultiString(0);
    }

    @Override
    protected PacketArgs.ArgumentType[] getArgumentTypes() {
        return new PacketArgs.ArgumentType[] { PacketArgs.ArgumentType.MultiString };
    }

    @Override
    protected Object[] getData() {
        return new Object[] { players };
    }
}
package rolit.model.networking.server;

import rolit.model.game.Game;

import java.util.LinkedList;

public class ServerGame extends Game {
    private final LinkedList<User> players = new LinkedList<User>();
    private final User creator;
    private boolean started;

    public ServerGame(User creator) {
        super(1);
        this.creator = creator;
        players.add(creator);
    }

    public User getCreator() {
        return creator;
    }

    public void addPlayer(User player) {
        players.add(player);
    }

    public void removePlayer(User player) {
        players.remove(player);
    }

//    public User[] getPlayers() {
//        User[] result = new User[players.size()];
//        players.toArray(result);
//        return result;
//    }

    public boolean isStarted() {
        return started;
    }

    public void start() {
        started = true;
    }

    public boolean isNext(User user) {
        return true;
    }

    public boolean canDoMove(int x, int y) {
        return true;
    }

    public void doMove(int x, int y) {

    }
}
package rolit.model.networking.server;

public class User {
    private final String username;

    public User(String username) {
        this.username = username;
    }

    public boolean isValidAuthentication() {
        return true;
    }

    public String getUsername() {
        return username;
    }
}
package rolit.model.networking.server;

import rolit.model.networking.common.Packet;
import rolit.model.networking.common.PacketArgs;

public class MessagePacket extends Packet {
    private String user;
    private String message;

    public MessagePacket(String user, String message) {
        this.user = user;
        this.message = message;
    }

    @Override
    protected void readFromArgs(PacketArgs args) {
        this.user = args.getString(0);
        this.message = args.getSpacedString(1);
    }

    @Override
    protected PacketArgs.ArgumentType[] getArgumentTypes() {
        return new PacketArgs.ArgumentType[] { PacketArgs.ArgumentType.String, PacketArgs.ArgumentType.MultiString };
    }

    @Override
    protected Object[] getData() {
        return new Object[] { user, message };
    }
}
package rolit.model.networking.server;

import rolit.model.networking.client.ChallengePacket;
import rolit.model.networking.client.ChallengeResponsePacket;
import rolit.model.networking.client.CreateGamePacket;
import rolit.model.networking.client.HandshakePacket;
import rolit.model.networking.client.JoinGamePacket;
import rolit.model.networking.client.MovePacket;
import rolit.model.networking.client.StartGamePacket;
import rolit.model.networking.common.ProtocolException;

public abstract class ClientHandlerState {
    private ClientHandler handler;

    public ClientHandlerState(ClientHandler handler) {
        this.handler = handler;
    }

    private void error(String commandName) throws ProtocolException {
        throw new ProtocolException("Cannot do " + commandName + " while in state " + this.getClass().getName(), ServerProtocol.ERROR_GENERIC);
    }

    public ClientHandlerState challenge(ChallengePacket packet) throws ProtocolException {
        error("challenge");
        return null;
    }

    public ClientHandlerState challengeResponse(ChallengeResponsePacket packet) throws ProtocolException {
        error("challenge response");
        return null;
    }

    public ClientHandlerState createGame(CreateGamePacket packet) throws ProtocolException {
        error("create game");
        return null;
    }

    public ClientHandlerState handshake(HandshakePacket packet) throws ProtocolException {
        error("hello");
        return null;
    }

    public ClientHandlerState joinGame(JoinGamePacket packet) throws ProtocolException {
        error("join game");
        return null;
    }

    public ClientHandlerState move(MovePacket packet) throws ProtocolException {
        error("move");
        return null;
    }

    public ClientHandlerState startGame(StartGamePacket packet) throws ProtocolException {
        error("start game");
        return null;
    }

    public ClientHandler getHandler() {
        return handler;
    }
}
package rolit.model.networking.server;

import rolit.model.networking.common.Packet;
import rolit.model.networking.common.PacketArgs;

public class ChallengeResponsePacket extends Packet {
    private String user;
    private boolean accept;

    public ChallengeResponsePacket(String user, boolean accept) {
        this.user = user;
        this.accept = accept;
    }

    public String getUser() {
        return user;
    }

    public boolean isAccept() {
        return accept;
    }

    @Override
    protected void readFromArgs(PacketArgs args) {
        this.user = args.getString(0);
        this.accept = args.getBool(1);
    }

    @Override
    protected PacketArgs.ArgumentType[] getArgumentTypes() {
        return new PacketArgs.ArgumentType[] { PacketArgs.ArgumentType.String, PacketArgs.ArgumentType.Boolean };
    }

    @Override
    protected Object[] getData() {
        return new Object[] { user, accept };
    }
}
package rolit.model.networking.server;

import rolit.model.networking.common.Packet;
import rolit.model.networking.common.PacketArgs;

public class GameOverPacket extends Packet {
    private int score;
    private String[] winners;

    public GameOverPacket(int score, String[] winners) {
        this.score = score;
        this.winners = winners;
    }

    public int getScore() {
        return score;
    }

    public String[] getWinners() {
        return winners;
    }

    @Override
    protected void readFromArgs(PacketArgs args) {
        this.score = args.getInt(0);
        this.winners = args.getMultiString(1);
    }

    @Override
    protected PacketArgs.ArgumentType[] getArgumentTypes() {
        return new PacketArgs.ArgumentType[] { PacketArgs.ArgumentType.Integer, PacketArgs.ArgumentType.MultiString };
    }

    @Override
    protected Object[] getData() {
        return new Object[] { score, winners };
    }
}
package rolit.model.networking.server;

import rolit.model.networking.client.ClientProtocol;
import rolit.model.networking.client.CreateGamePacket;
import rolit.model.networking.client.JoinGamePacket;
import rolit.model.networking.client.StartGamePacket;
import rolit.model.networking.common.Command;
import rolit.model.networking.common.Packet;
import rolit.model.networking.common.ProtocolException;
import rolit.model.networking.client.ChallengePacket;
import rolit.model.networking.client.ChallengeResponsePacket;
import rolit.model.networking.client.HandshakePacket;
import rolit.model.networking.client.MovePacket;
import rolit.util.Strings;

import java.io.*;
import java.net.Socket;

public class ClientHandler implements Runnable {
    private final Server server;
    private final Socket client;
    private BufferedReader input;
    private PrintStream output;
    private final Thread thread;

    private ClientHandlerState state;

    private int clientSupports;
    private String clientName;

    public ClientHandler(Server server, Socket client) throws IOException {
        this.server = server;
        this.client = client;
        thread = new Thread(this);
        state = new InitialClientHandlerState(this);
    }

    public void start() {
        thread.start();
    }

    private void handlePacket(Packet packet) throws ProtocolException {
        if(packet instanceof ChallengePacket) {
            state = state.challenge((ChallengePacket) packet);
        } else if(packet instanceof ChallengeResponsePacket) {
            state = state.challengeResponse((ChallengeResponsePacket) packet);
        } else if(packet instanceof CreateGamePacket) {
            state = state.createGame((CreateGamePacket) packet);
        } else if(packet instanceof HandshakePacket) {
            state = state.handshake((HandshakePacket) packet);
        } else if(packet instanceof HighscorePacket) {
            highscore((HighscorePacket) packet);
        } else if(packet instanceof JoinGamePacket) {
            state = state.joinGame((JoinGamePacket) packet);
        } else if(packet instanceof MessagePacket) {
            message((MessagePacket) packet);
        } else if(packet instanceof MovePacket) {
            state = state.move((MovePacket) packet);
        } else if(packet instanceof StartGamePacket) {
            state = state.startGame((StartGamePacket) packet);
        } else {
            throw new ProtocolException("Client caused the server to be in an impossible condition", ServerProtocol.ERROR_GENERIC);
        }
    }

    private void message(MessagePacket packet) {

    }

    private void highscore(HighscorePacket packet) {

    }

    @Override
    public void run() {
        try {
            try {
                this.input = new BufferedReader(new InputStreamReader(client.getInputStream(), "UTF-8"));
                this.output = new PrintStream(client.getOutputStream(), true, "UTF-8");

                while(true) {
                    handlePacket(Packet.readClientPacketFrom(input));
                }
            } catch (ProtocolException e) {
                server.fireClientError("ProtocolException: " + e.getMessage());
                new ErrorPacket(e.getCode()).writeTo(output);
                client.close();
            }
        } catch (IOException e) {
            server.fireClientError("IOException: " + e.getMessage());
        }
    }

    public int getClientSupports() {
        return clientSupports;
    }

    public void setClientSupports(int clientSupports) {
        this.clientSupports = clientSupports;
    }

    public String getClientName() {
        return clientName;
    }

    public void setClientName(String clientName) {
        this.clientName = clientName;
    }

    public void write(Packet packet) {
        packet.writeTo(output);
    }
}
package rolit.model.networking.server;

import rolit.model.networking.common.Packet;
import rolit.model.networking.common.PacketArgs;

public class MovePacket extends Packet {
    public MovePacket() {

    }

    @Override
    protected void readFromArgs(PacketArgs args) {

    }

    @Override
    protected PacketArgs.ArgumentType[] getArgumentTypes() {
        return new PacketArgs.ArgumentType[] {  };
    }

    @Override
    protected Object[] getData() {
        return new Object[] {  };
    }
}
package rolit.model.networking.server;

import rolit.model.networking.common.Packet;
import rolit.model.networking.common.PacketArgs;

public class ChallengePacket extends Packet {
    @Override
    protected void readFromArgs(PacketArgs args) {
        //To change body of implemented methods use File | Settings | File Templates.
    }

    @Override
    protected PacketArgs.ArgumentType[] getArgumentTypes() {
        return new PacketArgs.ArgumentType[0];  //To change body of implemented methods use File | Settings | File Templates.
    }

    @Override
    protected Object[] getData() {
        return new Object[0];  //To change body of implemented methods use File | Settings | File Templates.
    }
}
package rolit.model.networking.server;

import rolit.model.networking.common.Packet;
import rolit.model.networking.common.PacketArgs;

public class GamePacket extends Packet {
    private String game;
    private int status;
    private int players;

    public GamePacket(String game, int status, int players) {
        this.game = game;
        this.status = status;
        this.players = players;
    }

    public String getGame() {
        return game;
    }

    public int getStatus() {
        return status;
    }

    public int getPlayers() {
        return players;
    }

    @Override
    protected void readFromArgs(PacketArgs args) {
        this.game = args.getString(0);
        this.status = args.getInt(1);
        this.players = args.getInt(2);
    }

    @Override
    protected PacketArgs.ArgumentType[] getArgumentTypes() {
        return new PacketArgs.ArgumentType[] { PacketArgs.ArgumentType.String, PacketArgs.ArgumentType.Integer, PacketArgs.ArgumentType.Integer };
    }

    @Override
    protected Object[] getData() {
        return new Object[] { game, status, players };
    }
}
package rolit.model.networking.server;

public class AuthClientHandlerState extends ClientHandlerState {
    public AuthClientHandlerState(ClientHandler handler) {
        super(handler);
        getHandler().write(new HandshakePacket(Server.GLOBAL_SUPPORTS, Server.GLOBAL_VERSION, "hallo"));
    }
}
package rolit.model.networking.server;

import rolit.model.networking.common.Packet;
import rolit.model.networking.common.PacketArgs;

public class OnlinePacket extends Packet {
    private String user;
    private boolean online;

    public OnlinePacket(String user, boolean online) {
        this.user = user;
        this.online = online;
    }

    public String getUser() {
        return user;
    }

    public boolean isOnline() {
        return online;
    }

    @Override
    protected void readFromArgs(PacketArgs args) {
        this.user = args.getString(0);
        this.online = args.getBool(1);
    }

    @Override
    protected PacketArgs.ArgumentType[] getArgumentTypes() {
        return new PacketArgs.ArgumentType[] { PacketArgs.ArgumentType.String, PacketArgs.ArgumentType.Boolean }
    }

    @Override
    protected Object[] getData() {
        return new Object[] { user, online };
    }
}
package rolit.model.networking.server;

import rolit.model.networking.common.CommonProtocol;

import java.io.IOException;

/**
 * @author Pieter Bos
 * @author Martijn de Bijl
 *
 * Abstract class met alle constanten en methodes die gebruikt kunnen worden
 */
public abstract class ServerProtocol extends CommonProtocol {
    /**
     * Constante voor het handshake-commando
     */
    public static final String HANDSHAKE = "hello";

    /**
     * Constante voor het authOk-commando
     */
    public static final String AUTH_OK = "authOk";

    /**
     * Constante voor het error-commando
     */
    public static final String ERROR = "error";

    /**
     * Constante voor het game-commando
     */
    public static final String GAME = "game";

    /**
     * Constante voor het start-commando
     */
    public static final String START = "start";

    /**
     * Constante voor het move-commando
     */
    public static final String MOVE = "move";

    /**
     * Constante voor het move-done-commando
     */
    public static final String MOVE_DONE = "moveDone";

    /**
     * Constante voor het game-over-command
     */
    public static final String GAME_OVER = "gameOver";

    /**
     * Constante voor het message-commando
     */
    public static final String MESSAGE = "message";

    /**
     * Constante voor het challenge-commando
     */
    public static final String CHALLENGE = "challenge";

    /**
     * Constante voor het challenge-response-commando
     */
    public static final String CHALLENGE_RESPONSE = "challengeResponse";

    /**
     * Constante voor het can-be-challenged-commando
     */
    public static final String CAN_BE_CHALLENGED = "canBeChallenged";

    /**
     *
     */
    public static final String ONLINE = "online";

    /**
     * Constante voor highscore
     */
    public static final String HIGHSCORE = "highscore";

    public static final int ERROR_GENERIC = -1;
    public static final int ERROR_INVALID_LOGIN = 1;
    public static final int ERROR_GAME_FULL = 2;
    public static final int ERROR_TOO_LITTLE_PLAYERS = 3;
    public static final int ERROR_INVALID_MOVE = 4;
    public static final int ERROR_NO_SUCH_GAME = 5;
    public static final int ERROR_USER_HAS_NO_GAME = 6;
    public static final int ERROR_HANDSHAKE_MISSING = 7;
    public static final int ERROR_USER_ALREADY_HAS_GAME = 8;

    public static final int HIGHSCORE_UNAVAILABLE = -1;

    /**
     * Status om aan te geven dat de creator voortijdig is weggegaan
     */
    public static final int STATUS_PREMATURE_LEAVE = -1;

    /**
     * Status om aan te geven dat het spel nog niet is gestart.
     */
    public static final int STATUS_NOT_STARTED = 0;

    /**
     * Status om aan te geven dat het spel is gestart.
     */
    public static final int STATUS_STARTED = 1;

    /**
     * Antwoord op de handshake van de client. Moet altijd het eerst verzonden commando zijn, met uitzondering van
     * errors.
     * @requires Dat de handshake van de client is verzonden.
     * @requires Dat de handshake van de client niet een al ingelodge naam kiest.
     * @requires Dat de clientName niet begint met "player_"
     * @param supports Wat de server ondersteunt.
     * @param version Een beschrijving van wat de server kan
     */
    public abstract void handshake(int supports, String version) throws IOException;

    /**
     * Antwoord op de handshake van de client. Moet altijd het eerst verzonden commando zijn, met uitzondering van
     * errors.
     * @requires Dat de requirements van de eerste overload zijn voldaan.
     * @requires Dat de clientName juist wel begint met "player_"
     * @param supports
     * @param version
     * @param nonce
     * @throws IOException
     */
    public abstract void handshake(int supports, String version, String nonce) throws IOException;

    /**
     * Antwoord op het auth-pakket van de client.
     * @requires Dat de handshake is gedaan.
     * @requires Dat de client een juist gesignde nonce heeft gestuurd.
     * @requires Dat de nonce gesigned is met de juiste public-key volgens ss-security.student.utwente.nl
     * @throws IOException
     */
    public abstract void authOk() throws IOException;

    /**
     * Commando om de client te laten weten dat hij iets fout heeft gedaan, waardoor de verbinding moet worden
     * verbroken.
     * @requires Dat de client iets fout heeft gedaan...
     * @requires Dat dit het enige en eerste pakket na de fout is.
     * @param errorCode De error-code, op te zoeken in de errorCode-tabel.
     */
    public abstract void error(int errorCode) throws IOException;

    /**
     * Commando om de client te laten weten dat er óf een nieuw spel is, óf dat er een spel is veranderd in status.
     * Clients krijgen een serie van deze commando's na de handshake om zo een lijst van alle spellen op te bouwen. Als
     * er daarna iets verandert aan het aantal spelers of dat het spel is begonnen moet de server weer een update
     * sturen.
     * @requires Dat de handshake is gedaan.
     * @requires Dat óf het spel in hasStarted-status is veranderd, óf in aantal spelers is veranderd, óf dat de client
     * nog niet de volledige lijst met spellen heeft ontvangen direct na de handshake.
     * @param creator De maker van het spel.
     * @param hasStarted De status van het spel.
     * @param noPlayers Het aantal spelers in het spel.
     */
    public abstract void game(String creator, int status, int noPlayers) throws IOException;

    /**
     * Commando om een spel te starten met twee spelers, die in die volgorde een zet moeten doen.
     * @requires Dat de handshake is gedaan.
     * @requires Dat de speler in een spel zit.
     * @requires Dat de creator van het spel het spel heeft gestart.
     * @requires Dat dit bericht nog niet is gestuurd voor dit spel.
     * @param playerOne De eerste speler
     * @param playerTwo De tweede speler
     */
    public abstract void start(String playerOne, String playerTwo) throws IOException;

    /**
     * Commando om een spel te starten met drie spelers, die in die volgorde een zet moeten doen.
     * @requires Dat de requirements bij de eerste overload zijn voldaan.
     * @param playerOne De eerste speler
     * @param playerTwo De tweede speler
     * @param playerThree De derde speler
     */
    public abstract void start(String playerOne, String playerTwo, String playerThree) throws IOException;

    /**
     * Commando om een spel te starten met vier spelers, die in die volgorde een zet moeten doen.
     * @requires Dat de requirements bij de eerste overload zijn voldaan.
     * @param playerOne De eerste speler
     * @param playerTwo De tweede speler
     * @param playerThree De derde speler
     * @param playerFour De vierde speler
     */
    public abstract void start(String playerOne, String playerTwo, String playerThree, String playerFour) throws IOException;

    /**
     * Commando om de client te vertellen dat hij een zet moet gaan doen.
     * @requires Dat de handshake is gedaan.
     * @requires Dat de speler in een spel zit.
     * @requires Dat het spel is gestart.
     * @requires Dat de speler ook echt aan de beurt is.
     */
    public abstract void move() throws IOException;

    /**
     * Commando om de client te laten weten dat iemand een zet heeft gedaan in het huidige spel.
     * @requires Dat de handshake is gedaan.
     * @requires Dat de speler in een spel zit.
     * @requires Dat het spel is gestart.
     * @requires Dat de speler die zet heeft gedaan
     * @param name Naam van de speler die de zet heeft gedan.
     * @param x X-coördinaat, waarbij de linkerkant 0 is en de rechterkant 7.
     * @param y Y-coördinaat, waarbij de bovenkant 0 is en de onderkant 7.
     */
    public abstract void moveDone(String name, int x, int y) throws IOException;

    /**
     * Commando om de client te laten weten dat het spel is afgelopen, om welke reden dan ook. Eventueel zijn er
     * winnaars als het spel helemaal is voltooid. De server mag bepalen wat er gebeurt als er meerdere mensen dezelfde
     * score hebben.
     * @requires Dat de handshake is gedaan.
     * @requires Dat de speler in een spel zit.
     * @requires Dat het spel is gestart.
     * @requires Dat:
     *           * Als het spel is gestart: ofwel het spel is afgelopen volgens de regels van de server ofwel één van de
     *                 mensen is weggegaan
     * @param score De hoogste score
     * @param winners De mensen met die score
     */
    public abstract void gameOver(int score, String[] winners) throws IOException;

    /**
     * Commando om de client op te hoogte te stellen van een chatbericht
     * @requires Dat de handshake is gedaan.
     * @requires Dat de speler dit bericht heeft verzonden.
     * @param name Afzender van het chatbericht
     * @param body Tekst van het chatbericht
     */
    public abstract void message(String name, String body) throws IOException;

    /**
     * Commando om de client op te hoogte te stellen van een uitdaging met twee mensen.
     * @requires Dat de handshake is gedaan.
     * @requires Dat de speler niet is uitgedaagd.
     * @requires Dat de speler niet in een spel zit.
     * @requires Dat de speler uitdaagbaar is.
     * @param challenger De uitdager
     */
    public abstract void challenge(String challenger, String other1) throws IOException;

    /**
     * Commando om de client op de hoogte te stellen van een uitdaging met drie mensen
     * @requires Dat de requirements bij de eerste overload zijn voldaan.
     * @param challenger De uitdager
     * @param other1 Andere gebruiker
     */
    public abstract void challenge(String challenger, String other1, String other2) throws IOException;

    /**
     * Commando om de client op de hoogte te stellen van een uitdaging met vier mensen
     * @requires Dat de requirements bij de eerste overload zijn voldaan.
     * @param challenger De uitdager
     * @param other1 Andere gebruiker 1
     * @param other2 Andere gebruiker 2
     */
    public abstract void challenge(String challenger, String other1, String other2, String other3) throws IOException;

    /**
     * Commando om mensen die in een uitdaging zitten op de hoogte te stellen van de status van de uitgedaagden.
     * @requires Dat de handshake is gedaan.
     * @requires Dat de client is uitgedaagd.
     * @param name Naam van de uitgedaagde.
     * @param accept Of deze persoon accepteert.
     */
    public abstract void challengeResponse(String name, boolean accept) throws IOException;

    /**
     * Commando om de client op de hoogte te stellen van het veranderen van de status van iemand.
     * @requires Dat de handshake is gedaan.
     * @requires Dat de flag true is als de speler is uitgedaagd of een uitdager is.
     * @param name Naam van de uitgedaagde
     * @param flag Of hij kan worden uitgedaagd.
     */
    public abstract void canBeChallenged(String name, boolean flag) throws IOException;

    /**
     * Commando om de client op de hoogte te stellen van de gevraagde highscores.
     * @requires Dat de handshake is gedaan.
     * @requires Dat de client heeft gevraagd om highscores.
     * @param args Argumenten
     */
    public abstract void highscore(String[] args) throws IOException;

    /**
     * Commando om de client op de hoogte te stellen van een gebruiker die inlogt of weggaat
     * @requires Dat de handshake is gedaan
     * @requires Dat ófwel er een client bijkomt, ófwel er een client weggaat, ófwel dat de client de lijst met mensen
     * nog niet in zijn geheel heeft ontvangen na de lijst van spellen. Dit laatste is geen requirement voor servers
     * zonder chat.
     */
    public abstract void online(String name, boolean isOnline) throws IOException;
}
package rolit.model.networking.server;

import rolit.model.networking.client.MovePacket;

public class GameClientHandlerState extends ClientHandlerState {
    private final String creator;

    public GameClientHandlerState(ClientHandler handler, String creator) {
        super(handler);
        this.creator = creator;
    }

    public String getCreator() {
        return creator;
    }

    @Override
    public ClientHandlerState move(MovePacket packet) {
        return this;
    }
}
package rolit.model.networking.server;

import rolit.model.networking.common.Packet;
import rolit.model.networking.common.PacketArgs;

public class HandshakePacket extends Packet {
    private int supports;
    private String version;
    private String nonce;

    public HandshakePacket(int supports, String version, String nonce) {
        this.supports = supports;
        this.version = version;
        this.nonce = nonce;
    }

    public HandshakePacket(int supports, String version) {
        this(supports, version, null);
    }

    @Override
    protected void readFromArgs(PacketArgs args) {
        this.supports = args.getInt(0);
        this.version = args.getString(1);
        this.nonce = args.getMultiString(2).length == 1 ? args.getMultiString(2)[0] : null;
    }

    @Override
    protected PacketArgs.ArgumentType[] getArgumentTypes() {
        return new PacketArgs.ArgumentType[] { PacketArgs.ArgumentType.Integer, PacketArgs.ArgumentType.String, PacketArgs.ArgumentType.MultiString };
    }

    @Override
    protected Object[] getData() {
        return new Object[] { supports, version, nonce == null ? new String[] {  } : new String[] { nonce } };
    }
}
package rolit.model.networking.server;

import rolit.model.networking.client.StartGamePacket;

public class ChallengerClientHandlerState extends ClientHandlerState {
    public ChallengerClientHandlerState(ClientHandler handler) {
        super(handler);
    }

    @Override
    public ClientHandlerState startGame(StartGamePacket packet) {
        return new GameClientHandlerState();
    }
}
package rolit.model.networking.server;

import rolit.model.networking.common.Packet;
import rolit.model.networking.common.PacketArgs;

public class HighscorePacket extends Packet {
    private String[] data;

    public HighscorePacket(String[] data) {
        this.data = data;
    }

    public String[] getDataField() {
        return data;
    }

    @Override
    protected void readFromArgs(PacketArgs args) {
        this.data = args.getMultiString(0);
    }

    @Override
    protected PacketArgs.ArgumentType[] getArgumentTypes() {
        return new PacketArgs.ArgumentType[] { PacketArgs.ArgumentType.MultiString };
    }

    @Override
    protected Object[] getData() {
        return new Object[] { data };
    }
}
package rolit.model.networking.server;

import rolit.model.networking.client.ChallengePacket;
import rolit.model.networking.client.CreateGamePacket;
import rolit.model.networking.client.JoinGamePacket;

public class GameLobbyClientHandlerState extends ClientHandlerState {
    public GameLobbyClientHandlerState(ClientHandler handler) {
        super(handler);
        getHandler().write(new HandshakePacket(Server.GLOBAL_SUPPORTS, Server.GLOBAL_VERSION));
    }

    @Override
    public ClientHandlerState challenge(ChallengePacket packet) {
        return new ChallengerClientHandlerState(getHandler());
    }

    @Override
    public ClientHandlerState joinGame(JoinGamePacket packet) {
        return new WaitForGameClientHandlerState(getHandler(), packet.getCreator());
    }

    @Override
    public ClientHandlerState createGame(CreateGamePacket packet) {
        return new WaitForGameClientHandlerState(getHandler(), getHandler().getClientName());
    }
}
package rolit.model.networking.server;

import rolit.model.networking.common.Packet;
import rolit.model.networking.common.PacketArgs;

public class MoveDonePacket extends Packet {
    private String user;
    private int x;
    private int y;

    public MoveDonePacket(String user, int x, int y) {
        this.user = user;
        this.x = x;
        this.y = y;
    }

    public String getUser() {
        return user;
    }

    public int getX() {
        return x;
    }

    public int getY() {
        return y;
    }

    @Override
    protected void readFromArgs(PacketArgs args) {
        this.user = args.getString(0);
        this.x = args.getInt(1);
        this.y = args.getInt(2);
    }

    @Override
    protected PacketArgs.ArgumentType[] getArgumentTypes() {
        return new PacketArgs.ArgumentType[] { PacketArgs.ArgumentType.String, PacketArgs.ArgumentType.Integer, PacketArgs.ArgumentType.Integer };
    }

    @Override
    protected Object[] getData() {
        return new Object[] { user, x, y };
    }
}
package rolit.model.networking.client;

import rolit.model.networking.common.CommonProtocol;

/**
 * @author Pieter Bos
 * @author Martijn de Bijl
 *
 * Abstract class met alle constanten en methodes die gebruikt kunnen worden
 */
public abstract class ClientProtocol extends CommonProtocol {
    /**
     * Constante voor het handshake-commando
     */
    public static final String HANDSHAKE = "hello";

    /**
     * Constante voor het auth-commando
     */
    public static final String AUTH = "auth";

    /**
     * Constante voor het create-gamecommando
     */
    public static final String CREATE_GAME = "createGame";

    /**
     * Constante voor het join-gamecommando
     */
    public static final String JOIN_GAME = "joinGame";

    /**
     * Constante voor het start-gamecommando
     */
    public static final String START_GAME = "startGame";

    /**
     * Constante voor het movecommando
     */
    public static final String MOVE = "move";

    /**
     * Constante voor het messagecommando
     */
    public static final String MESSAGE = "message";

    /**
     * Constante voor het challengecommando
     */
    public static final String CHALLENGE = "challenge";

    /**
     * Constante voor het challenge-responsecommando
     */
    public static final String CHALLENGE_RESPONSE = "challengeResponse";

    /**
     * Constante voor het highscorecommando
     */
    public static final String HIGHSCORE = "highscore";

    /**
     * Handshake voor de server. Moet altijd het eerste verzonden pakket zijn, met uitzondering van de errors.
     * @requires Dat de handshake nog niet is ontvangen
     * @requires Dat dit het eerste pakket op de communicatelijn is.
     * @param clientName Naam van de client.
     * @param supports Wat de client ondersteunt.
     * @param version Een beschrijving van wat de client kan.
     */
    public abstract void hello(String clientName, int supports, String version);

    /**
     * Authenticatie van de client.
     * @requires Dat de handshake is gedaan.
     * @requires Dat de client de private key heeft opgehaald bij ss-security.student.utwente.nl met de verstuurde
     * private key en bijbehorend wachtwoord.
     * @requires Dat de nonce die door de server is gestuurd is gesigned met de private key.
     * @param signature De gesignde nonce
     */
    public abstract void auth(String signature);

    /**
     * Maak een spel
     * @requires Dat de handshake is gedaan.
     * @requires Dat de client nog geen spel is begonnen
     */
    public abstract void createGame();

    /**
     * Join een spel
     * @requires Dat de handshake is gedaan.
     * @requires Dat de speler nog niet in een spel zit.
     * @requires Dat het spel nog niet vol zit.
     * @param creator De maker van het spel
     */
    public abstract void joinGame(String creator);

    /**
     * @requires Dat de handshake is gedaan.
     * @requires Dat de speler in een spel zit.
     * @requires Dat de speler de creator van het spel is.
     * @requires Dat het spel nog niet is gestart.
     * Start het spel waarvan de gebruiker de creator is.
     */
    public abstract void startGame();

    /**
     * Doe een zet
     * @requires Dat de handshake is gedaan.
     * @requires Dat de speler in een spel zit
     * @requires Dat de speler een move-commando heeft ontvangen.
     * @param x X-coördinaat
     * @param y Y-coördinaat
     */
    public abstract void move(int x, int y);

    /**
     * @requires Dat de handshake is gedaan.
     * @requires Dat de server chat-berichten ondersteunt.
     * Stuur een bericht naar iedereen in de lobby of iedereen in het spel
     * @param body Het bericht
     */
    public abstract void message(String body);

    /**
     * Daag één ander uit voor een spel
     * @requires Dat de handshake is gedaan.
     * @requires Dat de speler niet in een spel zit.
     * @requires Dat de speler niet een uitdager is.
     * @requires Dat de speler niet al is uitgedaagd.
     * @requires Dat de uitgedaagde(n) kunnen worden uitgedaagd.
     * @param other De ander
     */
    public abstract void challenge(String other);

    /**
     * Daag twee anderen uit voor een spel
     * @requires Dat de requirements bij de andere overload worden voldaan.
     * @param other1 De een
     * @param other2 De ander
     */
    public abstract void challenge(String other1, String other2);

    /**
     * Daag drie anderen uit voor een spel
     * @requires Dat de requirements bij de andere overload worden voldaan.
     * @param other1 De eerste andere
     * @param other2 De tweede andere
     * @param other3 De derder andere
     */
    public abstract void challenge(String other1, String other2, String other3);

    /**
     * Reageer op een uitdaging
     * @requires Dat de handshake is gedaan.
     * @requires Dat de speler is uitgedaagd.
     * @param accept Of de client accepteert
     */
    public abstract void challengeResponse(boolean accept);

    /**
     * Vraag highscores op bij de server
     * @requires Dat de handshake is gedaan
     * @requires Dat wanneer het type één van "date" of "player" is, arg respectievelijk van het volgende formaat is:
     *           * yyyy-[m]m-[d]d
     *           * SpelerNaamZonderSpaties
     * @param type Type highscore (bijv. date, player)
     * @param arg Een argument (bijv. 2014-01-01)
     */
    public abstract void highscore(String type, String arg);
}
package rolit.model.networking.client;

import rolit.model.networking.common.Packet;
import rolit.model.networking.common.PacketArgs;

public class StartGamePacket extends Packet {
    public StartGamePacket() {

    }

    @Override
    protected void readFromArgs(PacketArgs args) {

    }

    @Override
    protected PacketArgs.ArgumentType[] getArgumentTypes() {
        return new PacketArgs.ArgumentType[] {  };
    }

    @Override
    protected Object[] getData() {
        return new Object[] {  };
    }
}
package rolit.model.networking.client;

import rolit.model.networking.common.Packet;
import rolit.model.networking.common.PacketArgs;

public class MessagePacket extends Packet {
    private String message;

    public MessagePacket(String message) {

        this.message = message;
    }

    public String getMessage() {
        return message;
    }

    @Override
    protected void readFromArgs(PacketArgs args) {
        this.message = args.getString(0);
    }

    @Override
    protected PacketArgs.ArgumentType[] getArgumentTypes() {
        return new PacketArgs.ArgumentType[] { PacketArgs.ArgumentType.String };
    }

    @Override
    protected Object[] getData() {
        return new Object[] { message };
    }
}
package rolit.model.networking.client;

import rolit.model.networking.common.Packet;
import rolit.model.networking.common.PacketArgs;

public class ChallengeResponsePacket extends Packet {
    private boolean response;

    public ChallengeResponsePacket(boolean response) {
        this.response = response;
    }

    public boolean isResponse() {
        return response;
    }

    @Override
    protected void readFromArgs(PacketArgs args) {
        this.response = args.getBool(0);
    }

    @Override
    protected PacketArgs.ArgumentType[] getArgumentTypes() {
        return new PacketArgs.ArgumentType[] { PacketArgs.ArgumentType.Boolean };
    }

    @Override
    protected Object[] getData() {
        return new Object[] { response };
    }
}
package rolit.model.networking.client;

import rolit.model.networking.common.Packet;
import rolit.model.networking.common.PacketArgs;

public class MovePacket extends Packet {
    private int x;
    private int y;

    public MovePacket(int x, int y) {
        this.x = x;
        this.y = y;
    }

    public int getX() {
        return x;
    }

    public int getY() {
        return y;
    }

    @Override
    protected void readFromArgs(PacketArgs args) {
        this.x = args.getInt(0);
        this.y = args.getInt(1);
    }

    @Override
    protected PacketArgs.ArgumentType[] getArgumentTypes() {
        return new PacketArgs.ArgumentType[] { PacketArgs.ArgumentType.Integer, PacketArgs.ArgumentType.Integer };
    }

    @Override
    protected Object[] getData() {
        return new Object[] { x, y };
    }
}
package rolit.model.networking.client;

import rolit.model.networking.common.Packet;
import rolit.model.networking.common.PacketArgs;

public class CreateGamePacket extends Packet {
    public CreateGamePacket() {

    }

    @Override
    protected void readFromArgs(PacketArgs args) {

    }

    @Override
    protected PacketArgs.ArgumentType[] getArgumentTypes() {
        return new PacketArgs.ArgumentType[] {  };
    }

    @Override
    protected Object[] getData() {
        return new Object[] {  };
    }
}
package rolit.model.networking.client;

import rolit.model.networking.common.Packet;
import rolit.model.networking.common.PacketArgs;

public class ChallengePacket extends Packet {

    private String[] challenged;

    public ChallengePacket(String[] challenged) {
        this.challenged = challenged;
    }

    public String[] getChallenged() {
        return challenged;
    }

    @Override
    protected void readFromArgs(PacketArgs args) {
        this.challenged = args.getMultiString(0);
    }

    @Override
    protected PacketArgs.ArgumentType[] getArgumentTypes() {
        return new PacketArgs.ArgumentType[] { PacketArgs.ArgumentType.MultiString };
    }

    @Override
    protected Object[] getData() {
        return new Object[] { challenged };
    }
}
package rolit.model.networking.client;

import rolit.model.networking.common.Packet;
import rolit.model.networking.common.PacketArgs;

public class JoinGamePacket extends Packet {

    private String creator;

    public JoinGamePacket(String creator) {
        this.creator = creator;
    }

    public String getCreator() {
        return creator;
    }

    @Override
    protected void readFromArgs(PacketArgs args) {
        this.creator = args.getString(0);
    }

    @Override
    protected PacketArgs.ArgumentType[] getArgumentTypes() {
        return new PacketArgs.ArgumentType[] { PacketArgs.ArgumentType.String };
    }

    @Override
    protected Object[] getData() {
        return new Object[] { creator };
    }
}
package rolit.model.networking.client;

import rolit.model.networking.common.Packet;
import rolit.model.networking.common.PacketArgs;

public class HandshakePacket extends Packet {
    private String name;
    private int supports;
    private String version;

    public HandshakePacket(String name, int supports, String version) {

        this.name = name;
        this.supports = supports;
        this.version = version;
    }

    @Override
    protected void readFromArgs(PacketArgs args) {
        this.name = args.getString(0);
        this.supports = args.getInt(1);
        this.version = args.getString(2);
    }

    @Override
    protected PacketArgs.ArgumentType[] getArgumentTypes() {
        return new PacketArgs.ArgumentType[] { PacketArgs.ArgumentType.Integer, PacketArgs.ArgumentType.String };
    }

    @Override
    protected Object[] getData() {
        return new Object[] { name, supports, version };
    }

    public String getName() {
        return name;
    }

    public int getSupports() {
        return supports;
    }

    public String getVersion() {
        return version;
    }
}
package rolit.model.networking.client;

import rolit.model.networking.common.Packet;
import rolit.model.networking.common.PacketArgs;

public class AuthPacket extends Packet {
    private String cypherText;

    public AuthPacket(String cypherText) {
        this.cypherText = cypherText;
    }

    public String getCypherText() {
        return cypherText;
    }

    @Override
    protected void readFromArgs(PacketArgs args) {
        this.cypherText = args.getString(0);
    }

    @Override
    protected PacketArgs.ArgumentType[] getArgumentTypes() {
        return new PacketArgs.ArgumentType[] { PacketArgs.ArgumentType.String };
    }

    @Override
    protected Object[] getData() {
        return new Object[] { cypherText };
    }
}
package rolit.model.networking.client;

import rolit.model.networking.common.Packet;
import rolit.model.networking.common.PacketArgs;

public class HighscorePacket extends Packet {
    private String type;
    private String arg;

    public HighscorePacket(String type, String arg) {
        this.type = type;
        this.arg = arg;
    }

    public String getType() {
        return type;
    }

    public String getArg() {
        return arg;
    }

    @Override
    protected void readFromArgs(PacketArgs args) {
        this.type = args.getString(0);
        this.arg = args.getString(1);
    }

    @Override
    protected PacketArgs.ArgumentType[] getArgumentTypes() {
        return new PacketArgs.ArgumentType[] { PacketArgs.ArgumentType.String, PacketArgs.ArgumentType.String };
    }

    @Override
    protected Object[] getData() {
        return new Object[] { type, arg };
    }
}
package rolit.model.game;

/**
 * Created by Martijn on 20-1-14.
 */
public class Player {

    private final int color;

    public Player(int nummer) {
        this.color = nummer;
    }


    public int getColor() {
        return color;
    }
}
package rolit.model.game;

/**
 * Created by Martijn on 20-1-14.
 */
public class Position {

    private int y;
    private int x;

    public Position(int x, int y){
        this.x = x;
        this.y = y;
    }

    public int getX(){
        return x;
    }

    public int getY(){
        return y;
    }


    public Position add(Position direction) {
        Position result = new Position(this.getX() + direction.getX(), this.getY() + direction.getY());
        return result;
    }

    public Position runVector(Position position){
        int x = position.getX();
        int y = position.getY();
        return new Position(x,y);
    }
}
package rolit.model.game;

public class Game {

    private final int players;
    private final Board board;
    private int currentPlayer;

    public Game(int players){
        this.players = players;
        board = new Board();
        currentPlayer = 0;
    }

    public int getPlayers() {
        return players;
    }

    public Board getBoard() {
        return board;
    }

    public int getCurrentPlayer() {
        return currentPlayer;
    }

    public boolean legalMove(Board board){
        return true;
    }



}
package rolit.model.game;

import java.util.LinkedList;

/**
 * The board class
 *
 * @author Martijn de Bijl
 */
public class Board {
    /**
     * De standaard hoogte voor het bord.
     */
    public static final int BOARD_WIDTH = 8;
    /**
     * De standaard breedte van het bord.
     */
    public static final int BOARD_HEIGHT = 8;
    /**
     * De variabele die een leeg veld aangeeft.
     */
    public static final int EMPTY_FIELD = 9;

    /**
     * De array waarin de informatie van het bord is opgeslagen.
     */
    private int[][] array;

    /**
     * Alle richtingen waarin gekeken moet worden naar aanliggende kleuren
     */
    private static Position[] DIRECTIONS = {
            new Position(-1, -1),
            new Position(-1, 0),
            new Position(-1, 1),
            new Position(1, 0),
            new Position(1, -1),
            new Position(1, 1),
            new Position(0, 1),
            new Position(0, -1)
    };

    /**
     * Constructor voor klasse bord. Hierin wordt de array aangemaakt en gevuld met legen velden en de 4 balletje in
     * het midden.
     */
    public Board() {
        array = new int[BOARD_WIDTH][BOARD_HEIGHT];
        for (int x = 0; x < BOARD_WIDTH; x++) {
            for (int y = 0; y < BOARD_HEIGHT; y++) {
                array[x][y] = EMPTY_FIELD;
                array[x][y] = EMPTY_FIELD;
            }
        }
        array[3][3] = 0;
        array[4][3] = 1;
        array[4][4] = 2;
        array[3][4] = 3;

    }

    /**
     * Geeft terug waarmee een bepaald veld gevuld is.
     *
     * @param x de x-coördinaat, oftewel horizontale positie op het bord.
     * @param y de y-coördinaat, oftwel vericale positie op het bord.
     * @return geeft een integer terug die de kleur van de speler, of een leeg veld aangeeft.
     */
    public int getField(int x, int y) {
        return array[x][y];
    }

    /**
     * Geeft terug waarmee een bepaald veld gevuld is.
     *
     * @param position de positie van het veld, gegeven in een vector met een x en y coördinaat.
     * @return geeft een integer terug die de kleur van de speler, of een leeg veld aangeeft.
     */
    public int getField(Position position) {
        int x = (position.getX());
        int y = (position.getY());
        return array[x][y];
    }

    /**
     * Vult een bepaald veld met een kleur van een speler.
     * @param x     de x-coördinaat, oftewel horizontale positie op het bord.
     * @param y     de y-coördinaat, oftwel vericale positie op het bord.
     * @param field de integer die de kleur van de speler aangeeft.
     */
    public void setField(int x, int y, int field) {
        array[x][y] = field;
    }

    /**
     * Vult een bepaald veld met een kleur van een speler.
     * @param position de positie van het veld, gegeven in een vector met een x en y coördinaat.
     * @param field de integer die de kleur van de speler aangeeft.
     */
    public void setField(Position position, int field){
        array[position.getX()][position.getY()] = field;
    }

    /**
     * Geeft terug of een veld leeg is.
     * @param x de x-coördinaat, oftewel horizontale positie op het bord.
     * @param y de y-coördinaat, oftwel vericale positie op het bord.
     * @return een boolean of het veld leeg is.
     */
    public boolean isEmpty(int x, int y) {
        if (array[x][y] == EMPTY_FIELD) {
            return true;
        } else {
            return false;
        }
    }

    /**
     * Geeft terug of een veld leeg is.
     * @param position de positie van het veld, gegeven in een vector met een x en y coördinaat.
     * @return een boolean of het veld leeg is.
     */
    public boolean isEmpty(Position position) {
        if (array[position.getX()][position.getY()] == EMPTY_FIELD) {
            return true;
        } else {
            return false;
        }
    }

    /**
     * Maakt een kopie van het huidige bord.
     * @return een nieuw bord met alle informatie van het huidige bord.
     */
    public Board copy() {
        Board copy = new Board();
        for (int x = 0; x <= BOARD_WIDTH; x++) {
            for (int y = 0; y <= BOARD_HEIGHT; y++) {
                copy.setField(x, y, getField(x, y));
            }
        }
        return copy;
    }

    /**
     * Kijkt op een bepaald veld in alle richtingen welke slagen mogelijk zijn.
     *
     * @param player       de speler die de zet wil doen.
     * @param movePosition het veld waarop de speler de zet wil doen.
     * @return een array met alle slagen die mogelijk zijn.
     */
    public Capture[] getCapture(Player player, Position movePosition) {
        Position position = new Position(movePosition.getX(), movePosition.getY());
        LinkedList<Capture> captures = new LinkedList<Capture>();
        int length = 0;

        if (this.isEmpty(position) == false) {
            Capture[] capture = new Capture[0];
            return capture;
        } else {
            for (Position direction : DIRECTIONS) {
                Position checkField = new Position(position.add(direction).getX(), position.add(direction).getY());
                while (this.getField(checkField) != player.getColor() && this.getField(checkField) != EMPTY_FIELD) {
                    checkField = checkField.add(direction);
                    length++;
                }
                if (this.getField(checkField.add(direction)) == player.getColor() && length > 1) {
                    captures.add(new Capture(checkField, length));
                }
            }

            Capture[] result = new Capture[captures.size()];
            captures.toArray(result);
            return result;
        }
    }

    /**
     * Kijkt of een zet legaal is.
     *
     * @param player       de speler die de zet wil doen.
     * @param movePosition het veld waarop de speler de zet wil doen.
     * @return een boolean of de zet legaal is.
     */
    public boolean isLegalMove(Player player, Position movePosition) {
        Position position = new Position(movePosition.getX(), movePosition.getY());
        Capture[] captures = getCapture(player, position);

        if (captures.length != 0) {
            return true;
        }

        for (Position directions : DIRECTIONS) {
            if (this.getField(position.add(directions)) == EMPTY_FIELD) {
                return false;
            }
        }

        for (int y = 0; y < BOARD_HEIGHT; y++) {
            for (int x = 0; x < BOARD_WIDTH; x++) {
                Position checkField = new Position(x, y);
                if (getCapture(player, checkField).length > 0) {
                    return false;
                }
            }
        }
        return true;
    }

    /**
     * Doet de zet van een speler, en verandert alle kleuren naar zijn kleur van de geslagen balletjes.
     * @param player de speler die de zet doet.
     * @param movePosition het veld waarop de speler de zet wil doen.
     * @return een boolean of de zet gelukt is.
     */
    public boolean doMove(Player player, Position movePosition){
        if (isLegalMove(player,movePosition) == true){
            Capture[] captures = getCapture(player, movePosition);
            setField(movePosition, player.getColor());

            for(Capture capture : captures){
                for (int i = 0; i < captures.length; i++){
                    int x = (capture.getDirection().getX() + i * (capture.getDirection().getX()));
                    int y = (capture.getDirection().getY() + i * (capture.getDirection().getY()));
                    Position seize = new Position(x,y);
                    setField(seize, player.getColor());
                }
            }
            return true;
        }
        else {
            return false;
        }
    }

    /**
     * Maakt een visuele representatie van het huidige bord.
     *
     * @return een string zo geformat dat het bord leesbaar is.
     */
    public String toString() {
        String result = "+-+-+-+-+-+-+-+-+\n";
        for (int y = 0; y < BOARD_HEIGHT; y++) {
            boolean first = true;

            for (int x = 0; x < BOARD_WIDTH; x++) {
                if (first) {
                    result += "|";
                }

                first = false;

                result += getField(x, y) == EMPTY_FIELD ? " " : getField(x, y);

                result += "|";
            }

            result += "\n+-+-+-+-+-+-+-+-+\n";
        }
        return result;
    }

}
package rolit.model.game;

/**
 * Created by Martijn on 20-1-14.
 */
public class Capture {

    private int length;
    private Position direction;

    public Capture(Position direction, int length){
        this.length = length;
        this.direction = direction;
    }

    public int getLength(){
        return length;
    }

    public Position getDirection(){
        return direction;
    }


}
package rolit.model.game;

/**
 * Created by Martijn on 20-1-14.
 */
public class Vector {

    private int y;
    private int x;

    public Vector(int x, int y){
        this.x = x;
        this.y = y;
    }

    public int getX(){
        return x;
    }

    public int getY(){
        return y;
    }


    public Vector add(Vector direction) {
        Vector result = new Vector(this.getX() + direction.getX(), this.getY() + direction.getY());
        return result;
    }

    public Vector runVector(Vector vector){
        int x = vector.getX();
        int y = vector.getY();
        return new Vector(x,y);
    }
}
package rolit.model.event;

import rolit.model.networking.server.ClientHandler;

public interface ServerListener {
    public void serverError(String reason);
    public void newClient(ClientHandler handler);
    public void clientError(String reason);
}
package rolit.model.pietergame;

/**
 * Created by Martijn on 20-1-14.
 */
public class Position {
    public Position(int x, int y) {

    }
}
package rolit.model.pietergame;

import rolit.common.Position;

import java.util.LinkedList;

public class Board {
    public static int WIDTH = 8;
    public static int HEIGHT = 8;

    public static int NO_PLAYER = -1;

    private static Position[] DIRECTIONS = {
        new Position(-1, -1),
        new Position(0, -1),
        new Position(1, -1),
        new Position(-1, 0),
        new Position(1, 0),
        new Position(-1, 1),
        new Position(0, 1),
        new Position(1, 1),
    };

    private int[][] board = new int[WIDTH][HEIGHT];

    public Board() {
        for(int x = 0; x < WIDTH; x++) {
            for(int y = 0; y < HEIGHT; y++) {
                board[x][y] = NO_PLAYER;
            }
        }

        int middleX = WIDTH / 2 - 1;
        int middleY = HEIGHT / 2 - 1;

        board[middleX][middleY] = 0;
        board[middleX + 1][middleY] = 1;
        board[middleX][middleY + 1] = 2;
        board[middleX + 1][middleY + 1] = 3;
    }

    public int get(Position position) {
        return board[position.getX()][position.getY()];
    }

    private void set(Position position, int player) {
        board[position.getX()][position.getY()] = player;
    }

    public Capture[] getCaptures(int player, Position movePosition) {
        LinkedList<Capture> captures = new LinkedList<Capture>();

        for(Position direction : DIRECTIONS) {
            for(int length = Math.max(WIDTH, HEIGHT); length >= 2; length--) {
                Position position = movePosition.add(direction.scalarMultiply(length));

                if(position.inRectangle(WIDTH, HEIGHT) && get(position) == player) {
                    boolean anyOther = false;
                    boolean filled = true;

                    for(int i = 1; i < length; i++) {
                        Position innerPosition = movePosition.add(direction.scalarMultiply(i));

                        if(innerPosition.inRectangle(WIDTH, HEIGHT)) {
                            if(get(innerPosition) == NO_PLAYER) {
                                filled = false;
                            } else if(get(innerPosition) != player) {
                                anyOther = true;
                            }
                        }
                    }

                    if(filled && anyOther) {
                        captures.add(new Capture(direction, length));
                        break;
                    }
                }
            }
        }

        Capture[] result = new Capture[captures.size()];
        captures.toArray(result);
        return result;
    }

    public boolean isValidMove(int player, Position movePosition) {
        boolean adjacent = false;

        for(Position direction : DIRECTIONS) {
            Position position = movePosition.add(direction);

            if(position.inRectangle(WIDTH, HEIGHT) && get(position) != NO_PLAYER) {
                adjacent = true;
                break;
            }
        }

        if(!adjacent) {
            return false;
        }

        // Ensured that the move is adjacent to any other ball

        if(getCaptures(player, movePosition).length > 0) {
            return true;
        }

        // Player didn't do a block and capture

        for(int x = 0; x < WIDTH; x++) {
            for(int y = 0; y < HEIGHT; y++) {
                Position currentPosition = new Position(x, y);

                if(get(currentPosition) != NO_PLAYER) {
                    continue;
                }

                if(getCaptures(player, movePosition).length > 0) {
                    // Block and capture was possible, but player didn't do it
                    return false;
                }
            }
        }

        // Block and capture impossible, so the move is valid
        return true;
    }

    public boolean doMove(int player, Position movePosition) {
        if(isValidMove(player, movePosition)) {
            Capture[] captures = getCaptures(player, movePosition);

            set(movePosition, player);

            for(Capture capture : captures) {
                for(int i = 1; i < capture.getLength(); i++) {
                    Position position = movePosition.add(capture.getDirection().scalarMultiply(i));
                    set(position, player);
                }
            }

            return true;
        } else {
            return false;
        }
    }

    @Override
    public String toString() {
        String result = "";

        for(int y = 0; y < HEIGHT; y++) {
            for(int x = 0; x < WIDTH; x++) {
                result += " 0123".charAt(board[x][y] + 1);
            }

            result += "\n";
        }

        return result;
    }

    public static void main(String[] args) {
        Board b = new Board();

        System.out.print(b);

        System.out.println(b.doMove(2, new Position(5, 2)));

        System.out.print(b);
    }
}
import rolit.common.Position;

public class Capture {

    private final int length;
    private final Position direction;

    public Capture(Position direction, int length) {
        this.length = length;
        this.direction = direction;
    }

    public int getLength() {
        return length;
    }

    public Position getDirection() {
        return direction;
    }

}
package rolit.util;

public class Strings {
    public static String join(String delimiter, String[] strings) {
        String result = "";
        boolean first = true;

        for(String string : strings) {
            if(!first) {
                result += delimiter;
            }

            first = false;

            result += string;
        }

        return result;
    }
}
./src/rolit/view/layout/VSplitLayoutManager.java
./src/rolit/view/layout/HBoxLayoutManager.java
./src/rolit/view/layout/CenterLayoutManager.java
./src/rolit/view/layout/VBoxLayoutManager.java
./src/rolit/view/layout/HSplitLayoutManager.java
./src/rolit/view/layout/LeftRightLayoutManager.java
./src/rolit/view/layout/GridLayoutManager.java
./src/rolit/view/client/ChatPanel.java
./src/rolit/view/client/GameListPanel.java
./src/rolit/view/client/JoinGameAction.java
./src/rolit/view/client/ConnectPanel.java
./src/rolit/view/client/action/Action.java
./src/rolit/view/client/action/CreateGameAction.java
./src/rolit/view/client/action/ConnectAction.java
./src/rolit/view/client/ServerPanel.java
./src/rolit/view/client/MainView.java
./src/rolit/view/client/EventThread.java
./src/rolit/view/client/ChallengePanel.java
./src/rolit/view/client/WaitPanel.java
./src/rolit/view/client/GamePanel.java
./src/rolit/view/client/Program.java
./src/rolit/model/networking/sssecurity/SSSecurity.java
./src/rolit/model/networking/common/PacketInputStream.java
./src/rolit/model/networking/common/CommonProtocol.java
./src/rolit/model/networking/common/Packet.java
./src/rolit/model/networking/common/ProtocolException.java
./src/rolit/model/networking/common/PacketArgs.java
./src/rolit/model/networking/common/PacketSource.java
./src/rolit/model/networking/extensions/WebSocketClientProtocol.java
./src/rolit/model/networking/extensions/WebSocketServerProtocol.java
./src/rolit/model/networking/server/CanBeChallengedPacket.java
./src/rolit/model/networking/server/ErrorPacket.java
./src/rolit/model/networking/server/WaitForGameClientHandlerState.java
./src/rolit/model/networking/server/InitialClientHandlerState.java
./src/rolit/model/networking/server/Server.java
./src/rolit/model/networking/server/StartPacket.java
./src/rolit/model/networking/server/ServerGame.java
./src/rolit/model/networking/server/User.java
./src/rolit/model/networking/server/MessagePacket.java
./src/rolit/model/networking/server/ClientHandlerState.java
./src/rolit/model/networking/server/ChallengedClientHandlerState.java
./src/rolit/model/networking/server/ChallengeResponsePacket.java
./src/rolit/model/networking/server/GameOverPacket.java
./src/rolit/model/networking/server/ClientHandler.java
./src/rolit/model/networking/server/MovePacket.java
./src/rolit/model/networking/server/ChallengePacket.java
./src/rolit/model/networking/server/GamePacket.java
./src/rolit/model/networking/server/AuthClientHandlerState.java
./src/rolit/model/networking/server/OnlinePacket.java
./src/rolit/model/networking/server/ServerProtocol.java
./src/rolit/model/networking/server/GameClientHandlerState.java
./src/rolit/model/networking/server/HandshakePacket.java
./src/rolit/model/networking/server/ChallengerClientHandlerState.java
./src/rolit/model/networking/server/HighscorePacket.java
./src/rolit/model/networking/server/GameLobbyClientHandlerState.java
./src/rolit/model/networking/server/AuthOkPacket.java
./src/rolit/model/networking/server/MoveDonePacket.java
./src/rolit/model/networking/client/ClientProtocol.java
./src/rolit/model/networking/client/StartGamePacket.java
./src/rolit/model/networking/client/MessagePacket.java
./src/rolit/model/networking/client/ClientGame.java
./src/rolit/model/networking/client/ChallengeResponsePacket.java
./src/rolit/model/networking/client/ServerHandler.java
./src/rolit/model/networking/client/MovePacket.java
./src/rolit/model/networking/client/CreateGamePacket.java
./src/rolit/model/networking/client/ChallengePacket.java
./src/rolit/model/networking/client/JoinGamePacket.java
./src/rolit/model/networking/client/HandshakePacket.java
./src/rolit/model/networking/client/AuthPacket.java
./src/rolit/model/networking/client/HighscorePacket.java
./src/rolit/model/game/Player.java
./src/rolit/model/game/HumanPlayer.java
./src/rolit/model/game/Test/GameTest.java
./src/rolit/model/game/Test/HumanPlayerTest.java
./src/rolit/model/game/Test/BoardTest.java
./src/rolit/model/game/Position.java
./src/rolit/model/game/EasyComputerPlayer.java
./src/rolit/model/game/Game.java
./src/rolit/model/game/GameFullException.java
./src/rolit/model/game/Board.java
./src/rolit/model/game/Capture.java
./src/rolit/model/event/ServerListener.java
./src/rolit/util/Strings.java
./src/rolit/util/BiMap.java
./src/rolit/util/Crypto.java
./src/rolit/util/Arrays.java
package rolit.view.layout;

import java.awt.*;

/**
 * @author Pieter Bos
 *
 * Lays out exactly two components stacked vertically, splitting at a given distance from the top or bottom.
 */
public class VSplitLayoutManager implements LayoutManager {
    public enum VSplitType {
        Top,
        Bottom
    }

    private static final int DEFAULT_SPLIT = 24;
    private static final VSplitType DEFAULT_TYPE = VSplitType.Top;

    private VSplitType splitType;
    private int split;

    public VSplitLayoutManager(int split, VSplitType type) {
        this.splitType = type;
        this.split = split;
    }

    public VSplitLayoutManager(int split) {
        this(split, DEFAULT_TYPE);
    }

    public VSplitLayoutManager(VSplitType type) {
        this(DEFAULT_SPLIT, type);
    }

    public VSplitLayoutManager() {
        this(DEFAULT_TYPE);
    }

    @Override
    public void addLayoutComponent(String name, Component comp) {
    }

    @Override
    public void removeLayoutComponent(Component comp) {
    }

    @Override
    public Dimension preferredLayoutSize(Container parent) {
        return parent.getParent().getMinimumSize();
    }

    @Override
    public Dimension minimumLayoutSize(Container parent) {
        Dimension size1 = parent.getComponent(0).getMinimumSize();
        Dimension size2 = parent.getComponent(1).getMinimumSize();
        return new Dimension(Math.max(size1.width, size2.width), size1.height + size2.height);
    }

    @Override
    public void layoutContainer(Container parent) {
        Dimension parentSize = parent.getSize();
        Dimension size1 = parent.getComponent(0).getPreferredSize();
        Dimension size2 = parent.getComponent(1).getPreferredSize();

        if(splitType == VSplitType.Top) {
            parent.getComponent(0).setBounds(0, 0, parentSize.width, split);
            parent.getComponent(1).setBounds(0, split, parentSize.width, parentSize.height - split);
        } else {
            parent.getComponent(0).setBounds(0, 0, parentSize.width, parentSize.height - split);
            parent.getComponent(1).setBounds(0, parentSize.height - split, parentSize.width, split);
        }
    }
}
package rolit.view.layout;

import java.awt.*;

/**
 * @author Pieter Bos
 *
 * Lays out all components horizontally with a given gap, aligned to the top.
 */
public class HBoxLayoutManager implements LayoutManager {
    private static final int DEFAULT_GAP = 8;

    private int gap;

    public HBoxLayoutManager(int gap) {
        this.gap = gap;
    }

    public HBoxLayoutManager() {
        this(DEFAULT_GAP);
    }

    @Override
    public void addLayoutComponent(String name, Component comp) {
    }

    @Override
    public void removeLayoutComponent(Component comp) {
    }

    @Override
    public Dimension preferredLayoutSize(Container parent) {
        int max = 0;
        int totalWidth = 0;

        for(int i = parent.getComponentCount() - 1; i >= 0; i--) {
            if(parent.getComponent(i).getMinimumSize().height > max) {
                max = parent.getComponent(i).getMinimumSize().height;
            }

            totalWidth += parent.getComponent(i).getMinimumSize().width;
        }

        return new Dimension(totalWidth + (parent.getComponentCount() - 1) * gap, max);
    }

    @Override
    public Dimension minimumLayoutSize(Container parent) {
        return preferredLayoutSize(parent);
    }

    @Override
    public void layoutContainer(Container parent) {
        int currentX = 0;

        int components = parent.getComponentCount();

        for(int i = 0; i < components; i++) {
            Component component = parent.getComponent(i);
            component.setBounds(currentX, 0, component.getPreferredSize().width, component.getPreferredSize().height);

            currentX += component.getPreferredSize().width + gap;
        }
    }
}
package rolit.view.layout;

import java.awt.*;

/**
 * @author Pieter Bos
 *
 * Always centers a single component.
 */
public class CenterLayoutManager implements LayoutManager {
    @Override
    public void addLayoutComponent(String name, Component comp) {
    }

    @Override
    public void removeLayoutComponent(Component comp) {
    }

    @Override
    public Dimension preferredLayoutSize(Container parent) {
        Component component = parent.getComponent(0);
        return component.getMinimumSize();
    }

    @Override
    public Dimension minimumLayoutSize(Container parent) {
        return preferredLayoutSize(parent);
    }

    @Override
    public void layoutContainer(Container parent) {
        Dimension parentSize = parent.getSize();
        Component component = parent.getComponent(0);
        Dimension componentSize = component.getPreferredSize();
        component.setBounds((parentSize.width - componentSize.width) / 2, (parentSize.height - componentSize.height) / 2, componentSize.width, componentSize.height);
    }
}
package rolit.view.layout;

import java.awt.*;

/**
 * @author Pieter Bos
 *
 * Stacks all components vertically with a given gap. The components are left-aligned.
 */
public class VBoxLayoutManager implements LayoutManager {
    private static final int DEFAULT_GAP = 8;

    private int gap;

    public VBoxLayoutManager(int gap) {
        this.gap = gap;
    }

    public VBoxLayoutManager() {
        this(DEFAULT_GAP);
    }

    @Override
    public void addLayoutComponent(String name, Component comp) {
    }

    @Override
    public void removeLayoutComponent(Component comp) {
    }

    @Override
    public Dimension preferredLayoutSize(Container parent) {
        int max = 0;
        int totalHeight = 0;

        for(int i = parent.getComponentCount() - 1; i >= 0; i--) {
            if(parent.getComponent(i).getMinimumSize().width > max) {
                max = parent.getComponent(i).getMinimumSize().width;
            }

            totalHeight += parent.getComponent(i).getMinimumSize().height;
        }

        return new Dimension(max, totalHeight + (parent.getComponentCount() - 1) * gap);
    }

    @Override
    public Dimension minimumLayoutSize(Container parent) {
        return preferredLayoutSize(parent);
    }

    @Override
    public void layoutContainer(Container parent) {
        int currentY = 0;

        int components = parent.getComponentCount();

        for(int i = 0; i < components; i++) {
            Component component = parent.getComponent(i);
            component.setBounds(0, currentY, component.getPreferredSize().width, component.getPreferredSize().height);

            currentY += component.getPreferredSize().height + gap;
        }
    }
}
package rolit.view.layout;

import java.awt.*;

public class HSplitLayoutManager implements LayoutManager {
    public enum HSplitType {
        Left,
        Right
    }

    private static final int DEFAULT_SPLIT = 24;
    private static final HSplitType DEFAULT_TYPE = HSplitType.Left;

    private HSplitType splitType;
    private int split;

    public HSplitLayoutManager(int split, HSplitType type) {
        this.splitType = type;
        this.split = split;
    }

    public HSplitLayoutManager(int split) {
        this(split, DEFAULT_TYPE);
    }

    public HSplitLayoutManager(HSplitType type) {
        this(DEFAULT_SPLIT, type);
    }

    public HSplitLayoutManager() {
        this(DEFAULT_TYPE);
    }

    @Override
    public void addLayoutComponent(String name, Component comp) {
    }

    @Override
    public void removeLayoutComponent(Component comp) {
    }

    @Override
    public Dimension preferredLayoutSize(Container parent) {
        return parent.getParent().getMinimumSize();
    }

    @Override
    public Dimension minimumLayoutSize(Container parent) {
        Dimension size1 = parent.getComponent(0).getMinimumSize();
        Dimension size2 = parent.getComponent(1).getMinimumSize();
        return new Dimension(size1.width + size2.width, Math.max(size1.height, size2.height));
    }

    @Override
    public void layoutContainer(Container parent) {
        Dimension parentSize = parent.getSize();
        Dimension size1 = parent.getComponent(0).getPreferredSize();
        Dimension size2 = parent.getComponent(1).getPreferredSize();

        if(splitType == HSplitType.Left) {
            parent.getComponent(0).setBounds(0, 0, split, parentSize.height);
            parent.getComponent(1).setBounds(split, 0, parentSize.width - split, parentSize.height);
        } else {
            parent.getComponent(0).setBounds(0, 0, parentSize.width - split, parentSize.height);
            parent.getComponent(1).setBounds(parentSize.width - split, 0, split, parentSize.height);
        }
    }
}
package rolit.view.layout;

import java.awt.*;

/**
 * @author Pieter Bos
 *
 * Lays out exactly two components left and right, with a given minimum gap.
 */
public class LeftRightLayoutManager implements LayoutManager {
    private static final int DEFAULT_MINIMUM_GAP = 8;

    private int minimumGap;

    public LeftRightLayoutManager(int minimumGap) {
        this.minimumGap = minimumGap;
    }

    public LeftRightLayoutManager() {
        this(DEFAULT_MINIMUM_GAP);
    }

    @Override
    public void addLayoutComponent(String name, Component comp) {
    }

    @Override
    public void removeLayoutComponent(Component comp) {
    }

    @Override
    public Dimension preferredLayoutSize(Container parent) {
        int width = Math.max(minimumLayoutSize(parent).width, parent.getParent().getPreferredSize().width);
        int height = minimumLayoutSize(parent).height;
        return new Dimension(width, height);
    }

    @Override
    public Dimension minimumLayoutSize(Container parent) {
        Dimension size1 = parent.getComponent(0).getPreferredSize();
        Dimension size2 = parent.getComponent(1).getPreferredSize();
        return new Dimension(size1.width + size2.width + minimumGap, Math.max(size1.height, size2.height));
    }

    @Override
    public void layoutContainer(Container parent) {
        int height = minimumLayoutSize(parent).height;
        Dimension size1 = parent.getComponent(0).getPreferredSize();
        Dimension size2 = parent.getComponent(1).getPreferredSize();
        parent.getComponent(0).setBounds(0, (height - size1.height) / 2, size1.width, size1.height);
        parent.getComponent(1).setBounds(parent.getSize().width - size2.width, (height - size2.height) / 2, size2.width, size2.height);
    }
}
package rolit.view.layout;

import java.awt.*;

public class GridLayoutManager implements LayoutManager {
    private static final int DEFAULT_GAP = 8;

    private int width;
    private int height;
    private int gap;

    public GridLayoutManager(int width, int height, int gap) {
        this.width = width;
        this.height = height;
        this.gap = gap;
    }

    public GridLayoutManager(int width, int height) {
        this(width, height, DEFAULT_GAP);
    }

    @Override
    public void addLayoutComponent(String name, Component comp) {
    }

    @Override
    public void removeLayoutComponent(Component comp) {
    }

    @Override
    public Dimension preferredLayoutSize(Container parent) {
        int[] x = new int[width + 1];
        int[] y = new int[height + 1];

        for(int i = 0; i < height; i++) {
            int maxHeight = 0;

            for(int j = 0; j < width; j++) {
                Dimension size = parent.getComponent(j + i * width).getPreferredSize();
                if(size.height > maxHeight) {
                    maxHeight = size.height;
                }
            }

            y[i + 1] = y[i] + maxHeight;
        }

        for(int i = 0; i < width; i++) {
            int maxWidth = 0;

            for(int j = 0; j < height; j++) {
                Dimension size = parent.getComponent(i + j * width).getPreferredSize();
                if(size.width > maxWidth) {
                    maxWidth = size.width;
                }
            }

            x[i + 1] = x[i] + maxWidth;
        }

        return new Dimension(x[width] + (width - 1) * gap, y[height] + (height - 1) * gap);
    }

    @Override
    public Dimension minimumLayoutSize(Container parent) {
        return preferredLayoutSize(parent);
    }

    @Override
    public void layoutContainer(Container parent) {
        int[] x = new int[width + 1];
        int[] y = new int[height + 1];

        for(int i = 0; i < height; i++) {
            int maxHeight = 0;

            for(int j = 0; j < width; j++) {
                Dimension size = parent.getComponent(j + i * width).getPreferredSize();
                if(size.height > maxHeight) {
                    maxHeight = size.height;
                }
            }

            y[i + 1] = y[i] + maxHeight + gap;
        }

        for(int i = 0; i < width; i++) {
            int maxWidth = 0;

            for(int j = 0; j < height; j++) {
                Dimension size = parent.getComponent(i + j * width).getPreferredSize();
                if(size.width > maxWidth) {
                    maxWidth = size.width;
                }
            }

            x[i + 1] = x[i] + maxWidth + gap;
        }

        for(int i = 0; i < width; i++) {
            for(int j = 0; j < height; j++) {
                parent.getComponent(i + j * width).setBounds(x[i], y[j], x[i + 1] - x[i] - gap, y[j + 1] - y[j] - gap);
            }
        }
    }
}
package rolit.view.client;

import rolit.view.layout.VSplitLayoutManager;

import javax.swing.*;

public class ChatPanel extends JPanel {
    private final ChatController controller;
    private JTextArea textArea;
    private JTextField textField;

    public class ChatController {
        private ChatPanel panel;
        private MainView.MainController controller;

        public ChatController(ChatPanel panel, MainView.MainController controller) {
            this.panel = panel;
            this.controller = controller;
        }

        public void initialize() {

        }

        public void message(String user, String message) {
            panel.getTextArea().setText(getTextArea().getText() + "\n" + user + ": " + message);
        }
    }

    public ChatPanel(MainView.MainController controller) {
        this.controller = new ChatController(this, controller);
        setLayout(new VSplitLayoutManager(VSplitLayoutManager.VSplitType.Bottom));

        textArea = new JTextArea();
        textField = new JTextField();

        add(textArea);
        add(textField);
    }

    public JTextArea getTextArea() {
        return textArea;
    }

    public JTextField getTextField() {
        return textField;
    }

    public ChatPanel.ChatController getController() {
        return controller;
    }
}
package rolit.view.client;

import rolit.model.networking.client.ClientGame;
import rolit.view.layout.*;

import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.security.Signature;
import java.util.Collection;

public class GameListPanel extends JPanel {
    private final JPanel listPanel;
    private final ChatPanel chatPanel;
    private final JButton createGameButton;
    private final JButton challengeButton;
    private final ServerPanel serverPanel;
    private GameListController controller;

    public JButton getCreateGameButton() {
        return createGameButton;
    }

    public JButton getChallengeButton() {
        return challengeButton;
    }

    public class GameListController implements ActionListener {
        private GameListPanel panel;
        private MainView.MainController controller;

        public GameListController(GameListPanel panel, MainView.MainController controller) {
            this.panel = panel;
            this.controller = controller;
        }

        public void initialize() {
            panel.getChallengeButton().addActionListener(this);
            panel.getCreateGameButton().addActionListener(this);
        }

        public void update(Collection<ClientGame> values) {
            JPanel panel = this.panel.getListPanel();
            panel.removeAll();
            panel.setLayout(null);

            panel.add(new JLabel("Spelmaker"));
            panel.add(new JLabel("Aantal spelers"));
            panel.add(Box.createGlue());

            for(ClientGame game : values) {
                panel.add(new JLabel(game.getCreator()));
                panel.add(new JLabel(game.getPlayers() + ""));

                JButton joinButton = new JButton("Meedoen");
                joinButton.setActionCommand(game.getCreator());

                if(game.getPlayers() >= 4) {
                    joinButton.setEnabled(false);
                }

                joinButton.addActionListener(this);

                panel.add(joinButton);
            }

            panel.setLayout(new GridLayoutManager(3, values.size() + 1, 8));
            panel.revalidate();
        }

        @Override
        public void actionPerformed(ActionEvent e) {
            if(e.getActionCommand().equals("  createGame")) {
                controller.doCreateGame();
            } else if(e.getActionCommand().equals("  challenge")) {
                // TODO implement
            } else {
                controller.doJoinGame(e.getActionCommand());
            }
        }

        public void enable() {
            panel.getServerPanel().getController().enable();
            panel.getCreateGameButton().setEnabled(true);
            panel.getChallengeButton().setEnabled(true);
            this.update(controller.getGames());
        }

        public void disable() {
            panel.getServerPanel().getController().disable();
            panel.getCreateGameButton().setEnabled(false);
            panel.getChallengeButton().setEnabled(false);

            for(Component component : panel.getListPanel().getComponents()) {
                if(component instanceof JButton) {
                    ((JButton) component).setEnabled(false);
                }
            }
        }
    }

    public GameListPanel(MainView.MainController controller) {
        this.controller = new GameListController(this, controller);
        setLayout(new VSplitLayoutManager(VSplitLayoutManager.VSplitType.Top));

        JPanel mainPanel = new JPanel();
        mainPanel.setLayout(new HSplitLayoutManager(200, HSplitLayoutManager.HSplitType.Right));

        JPanel gamesPanel = new JPanel();
        gamesPanel.setLayout(new VSplitLayoutManager(VSplitLayoutManager.VSplitType.Bottom));

        listPanel = new JPanel();
        listPanel.setLayout(new VBoxLayoutManager());

        listPanel.add(new JLabel("Nog geen spellen..."));

        JPanel buttonsArrayPanel = new JPanel();
        buttonsArrayPanel.setLayout(new HBoxLayoutManager());

        createGameButton = new JButton("Maak spel");
        createGameButton.setActionCommand("  createGame");
        challengeButton = new JButton("Daag een speler uit");
        challengeButton.setActionCommand("  challenge");

        buttonsArrayPanel.add(createGameButton);
        buttonsArrayPanel.add(challengeButton);

        gamesPanel.add(listPanel);
        gamesPanel.add(buttonsArrayPanel);

        mainPanel.add(gamesPanel);
        chatPanel = new ChatPanel(controller);
        mainPanel.add(chatPanel);

        serverPanel = new ServerPanel(controller);
        add(serverPanel);
        add(mainPanel);

        this.controller.initialize();
    }

    public ServerPanel getServerPanel() {
        return serverPanel;
    }

    public ChatPanel getChatPanel() {
        return chatPanel;
    }

    public JPanel getListPanel() {
        return listPanel;
    }

    public GameListController getController() {
        return controller;
    }
}
package rolit.view.client;

import rolit.model.networking.client.ServerHandler;
import rolit.view.client.action.Action;

public class JoinGameAction extends Action {
    private ServerHandler currentServer;
    private String creator;

    public JoinGameAction(MainView.MainController mainController, ServerHandler currentServer, String creator) {
        super(mainController);
        this.currentServer = currentServer;
        this.creator = creator;
    }

    public String getCreator() {
        return creator;
    }

    @Override
    public boolean doAction() throws Throwable {
        currentServer.joinGame(creator);
        return true;
    }
}
package rolit.view.client;

import rolit.view.layout.CenterLayoutManager;
import rolit.view.layout.LeftRightLayoutManager;
import rolit.view.layout.VBoxLayoutManager;

import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;

/**
 * @author Pieter Bos
 *
 * Panel to connect to a server.
 */
public class ConnectPanel extends JPanel {
    private static final int DEFAULT_TEXT_FIELD_WIDTH = 200;
    private static final int DEFAULT_TEXT_FIELD_HEIGHT = 24;
    private final ConnectPanelController controller;

    private JTextField hostname;
    private JTextField userName;
    private JPasswordField password;
    private JButton loginButton;

    public class ConnectPanelController implements ActionListener, KeyListener {
        private final ConnectPanel panel;
        private final MainView.MainController mainController;

        public ConnectPanelController(ConnectPanel panel, MainView.MainController mainController) {
            this.panel = panel;
            this.mainController = mainController;
        }

        public void initialize() {
            panel.getLoginButton().addActionListener(this);
            panel.getUserNameTextField().addActionListener(this);
            panel.getUserNameTextField().addKeyListener(this);
        }

        @Override
        public void actionPerformed(ActionEvent e) {
            if(e.getSource() == panel.getLoginButton()) {
                mainController.doConnect(panel.getHostnameTextField().getText(), panel.getUserNameTextField().getText(),
                        new String(panel.getPasswordField().getPassword()));
            }
        }

        public void disable() {
            panel.getLoginButton().setEnabled(false);
        }

        public void enable() {
            panel.getLoginButton().setEnabled(true);
        }

        @Override
        public void keyTyped(KeyEvent e) {
            if(e.getSource() == panel.getUserNameTextField()) {
                if(panel.getUserNameTextField().getText().startsWith("player_")) {
                    panel.getPasswordField().setEnabled(true);
                } else {
                    panel.getPasswordField().setEnabled(false);
                }
            }
        }

        @Override
        public void keyPressed(KeyEvent e) {  }

        @Override
        public void keyReleased(KeyEvent e) {  }
    }

    public JPasswordField getPasswordField() {
        return password;
    }

    public ConnectPanel(MainView.MainController mainController) {
        this.controller = new ConnectPanelController(this, mainController);

        setLayout(new CenterLayoutManager());

        JPanel panel = new JPanel();
        panel.setLayout(new VBoxLayoutManager());

        JLabel logInLabel = new JLabel("Verbinden met server");
        panel.add(logInLabel);

        JPanel panel1 = new JPanel();
        panel1.setLayout(new LeftRightLayoutManager());

        JLabel hostnameLabel = new JLabel("Hostname:poort");
        hostname = new JTextField();
        hostname.setPreferredSize(new Dimension(DEFAULT_TEXT_FIELD_WIDTH, DEFAULT_TEXT_FIELD_HEIGHT));
        panel1.add(hostnameLabel);
        panel1.add(hostname);
        panel.add(panel1);

        JPanel panel2 = new JPanel();
        panel2.setLayout(new LeftRightLayoutManager());

        JLabel userNameLabel = new JLabel("Gebruikersnaam");
        userName = new JTextField();
        userName.setPreferredSize(new Dimension(DEFAULT_TEXT_FIELD_WIDTH, DEFAULT_TEXT_FIELD_HEIGHT));
        panel2.add(userNameLabel);
        panel2.add(userName);
        panel.add(panel2);

        JPanel panel3 = new JPanel();
        panel3.setLayout(new LeftRightLayoutManager());

        JLabel passwordLabel = new JLabel("Wachtwoord");
        password = new JPasswordField();
        password.setPreferredSize(new Dimension(DEFAULT_TEXT_FIELD_WIDTH, DEFAULT_TEXT_FIELD_HEIGHT));
        password.setEnabled(false);
        panel3.add(passwordLabel);
        panel3.add(password);
        panel.add(panel3);

        JPanel panel4 = new JPanel();
        panel4.setLayout(new LeftRightLayoutManager());

        loginButton = new JButton("Inloggen");
        panel4.add(Box.createGlue());
        panel4.add(loginButton);
        panel.add(panel4);

        add(panel);

        controller.initialize();
    }

    public ConnectPanelController getController() {
        return controller;
    }

    public JTextField getHostnameTextField() {
        return hostname;
    }

    public JTextField getUserNameTextField() {
        return userName;
    }

    public JButton getLoginButton() {
        return loginButton;
    }
}
package rolit.view.client.action;

import rolit.view.client.MainView;

public abstract class Action extends Thread {
    private final MainView.MainController controller;

    public Action(MainView.MainController controller) {
        this.controller = controller;
    }

    public abstract boolean doAction() throws Throwable;

    @Override
    public void run() {
        try {
            if(doAction()) {
                controller.actionSucceeded();
            } else {
                controller.actionFailed();
            }
        } catch (Throwable throwable) {
            // Een actie móet altijd falen of goed gaan.
            controller.actionFailed();
        }
    }
}
package rolit.view.client.action;

import rolit.model.networking.client.ServerHandler;
import rolit.view.client.MainView;

public class CreateGameAction extends Action {
    private ServerHandler server;

    public CreateGameAction(MainView.MainController controller, ServerHandler server) {
        super(controller);
        this.server = server;
    }

    @Override
    public boolean doAction() {
        server.createGame();
        return true;
    }
}
package rolit.view.client.action;

import rolit.model.networking.client.AuthPacket;
import rolit.model.networking.client.ServerHandler;
import rolit.model.networking.common.CommonProtocol;
import rolit.model.networking.common.PacketInputStream;
import rolit.model.networking.common.ProtocolException;
import rolit.model.networking.server.AuthOkPacket;
import rolit.model.networking.server.HandshakePacket;
import rolit.model.networking.sssecurity.SSSecurity;
import rolit.util.Crypto;
import rolit.view.client.MainView;

import javax.swing.*;
import java.io.IOException;
import java.security.PrivateKey;

public class ConnectAction extends Action {
    private String password;
    private String hostnamePort;
    private String userName;
    private ServerHandler handler;
    private PacketInputStream eventStream;
    private String error;

    public ConnectAction(String hostnamePort, String userName, String password, MainView.MainController controller) {
        super(controller);
        this.hostnamePort = hostnamePort;
        this.userName = userName;
        this.password = password;
    }

    public String getHostnamePort() {
        return hostnamePort;
    }

    public String getUserName() {
        return userName;
    }

    public ServerHandler getServerHandler() {
        return handler;
    }

    public PacketInputStream getEventStream() {
        return eventStream;
    }

    @Override
    public boolean doAction() throws IOException, ProtocolException {
        if(!hostnamePort.contains(":")) return false;

        String hostname = hostnamePort.split(":")[0];
        int port = Integer.parseInt(hostnamePort.split(":")[1]);

        handler = new ServerHandler(hostname, port);

        eventStream = handler.createPacketInputStream();

        handler.start();

        handler.handshake(userName);
        HandshakePacket packet = handler.expectPacket(HandshakePacket.class);

        if(userName.startsWith("player_")) {
            String nonce = packet.getNonce();
            PrivateKey key = SSSecurity.getPrivateKey(userName, password);

            if(key == null) {
                error = "incorrect wachtwoord of gebruikersnaam";
                return false;
            }

            String sign = Crypto.base64Encode(Crypto.sign(Crypto.base64Decode(nonce), key));
            handler.auth(sign);
            handler.expectPacket(AuthOkPacket.class);
        }

        return true;
    }

    public String getError() {
        return error;
    }
}
package rolit.view.client;

import rolit.view.layout.HBoxLayoutManager;
import rolit.view.layout.LeftRightLayoutManager;

import javax.swing.*;

public class ServerPanel extends JPanel {
    private final ServerController controller;
    JLabel serverConnectionLabel;
    JLabel userNameLabel;
    JButton logoutButton;

    public class ServerController {
        private ServerPanel panel;
        private MainView.MainController controller;

        public ServerController(ServerPanel panel, MainView.MainController controller) {
            this.panel = panel;
            this.controller = controller;
        }

        public void initialize() {

        }

        public void update() {
            panel.getServerConnectionLabel().setText("Verbonden met " + controller.getCurrentServer().getHostName());
            panel.getUserNameLabel().setText("Ingelogd als " + controller.getCurrentUser());
        }

        public void enable() {
            panel.getLogoutButton().setEnabled(true);
        }

        public void disable() {
            panel.getLogoutButton().setEnabled(false);
        }
    }

    public ServerPanel(MainView.MainController controller) {
        this.controller = new ServerController(this, controller);
        setLayout(new LeftRightLayoutManager());

        serverConnectionLabel = new JLabel("Verbonden met ");
        add(serverConnectionLabel);

        JPanel rightPanel = new JPanel();
        rightPanel.setLayout(new HBoxLayoutManager());

        userNameLabel = new JLabel("Ingelogd als ");
        logoutButton = new JButton("Uitloggen");

        rightPanel.add(userNameLabel);
        rightPanel.add(logoutButton);

        add(rightPanel);
        this.controller.initialize();
    }

    public JLabel getServerConnectionLabel() {
        return serverConnectionLabel;
    }

    public JLabel getUserNameLabel() {
        return userNameLabel;
    }

    public JButton getLogoutButton() {
        return logoutButton;
    }

    public ServerController getController() {
        return controller;
    }
}
package rolit.view.client;

import rolit.model.networking.client.ClientGame;
import rolit.model.networking.client.ServerHandler;
import rolit.model.networking.server.*;
import rolit.view.client.action.ConnectAction;
import rolit.view.client.action.Action;
import rolit.view.client.action.CreateGameAction;

import javax.swing.*;
import java.awt.*;
import java.lang.reflect.InvocationTargetException;
import java.util.Collection;
import java.util.HashMap;
import java.util.LinkedList;

public class MainView extends JFrame {
    private final MainController controller;

    /**
     * Zorgt er voor dat de view de goede panel laat zien en dat de juiste acties op de achtergrond gebeuren.
     */
    public class MainController {
        private final MainView view;

        private final ConnectPanel connectPanel;
        private final GameListPanel gameListPanel;
        private final WaitPanel waitPanel;

        private Action currentAction;
        private ServerHandler currentServer = null;
        private String currentGame = null;

        private ChatPanel currentChatPanel = null;

        private HashMap<String, ClientGame> games = new HashMap<String, ClientGame>();
        private String currentUser;

        public void gameUpdate(GamePacket packet) {
            if(games.get(packet.getGame()) == null && packet.getStatus() == 0) {
                games.put(packet.getGame(), new ClientGame(packet.getGame(), packet.getPlayers()));
            } else if(games.get(packet.getGame()) != null && packet.getStatus() != 0) {
                games.remove(packet.getGame());
            } else if(games.get(packet.getGame()) != null) {
                games.get(packet.getGame()).setPlayers(packet.getPlayers());
            }

            SwingUtilities.invokeLater(new Runnable() {
                @Override
                public void run() {
                    gameListPanel.getController().update(games.values());
                    waitPanel.getController().update(games.values());
                    view.revalidate();
                }
            });
        }

        public void message(MessagePacket packet) {
            currentChatPanel.getController().message(packet.getUser(), packet.getMessage());
        }

        public void challenge(ChallengePacket packet) {
            // TODO implement
        }

        public void online(OnlinePacket packet) {
            // TODO add UI and implement
        }

        public void canBeChallenged(CanBeChallengedPacket packet) {
            // TODO implement
        }

        public ServerHandler getCurrentServer() {
            return currentServer;
        }

        public String getCurrentGame() {
            return currentGame;
        }

        public String getCurrentUser() {
            return currentUser;
        }

        public void doCreateGame() {
            gameListPanel.getController().disable();
            doAction(new CreateGameAction(this, currentServer));
        }

        public void doJoinGame(String creator) {
            gameListPanel.getController().disable();
            doAction(new JoinGameAction(this, currentServer, creator));
        }

        public ClientGame getGame(String currentGame) {
            return games.get(currentGame);
        }

        public void abortGame() {
            error("De server heeft het spel voortijdig gestopt.");
            switchTo(gameListPanel);
        }

        private class SwitchRunnable implements Runnable {
            private MainView view;
            private JPanel switchTo;

            public SwitchRunnable(MainView view, JPanel switchTo) {
                this.view = view;
                this.switchTo = switchTo;
            }

            @Override
            public void run() {
                view.getContentPane().remove(0);
                view.getContentPane().add(switchTo);
                view.getContentPane().revalidate();
            }
        }

        public Collection<ClientGame> getGames() {
            return games.values();
        }

        public MainController(MainView view) {
            this.view = view;
            this.connectPanel = new ConnectPanel(this);
            this.gameListPanel = new GameListPanel(this);
            this.waitPanel = new WaitPanel(this);
        }

        public void initialize() {
            getContentPane().add(connectPanel);
            view.setVisible(true);
        }

        /**
         * such abstraction
         * much enterprise
         * wow
         * @param action de actie die op de achtergrond moet worden uitgevoerd.
         */
        private void doAction(Action action) {
            currentAction = action;
            currentAction.start();
        }

        public void doConnect(String hostnamePort, String userName, String password) {
            connectPanel.getController().disable();
            doAction(new ConnectAction(hostnamePort, userName, password, this));
        }

        public synchronized void actionSucceeded() {
            if(currentAction instanceof ConnectAction) {
                ConnectAction action = (ConnectAction) currentAction;
                currentServer = action.getServerHandler();
                currentUser = action.getUserName();

                currentChatPanel = gameListPanel.getChatPanel();
                switchTo(gameListPanel);
                connectPanel.getController().enable();
                new EventThread(this, action.getEventStream()).start();
            } else if(currentAction instanceof CreateGameAction) {
                currentGame = getCurrentUser();

                switchTo(waitPanel);
                gameListPanel.getController().enable();
            } else if(currentAction instanceof JoinGameAction) {
                currentGame = ((JoinGameAction) currentAction).getCreator();

                switchTo(waitPanel);
                gameListPanel.getController().enable();
            }

            currentAction = null;
        }

        private void switchTo(JPanel panel) {
            System.out.println(Thread.currentThread().getName());
            System.out.flush();
            SwingUtilities.invokeLater(new SwitchRunnable(view, panel));
            System.out.println();
        }

        public synchronized void actionFailed() {
            if(currentAction instanceof ConnectAction) {
                ConnectAction action = (ConnectAction) currentAction;

                if(action.getError() != null) {
                    error("Kon niet verbinden met " + action.getHostnamePort() + ": " + action.getError());
                } else {
                    error("Kon niet verbinden met " + action.getHostnamePort());
                }

                connectPanel.getController().enable();
            } else if(currentAction instanceof CreateGameAction) {
                error("Kon geen spel maken");

                gameListPanel.getController().enable();
            }

            currentAction = null;
        }
    }

    public MainView() {
        this.controller = new MainController(this);

        setSize(640, 480);
        setMinimumSize(new Dimension(640, 480));
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

        controller.initialize();
    }

    public static void error(String message) {
        JOptionPane.showMessageDialog(null, message);
    }
}
package rolit.view.client;

import rolit.model.networking.common.Packet;
import rolit.model.networking.common.PacketInputStream;
import rolit.model.networking.common.ProtocolException;
import rolit.model.networking.server.*;
import rolit.util.Arrays;

import java.io.IOException;

public class EventThread extends Thread {
    private final PacketInputStream stream;
    private final MainView.MainController controller;
    private final Class[] EVENT_PACKET_TYPES = {
            GamePacket.class,
            MessagePacket.class,
            ChallengePacket.class,
            OnlinePacket.class,
            CanBeChallengedPacket.class
    };

    public EventThread(MainView.MainController controller, PacketInputStream stream) {
        this.stream = stream;
        this.controller = controller;
    }

    @Override
    public void run() {
        try {
            while(true) {
                Packet packet = stream.readPacket();

                if(Arrays.contains(EVENT_PACKET_TYPES, packet.getClass())) {
                    if(packet instanceof GamePacket) {
                        controller.gameUpdate((GamePacket) packet);
                    } else if(packet instanceof MessagePacket) {
                        controller.message((MessagePacket) packet);
                    } else if(packet instanceof ChallengePacket) {
                        controller.challenge((ChallengePacket) packet);
                    } else if(packet instanceof OnlinePacket) {
                        controller.online((OnlinePacket) packet);
                    } else if(packet instanceof CanBeChallengedPacket) {
                        controller.canBeChallenged((CanBeChallengedPacket) packet);
                    }
                }
            }
        } catch (ProtocolException e) {

        } catch (IOException e) {

        }
    }
}
package rolit.view.client;

import rolit.view.layout.CenterLayoutManager;
import rolit.view.layout.GridLayoutManager;
import rolit.view.layout.HBoxLayoutManager;
import rolit.view.layout.VBoxLayoutManager;

import javax.swing.*;
import java.awt.*;

public class ChallengePanel extends JPanel {
    public ChallengePanel() {
        setLayout(new CenterLayoutManager());
        setSize(new Dimension(300, 1));

        JPanel mainPanel = new JPanel();
        mainPanel.setLayout(new VBoxLayoutManager());

        JLabel challengeLabel = new JLabel("Daag mensen uit:");

        JPanel challengePanel = new JPanel();
        challengePanel.setLayout(new HBoxLayoutManager());

        JComboBox players = new JComboBox<String>();
        players.addItem("Pieter");
        players.addItem("Martijn");

        JButton challengeButton = new JButton("Uitdagen");

        challengePanel.add(players);
        challengePanel.add(challengeButton);

        JLabel challengedPeople = new JLabel("Uitgedaagde mensen:");

        JPanel challengedPanel = new JPanel();
        challengedPanel.setLayout(new GridLayoutManager(2, 2));
        challengedPanel.add(new JLabel("Laurens"));
        challengedPanel.add(new JButton("Verwijder"));
        challengedPanel.add(new JLabel("Sophie"));
        challengedPanel.add(new JButton("Verwijder"));

        mainPanel.add(challengeLabel);
        mainPanel.add(challengePanel);
        mainPanel.add(Box.createGlue());
        mainPanel.add(challengedPeople);
        mainPanel.add(challengedPanel);

        add(mainPanel);
    }

    public static void main(String[] args) throws ClassNotFoundException, UnsupportedLookAndFeelException, InstantiationException, IllegalAccessException {
        UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
        JFrame frame = new JFrame();
        frame.getContentPane().add(new ChallengePanel());
        frame.setSize(640, 480);
        frame.setMinimumSize(new Dimension(640, 480));
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.setVisible(true);
    }
}
package rolit.view.client;

import rolit.model.networking.client.ClientGame;
import rolit.view.layout.HSplitLayoutManager;
import rolit.view.layout.VSplitLayoutManager;

import javax.swing.*;
import java.awt.*;
import java.util.Collection;

public class WaitPanel extends JPanel {
    private final JLabel status;
    private final JButton actionButton;
    private final WaitController controller;
    private final ServerPanel serverPanel;
    private final JLabel creator;

    public WaitController getController() {
        return controller;
    }

    public JLabel getCreator() {
        return creator;
    }

    public class WaitController {
        private WaitPanel panel;
        private MainView.MainController controller;

        public WaitController(WaitPanel panel, MainView.MainController controller) {
            this.panel = panel;
            this.controller = controller;
        }

        public void update(Collection<ClientGame> games) {
            if(controller.getCurrentGame() != null) {
                ClientGame game = controller.getGame(controller.getCurrentGame());

                if(game == null) {
                    controller.abortGame();
                } else {
                    creator.setText("Het spel van " + game.getCreator() + " is nog niet begonnen.");
                    status.setText("Er zitten nu " + game.getPlayers() + " mensen in het spel.");
                }
            }
        }

        public void initialize() {

        }
    }

    public WaitPanel(MainView.MainController controller) {
        this.controller = new WaitController(this, controller);
        setLayout(new VSplitLayoutManager(VSplitLayoutManager.VSplitType.Top));

        JPanel mainPanel = new JPanel();
        mainPanel.setLayout(new HSplitLayoutManager(200, HSplitLayoutManager.HSplitType.Right));

        JPanel startPanel = new JPanel();

        creator = new JLabel("Het spel van  is nog niet begonnen");
        status = new JLabel("Er zitten nu  mensen in het spel.");
        actionButton = new JButton("Beginnen");
        actionButton.setEnabled(false);

        startPanel.add(creator);
        startPanel.add(status);
        startPanel.add(actionButton);

        mainPanel.add(startPanel);
        mainPanel.add(new ChatPanel(controller));

        serverPanel = new ServerPanel(controller);
        add(serverPanel);
        add(mainPanel);
        this.controller.initialize();
    }

    public ServerPanel getServerPanel() {
        return serverPanel;
    }

    public JLabel getStatus() {
        return status;
    }

    public JButton getActionButton() {
        return actionButton;
    }
}
package rolit.view.client;

import rolit.view.layout.GridLayoutManager;
import rolit.view.layout.HSplitLayoutManager;
import rolit.view.layout.VSplitLayoutManager;

import javax.swing.*;
import java.awt.*;

public class GamePanel extends JPanel {
    public GamePanel(MainView.MainController controller) {
        setLayout(new VSplitLayoutManager(VSplitLayoutManager.VSplitType.Top));

        JPanel mainPanel = new JPanel();
        mainPanel.setLayout(new HSplitLayoutManager(200, HSplitLayoutManager.HSplitType.Right));

        JPanel gamePanel = new JPanel();
        gamePanel.setLayout(new GridLayout(8, 8));

        JButton[][] buttons = new JButton[8][8];

        for(int y = 0; y < 8; y++) {
            for(int x = 0; x < 8; x++) {
                buttons[x][y] = new JButton("(" + x + "; " + y + ")");
                gamePanel.add(buttons[x][y]);
            }
        }

        JPanel sideBarPanel = new JPanel();
        sideBarPanel.setLayout(new VSplitLayoutManager(100, VSplitLayoutManager.VSplitType.Top));

        JPanel scorePanel = new JPanel();
        scorePanel.setLayout(new GridLayoutManager(2, 4));

        scorePanel.add(new JLabel("Pieter"));
        scorePanel.add(new JLabel("0"));
        scorePanel.add(new JLabel("Martijn"));
        scorePanel.add(new JLabel("0"));
        scorePanel.add(new JLabel("Laurens"));
        scorePanel.add(new JLabel("0"));
        scorePanel.add(new JLabel("Sophie"));
        scorePanel.add(new JLabel("0"));

        sideBarPanel.add(scorePanel);
        sideBarPanel.add(new ChatPanel(controller));

        mainPanel.add(gamePanel);
        mainPanel.add(sideBarPanel);

        add(new ServerPanel(controller));
        add(mainPanel);
    }
}
package rolit.view.client;

import javax.swing.*;

public class Program {
    public static void main(String[] args) throws ClassNotFoundException, UnsupportedLookAndFeelException, InstantiationException, IllegalAccessException {
        UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());

        SwingUtilities.invokeLater(new Runnable() {
            @Override
            public void run() {
                new MainView();
            }
        });
    }
}
package rolit.model.networking.sssecurity;

import rolit.util.Crypto;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintStream;
import java.net.InetAddress;
import java.net.Socket;
import java.security.KeyFactory;
import java.security.NoSuchAlgorithmException;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.interfaces.RSAPublicKey;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.PKCS8EncodedKeySpec;
import java.security.spec.RSAPublicKeySpec;
import java.security.spec.X509EncodedKeySpec;

public class SSSecurity {
    private static final int SS_SECURITY_PORT = 2013;
    private static final String SS_SECURITY_HOST = "ss-security.student.utwente.nl";

    private static String get(String command) throws IOException {
        Socket socket = new Socket(SS_SECURITY_HOST, SS_SECURITY_PORT);
        new PrintStream(socket.getOutputStream()).println(command);
        return new BufferedReader(new InputStreamReader(socket.getInputStream())).readLine();
    }

    /**
     * Vraagt een publickey van een bepaalde speler op bij de server.
     * @param user de speler waarvan de publickey opgevraagt moet worden.
     * @return een publickey
     */
    public static PublicKey getPublicKey(String user) {
        try {
            byte[] data = Crypto.base64Decode(get("PUBLICKEY " + user).split(" ")[1]);
            X509EncodedKeySpec keySpec = new X509EncodedKeySpec(data);
            KeyFactory fact = KeyFactory.getInstance("RSA");
            return fact.generatePublic(keySpec);
        } catch (InvalidKeySpecException e) {

        } catch (NoSuchAlgorithmException e) {

        } catch (IOException e) {

        }

        return null;
    }

    public static PrivateKey getPrivateKey(String user, String password) {
        try {
            byte[] data = Crypto.base64Decode(get("IDPLAYER " + user + " " + password).split(" ")[1]);
            PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(data);
            KeyFactory fact = KeyFactory.getInstance("RSA");
            return fact.generatePrivate(keySpec);
        } catch (IOException e) {

        } catch (NoSuchAlgorithmException e) {

        } catch (InvalidKeySpecException e) {

        }

        return null;
    }

    public static void main(String[] args) {
        System.out.println(SSSecurity.getPublicKey("player_trollit"));
    }
}
package rolit.model.networking.common;

import java.io.IOException;
import java.util.LinkedList;
import java.util.Queue;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;

public class PacketInputStream {
    private ReentrantLock lock = new ReentrantLock();
    private Condition queueNotEmpty = lock.newCondition();
    private Queue<Object> queue = new LinkedList<Object>();

    public Packet readPacket() throws ProtocolException, IOException {
        lock.lock();

        Object result = null;

        try {
            while(queue.size() == 0) {
                queueNotEmpty.await();
            }

            result = queue.poll();
        } catch (InterruptedException e) {

        } finally {
            lock.unlock();
        }

        if(result instanceof Packet) {
            return (Packet) result;
        } else if(result instanceof ProtocolException) {
            ProtocolException e = (ProtocolException) result;
            throw new ProtocolException(e.getMessage(), e.getCode());
        } else {
            throw (IOException) result;
        }
    }

    private void add(Object object) {
        lock.lock();

        try {
            queue.add(object);
            queueNotEmpty.signal();
        } finally {
            lock.unlock();
        }
    }

    public void notifyOfPacket(Packet packet) {
        add(packet);
    }

    public void notifyOfProtocolException(ProtocolException e) {
        add(e);
    }

    public void notifyOfIOException(IOException e) {
        add(e);
    }
}
package rolit.model.networking.common;

import java.io.*;
import java.security.*;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.PKCS8EncodedKeySpec;
import java.security.spec.X509EncodedKeySpec;
import java.util.Arrays;

/**
 * Het deel van het protocol dat de server en de client delen.
 * @author Pieter Bos
 * @author Martijn de Bijl
 *
 *
 */
public class CommonProtocol {
    /**
     * Constante om aan te geven dat de client of server alleen de basisdingen kan doen.
     */
    public static final int SUPPORTS_BAREBONE = 0;

    /**
     * Constante om aan te geven dat de client of server ook kan chatten.
     */
    public static final int SUPPORTS_CHAT = 1;

    /**
     * Constante om aan te geven dat de client of server ook kan uitdagen / uitgedaagd worden.
     */
    public static final int SUPPORTS_CHALLENGE = 2;

    /**
     * SUPPORTS_CHAT | SUPPORTS_CHALLENGE
     */
    public static final int SUPPORTS_CHAT_CHALLENGE = 3;

    /**
     * String-waarde voor true in het protocol
     */
    public static final String T_BOOLEAN_TRUE = "true";

    /**
     * String-waarde voor false in het protocol
     */
    public static final String T_BOOLEAN_FALSE = "false";

    /**
     * Versie in de handshake voor een standaardimplementatie
     */
    public static final String VERSION_NONE = "Standaard";

    /**
     * Minimum aantal spelers om een spel te laten beginnen
     */
    public static final int MINIMUM_PLAYER_COUNT = 2;

    /**
     * Maximum aantal spelers om een spel te kunnen laten beginnen
      */
    public static final int MAXIMUM_PLAYER_COUNT = 4;

    /**
     * Einde van regels
     */
    public static final String LINE_ENDING = "\r\n";

    /**
     * Delimiter van commando's
     */
    public static final String COMMAND_DELIMITER = " ";

    /**
     * Alle characters van base64 in volgorde.
     */
    private static final String BASE64_CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

    private static final char BASE64_PADDING = '=';

    /**
     * Methode om van een {@code OutputStream} een correcte {@code PrintStream} te maken.
     * @param output De {@code OutputStream}
     * @return de {@code PrintStream}
     */
    public PrintStream getPrintStream(OutputStream output) {
        try {
            return new PrintStream(output, true, "UTF-8");
        } catch (UnsupportedEncodingException e) {
            return null;
        }
    }

    /**
     * Methode om van een {@code InputStream} een correcte {@code BufferedReader} te maken.
     * @param input De {@code InputStream}
     * @return De {@code BufferedReader}
     */
    public BufferedReader getBufferedReader(InputStream input) {
        try {
            return new BufferedReader(new InputStreamReader(input, "UTF-8"));
        } catch (UnsupportedEncodingException e) {
            return null;
        }
    }

    /**
     * Methode om een commando naar een {@code PrintStream} te schrijven.
     * @param commandParts De gedeeltes van het commando.
     * @param output De {@code PrintStream}
     */
    public void writeCommandTo(String[] commandParts, PrintStream output) {
        boolean first = true;
        String command = "";

        for(String argument : commandParts) {
            if(!first) {
                command += " ";
            }

            first = false;

            command += argument;
        }

        output.print(command);
        output.print("\r\n");
    }

    /**
     * Methode om een commando van een {@code BufferedReader} te lezen.
     * @param input De {@code BufferedReader}
     * @return De array van {@code String}s
     * @throws IOException
     */
    public String[] readCommandFrom(BufferedReader input) throws IOException {
        String line = input.readLine();

        return line.split(" ");
    }

    /**
     * Converteert bytes naar een Base64-String. Er is namelijk geen standaardmethode in Java om dit te doen.
     * @param data De bytes
     * @return De String
     */
    public static String base64Encode(byte[] data) {
        String result = "";

        for(int i = 0; i < data.length / 3; i++) {
            int byte1 = (data[i * 3] + 256) % 256,
                    byte2 = (data[i * 3 + 1] + 256) % 256,
                    byte3 = (data[i * 3 + 2] + 256) % 256;

            result += BASE64_CHARS.charAt(byte1 / 4);
            result += BASE64_CHARS.charAt((byte1 % 4) * 16 + byte2 / 16);
            result += BASE64_CHARS.charAt((byte2 % 16) * 4 + byte3 / 64);
            result += BASE64_CHARS.charAt(byte3 % 64);
        }

        if(data.length % 3 == 1) {
            byte byte1 = data[data.length - 1];

            result += BASE64_CHARS.charAt(byte1 / 4);
            result += BASE64_CHARS.charAt((byte1 % 4) * 16);
            result += BASE64_PADDING;
            result += BASE64_PADDING;
        } else if(data.length % 3 == 2) {
            byte byte1 = data[data.length - 2], byte2 = data[data.length - 1];

            result += BASE64_CHARS.charAt(byte1 / 4);
            result += BASE64_CHARS.charAt((byte1 % 4) * 16 + byte2 / 16);
            result += BASE64_CHARS.charAt((byte2 % 16) * 4);
            result += BASE64_PADDING;
        }

        return result;
    }

    /**
     * Converteert een Bas64-String naar bytes.
     * @param data De String
     * @return De bytes
     */
    public static byte[] base64Decode(String data) {
        byte[] result = new byte[data.length() / 4 * 3];

        for(int i = 0; i < data.length() / 4; i++) {
            char char1 = data.charAt(i * 4), char2 = data.charAt(i * 4 + 1),
                    char3 = data.charAt(i * 4 + 2), char4 = data.charAt(i * 4 + 3);

            int result1 = BASE64_CHARS.indexOf(char1) * 4 + BASE64_CHARS.indexOf(char2) / 16;
            int result2 = (BASE64_CHARS.indexOf(char2) % 16) * 16 + BASE64_CHARS.indexOf(char3) / 4;
            int result3 = ((BASE64_CHARS.indexOf(char3) + 4) % 4) * 64 + BASE64_CHARS.indexOf(char4);

            result[i * 3] = (byte) (result1 < 128 ? result1 : (result1 - 256));
            result[i * 3 + 1] = (byte) (result2 < 128 ? result2 : (result2 - 256));
            result[i * 3 + 2] = (byte) (result3 < 128 ? result3 : (result3 - 256));
        }

        if(data.charAt(data.length() - 2) == '=') {
            return Arrays.copyOfRange(result, 0, result.length - 2);
        } else if(data.charAt(data.length() - 1) == '=') {
            return Arrays.copyOfRange(result, 0, result.length - 1);
        } else {
            return result;
        }
    }

    /**
     * Converteert een String van de ss-security-server naar een {@code PrivateKey}
     * @param data De data van de ss-security-server
     * @return De {@code PrivateKey}
     * @throws InvalidKeySpecException Als de data van de ss-security-server niet klopt.
     */
    public PrivateKey stringToPrivateKey(String data) throws InvalidKeySpecException {
        try {
            PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(data.getBytes());
            KeyFactory keyFactory = KeyFactory.getInstance("RSA");
            return keyFactory.generatePrivate(keySpec);
        } catch (NoSuchAlgorithmException e) {
            return null;
        }
    }

    /**
     * Signt een bericht met een {@code PrivateKey} en retourneert het resultaat in Base64
     * @param message Het bericht
     * @param key De {@code PrivateKey}
     * @return Het resultaat in Base64
     * @throws InvalidKeyException
     */
    public String sign(String message, PrivateKey key) throws InvalidKeyException {
        try {
            Signature signature = Signature.getInstance("SHA1withRSA");
            signature.initSign(key);
            signature.update(message.getBytes());
            return base64Encode(signature.sign());
        } catch (NoSuchAlgorithmException e) {
            return null;
        } catch (SignatureException e) {
            return null;
        }
    }

    /**
     * Converteert een String van de ss-security-server naar een {@code PublicKey}
     * @param data De data van de ss-security-server
     * @return De {@code PublicKey}
     * @throws InvalidKeySpecException
     */
    public PublicKey stringToPublicKey(String data) throws InvalidKeySpecException {
        try {
            X509EncodedKeySpec keySpec = new X509EncodedKeySpec(data.getBytes());
            KeyFactory keyFactory = KeyFactory.getInstance("RSA");
            return keyFactory.generatePublic(keySpec);
        } catch (NoSuchAlgorithmException e) {
            return null;
        }
    }

    /**
     * Verifieert een gesignd bericht voor een {@code PublicKey}.
     * @param message Het bericht
     * @param signedMessage Het gesignde bericht
     * @param key De {@code PublicKey}
     * @return Of het signen goed is gegaan
     * @throws InvalidKeyException
     */
    public boolean verify(String message, String signedMessage, PublicKey key) throws InvalidKeyException {
        try {
            Signature signature = Signature.getInstance("SHA1withRSA");
            signature.initVerify(key);
            signature.update(message.getBytes());
            return signature.verify(base64Decode(signedMessage));
        } catch (NoSuchAlgorithmException e) {
            return false;
        } catch (SignatureException e) {
            return false;
        }
    }
}
package rolit.model.networking.common;

import rolit.model.networking.client.*;
import rolit.model.networking.client.ChallengePacket;
import rolit.model.networking.client.HandshakePacket;
import rolit.model.networking.client.HighscorePacket;
import rolit.model.networking.client.MessagePacket;
import rolit.model.networking.client.MovePacket;
import rolit.model.networking.server.*;
import rolit.util.BiMap;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintStream;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.util.Arrays;
import java.util.LinkedHashMap;

/**
 * De basis voor alle pakketjes.
 * @author Pieter Bos
 */
public abstract class Packet {
    private static final BiMap<String, Class<? extends Packet>> CLIENT_PACKETS = new BiMap<String, Class<? extends Packet>>();
    private static final BiMap<String, Class<? extends Packet>> SERVER_PACKETS = new BiMap<String, Class<? extends Packet>>();

    static {
        CLIENT_PACKETS.put(ClientProtocol.HANDSHAKE, rolit.model.networking.client.HandshakePacket.class);
        CLIENT_PACKETS.put(ClientProtocol.AUTH, AuthPacket.class);
        CLIENT_PACKETS.put(ClientProtocol.CREATE_GAME, CreateGamePacket.class);
        CLIENT_PACKETS.put(ClientProtocol.JOIN_GAME, JoinGamePacket.class);
        CLIENT_PACKETS.put(ClientProtocol.START_GAME, StartGamePacket.class);
        CLIENT_PACKETS.put(ClientProtocol.MOVE, rolit.model.networking.client.MovePacket.class);
        CLIENT_PACKETS.put(ClientProtocol.MESSAGE, rolit.model.networking.client.MessagePacket.class);
        CLIENT_PACKETS.put(ClientProtocol.CHALLENGE, rolit.model.networking.client.ChallengePacket.class);
        CLIENT_PACKETS.put(ClientProtocol.CHALLENGE_RESPONSE, rolit.model.networking.client.ChallengeResponsePacket.class);
        CLIENT_PACKETS.put(ClientProtocol.HIGHSCORE, rolit.model.networking.client.HighscorePacket.class);

        SERVER_PACKETS.put(ServerProtocol.HANDSHAKE, rolit.model.networking.server.HandshakePacket.class);
        SERVER_PACKETS.put(ServerProtocol.AUTH_OK, AuthOkPacket.class);
        SERVER_PACKETS.put(ServerProtocol.ERROR, ErrorPacket.class);
        SERVER_PACKETS.put(ServerProtocol.GAME, GamePacket.class);
        SERVER_PACKETS.put(ServerProtocol.START, StartPacket.class);
        SERVER_PACKETS.put(ServerProtocol.MOVE, rolit.model.networking.server.MovePacket.class);
        SERVER_PACKETS.put(ServerProtocol.MOVE_DONE, MoveDonePacket.class);
        SERVER_PACKETS.put(ServerProtocol.GAME_OVER, GameOverPacket.class);
        SERVER_PACKETS.put(ServerProtocol.MESSAGE, rolit.model.networking.server.MessagePacket.class);
        SERVER_PACKETS.put(ServerProtocol.CHALLENGE, rolit.model.networking.server.ChallengePacket.class);
        SERVER_PACKETS.put(ServerProtocol.CHALLENGE_RESPONSE, rolit.model.networking.server.ChallengeResponsePacket.class);
        SERVER_PACKETS.put(ServerProtocol.CAN_BE_CHALLENGED, CanBeChallengedPacket.class);
        SERVER_PACKETS.put(ServerProtocol.HIGHSCORE, rolit.model.networking.server.HighscorePacket.class);
        SERVER_PACKETS.put(ServerProtocol.ONLINE, OnlinePacket.class);
    }

    protected Packet() {

    }

    /**
     * Geeft de argumenten uit een bepaald pakket.
     * @param args de argumenten van het pakket.
     */
    protected abstract void readFromArgs(PacketArgs args);

    /**
     * Geeft het type van de argumenten van het pakket.
     * @return het type van de argumenten.
     */
    protected abstract PacketArgs.ArgumentType[] getArgumentTypes();

    /**
     * Geeft de data van het pakket.
     * @return een array van objeceten met de data.
     */
    protected abstract Object[] getData();

    private static Packet readFrom(BufferedReader input, BiMap<String, Class<? extends Packet>> packets) throws IOException, ProtocolException {
        String line = input.readLine();

        if(line == null) {
            throw new IOException("Could not read a line");
        }

        String[] parts = line.split(CommonProtocol.COMMAND_DELIMITER);
        String command = parts[0];
        parts = Arrays.copyOfRange(parts, 1, parts.length);

        System.out.println(command);

        Packet result = null;

        try {
            Class<? extends Packet> packetClass = packets.get(command);

            if(packetClass == null) {
                throw new ProtocolException("Can't parse unregistered command " + command, ServerProtocol.ERROR_GENERIC);
            } else {
                Constructor<? extends Packet> constructor = packetClass.getDeclaredConstructor();

                if(constructor == null) {
                    throw new ProtocolException("Server cannot construct a packet for " + command, ServerProtocol.ERROR_GENERIC);
                } else {
                    constructor.setAccessible(true);
                    result = constructor.newInstance();
                }
            }
        } catch (InstantiationException e) {

        } catch (IllegalAccessException e) {

        } catch (NoSuchMethodException e) {

        } catch (InvocationTargetException e) {

        }

        PacketArgs.ArgumentType[] args = result.getArgumentTypes();

        result.readFromArgs(PacketArgs.fromParts(parts, args));

        return result;
    }

    public static Packet readClientPacketFrom(BufferedReader input) throws IOException, ProtocolException {
        return readFrom(input, CLIENT_PACKETS);
    }

    public static Packet readServerPacketFrom(BufferedReader input) throws IOException, ProtocolException {
        return readFrom(input, SERVER_PACKETS);
    }

    public String getCommand() {
        return CLIENT_PACKETS.getBackward(this.getClass()) == null
                ? SERVER_PACKETS.getBackward(this.getClass())
                : CLIENT_PACKETS.getBackward(this.getClass());
    }

    public void writeTo(PrintStream output) {
        output.print(getCommand());
        output.print(CommonProtocol.COMMAND_DELIMITER);
        output.print(new PacketArgs(getData()).toString());
        output.print(CommonProtocol.LINE_ENDING);
    }
}
package rolit.model.networking.common;

import rolit.model.networking.server.ServerProtocol;

/**
 * De verschillende exceptions die kunnen onstaan in het protocol.
 * @author Pieter Bos
 */
public class ProtocolException extends Exception {
    private final int code;

    public ProtocolException(String message, int code) {
        super(message);
        this.code = code;
    }

    public ProtocolException(String message) {
        this(message, ServerProtocol.ERROR_GENERIC);
    }

    public int getCode() {
        return code;
    }
}
package rolit.model.networking.common;

import rolit.model.networking.server.ServerProtocol;
import rolit.util.Strings;

import java.util.Arrays;

/**
 * De vrschillende argumenten die pakketjes kunnen hebben.
 * @author Pieter Bos
 */
public class PacketArgs {
    public enum ArgumentType {
        Integer,
        Boolean,
        String,
        MultiString
    }

    private Object[] data;

    public PacketArgs(Object[] data) {
        this.data = data;
    }

    private static Object parse(String data, ArgumentType arg) throws ProtocolException {
        switch(arg) {
            case Integer:
                return Integer.parseInt(data);
            case Boolean:
                if(!data.equals(CommonProtocol.T_BOOLEAN_TRUE) && !data.equals(CommonProtocol.T_BOOLEAN_FALSE)) {
                    throw new ProtocolException("Boolean must be true or false.", ServerProtocol.ERROR_GENERIC);
                }

                return data.equals(CommonProtocol.T_BOOLEAN_TRUE);
            case String:
                return data;
            case MultiString:
                throw new ProtocolException("Cannot parse a MultiString as a singular argument.", ServerProtocol.ERROR_GENERIC);
        }

        // Impossible
        return null;
    }

    public int getInt(int i) {
        return (Integer) data[i];
    }

    public boolean getBool(int i) {
        return (Boolean) data[i];
    }

    public String getString(int i) {
        return (String) data[i];
    }

    public String[] getMultiString(int i) {
        return (String[]) data[i];
    }

    public String getSpacedString(int i) {
        return Strings.join(CommonProtocol.COMMAND_DELIMITER, getMultiString(i));
    }

    public static PacketArgs fromParts(String[] parts, ArgumentType[] args) throws ProtocolException {
        boolean multiString = false;
        int multiStringLocation = -1;

        for(int i = 0; i < args.length; i++) {
            if(args[i] == ArgumentType.MultiString) {
                multiString = true;
                multiStringLocation = i;
                break;
            }
        }

        Object[] result = new Object[args.length];

        if(multiString) {
            for(int i = 0; i < multiStringLocation; i++) {
                result[i] = parse(parts[i], args[i]);
            }

            int left = args.length - multiStringLocation - 1;

            for(int i = parts.length - left, resultI = multiStringLocation + 1; i < parts.length; i++, resultI++) {
                result[resultI] = parse(parts[i], args[resultI]);
            }

            result[multiStringLocation] = Arrays.copyOfRange(parts, multiStringLocation, multiStringLocation + parts.length - args.length + 1);
        } else {
            if(parts.length > args.length) {
                throw new ProtocolException("Length of parts exceeds argument count.", ServerProtocol.ERROR_GENERIC);
            }

            for(int i = 0; i < parts.length; i++) {
                result[i] = parse(parts[i], args[i]);
            }
        }

        return new PacketArgs(result);
    }

    @Override
    public String toString() {
        String result = "";
        boolean first = true;

        for(Object unit : data) {
            if(!first) {
                result += CommonProtocol.COMMAND_DELIMITER;
            }

            first = false;

            if(unit instanceof Integer) {
                result += Integer.toString((Integer) unit);
            } else if(unit instanceof Boolean) {
                result += Boolean.toString((Boolean) unit);
            } else if(unit instanceof String) {
                result += (String) unit;
            } else {
                result += Strings.join(CommonProtocol.COMMAND_DELIMITER, (String[]) unit);
            }
        }

        return result;
    }

    public static String[] spacedToMulti(String s) {
        return s.split(CommonProtocol.COMMAND_DELIMITER);
    }
}
package rolit.model.networking.common;

import java.io.*;
import java.util.LinkedList;
import java.util.List;

public class PacketSource extends Thread {
    private final BufferedReader input;
    private List<PacketInputStream> inputStreams = new LinkedList<PacketInputStream>();

    public PacketSource(InputStream input) throws UnsupportedEncodingException {
        this.input = new BufferedReader(new InputStreamReader(input, "UTF-8"));
    }

    public PacketInputStream createInputStream() {
        PacketInputStream stream = new PacketInputStream();
        inputStreams.add(stream);
        return stream;
    }

    @Override
    public void run() {
        try {
            while(true) {
                Packet packet = Packet.readServerPacketFrom(input);
                notifyOfPacket(packet);
            }
        } catch (ProtocolException e) {
            notifyOfProtocolException(e);
        } catch (IOException e) {
            notifyOfIOException(e);
        }
    }

    private void notifyOfPacket(Packet packet) {
        for(PacketInputStream stream : inputStreams) {
            stream.notifyOfPacket(packet);
        }
    }

    private void notifyOfProtocolException(ProtocolException e) {
        for(PacketInputStream stream : inputStreams) {
            stream.notifyOfProtocolException(e);
        }
    }

    private void notifyOfIOException(IOException e) {
        for(PacketInputStream stream : inputStreams) {
            stream.notifyOfIOException(e);
        }
    }
}
package rolit.model.networking.extensions;
/**
 * @author Pieter Bos
 */
import rolit.model.networking.client.ClientProtocol;

public abstract class WebSocketClientProtocol extends ClientProtocol {
    public static final String GET = "GET";

    /**
     * Bij wijze van spreke een methode van de client.
     * @param path Moet altijd / zijn
     * @param version Moet altijd HTTP/1.1 zijn;
     */
    public abstract void get(String path, String version);
}
package rolit.model.networking.extensions;

import rolit.model.networking.server.ServerProtocol;

/**
 * @author Pieter Bos
 *
 * Abstract class voor het protocol van een rolit WebSocket server.
 *
 * Dit type server kan een extra commando ontvangen, GET. Deze moet als eerste worden verstuurd in plaats van de
 * handshake, of helemaal niet. Als dit commando wordt verstuurd wordt de connectie omgezet naar een HTTP-verbinding.
 * De server verwacht dan een "Upgrade: websocket" header en verder alle andere headers zoals gespecificeerd in
 * rfc #6455. Daarna reageert de server of met een 501 Not Implemented of een 101 Switching Protocols, afhankelijk van
 * of de request correct is. In het tweede geval wordt de connectie verheven naar een JSON-RPC 2.0 WebSocket server,
 * zoals hier gespecificeerd: http://www.jsonrpc.org/specification.
 * Elk commando is dan een JSON-RPC methode, met als argumenten gewoon de argumenten. Uitzondering is het chat-bericht,
 * die als één argument wordt verzonden. Daarnaast zijn de typen gewoon native JSON typen, namelijk strings, numbers en
 * booleans.
 *
 * Redenen voor dit protocol:
 * - Webstandaard die geïmplementeerd is in alle moderne browsers: IE10+, FF4+, Chrome14+, Safari5+, Opera11+ en deze
 *   browsers voor mobiele platforms.
 * - Heeft libraries voor bijna alle talen
 * - Is tekst-gebaseerd in het begin, zodat het redelijk vloeiend gaat tussen een WebSocket client en een gewone
 *   server.
 */
public abstract class WebSocketServerProtocol extends ServerProtocol {

}
package rolit.model.networking.server;

import rolit.model.networking.common.Packet;
import rolit.model.networking.common.PacketArgs;

/**
 * Het pakket dat verstuurd wordt als de status van een speler verandert ten aanzien van het gechallenged kunnen worden.
 * @author Pieter Bos
 */
public class CanBeChallengedPacket extends Packet {
    private String user;
    private boolean canBeChallenged;

    protected CanBeChallengedPacket() {

    }

    public CanBeChallengedPacket(String user, boolean canBeChallenged) {
        this.user = user;
        this.canBeChallenged = canBeChallenged;
    }

    public String getUser() {
        return user;
    }

    public boolean isCanBeChallenged() {
        return canBeChallenged;
    }

    /**
     * Zet de argumenten van het pakket in een variabele.
     * @param args de argumenten van het pakket.
     */
    @Override
    protected void readFromArgs(PacketArgs args) {
        this.user = args.getString(0);
        this.canBeChallenged = args.getBool(1);
    }

    /**
     * Geeft het type van het argument van het pakketje.
     * @return type argument.
     */
    @Override
    protected PacketArgs.ArgumentType[] getArgumentTypes() {
        return new PacketArgs.ArgumentType[] { PacketArgs.ArgumentType.String, PacketArgs.ArgumentType.Boolean };
    }

    /**
     * Geeft de data van het pakket in een object array.
     * @return een object array met de speler, en de status van het kunnen gechallenged worden.
     */
    @Override
    protected Object[] getData() {
        return new Object[] { user, canBeChallenged };
    }
}
package rolit.model.networking.server;

import rolit.model.networking.common.Packet;
import rolit.model.networking.common.PacketArgs;

/**
 * Het pakketje dat een error stuurt.
 * @author Pieter Bos
 */
public class ErrorPacket extends Packet {
    private int code;

    protected ErrorPacket() {

    }

    public ErrorPacket(int code) {
        this.code = code;
    }

    public int getCode() {
        return code;
    }

    /**
     * Zet de argumenten uit het pakketje in variabele.
     * @param args de argumenten van het pakket.
     */
    @Override
    protected void readFromArgs(PacketArgs args) {
        this.code = args.getInt(0);
    }

    /**
     * Geeft het type van het argument van het pakketje.
     * @return type argument.
     */
    @Override
    protected PacketArgs.ArgumentType[] getArgumentTypes() {
        return new PacketArgs.ArgumentType[] { PacketArgs.ArgumentType.Integer };
    }

    /**
     * Geeft de data van het pakket in een object array.
     * @return een object array met de error code.
     */
    @Override
    protected Object[] getData() {
        return new Object[] { this.code };
    }
}
package rolit.model.networking.server;

import rolit.model.networking.client.StartGamePacket;
import rolit.model.networking.common.ProtocolException;

/**
 * @author Pieter Bos
 */
public class WaitForGameClientHandlerState extends ClientHandlerState {
    private final String creator;

    public WaitForGameClientHandlerState(ClientHandler handler, String creator) {
        super(handler);
        this.creator = creator;
    }

    public String getCreator() {
        return creator;
    }

    /**
     * Verandert de status van de ClientHandler als het pakketje StartGame binnenkomt.
     * @param packet het ontvangen pakketje.
     * @return een nieuwe status van de ClientHandler.
     * @throws ProtocolException
     */
    @Override
    public ClientHandlerState startGame(StartGamePacket packet) throws ProtocolException {
        if(!getHandler().getClientName().equals(getCreator())) {
            throw new ProtocolException("Client tried to start a game that is not his.", ServerProtocol.ERROR_GENERIC);
        }

        getHandler().getGameByCreator(getHandler().getClientName()).start();

        getHandler().getGameByCreator(creator).getPlayers().get(0).getClient().notifyDoMove();

        return new GameClientHandlerState(getHandler(), getCreator());
    }

    /**
     * Verandert de status van de ClientHandler als er een response van een speler die gechallenged is binnenkomt.
     * @param response de reactie van de speler die gechallenged is.
     * @param challenged de speler die gechallenged is.
     * @return een nieuwe status van de ClientHandler.
     */
    @Override
    public ClientHandlerState notifyChallengeResponseBy(boolean response, String challenged) {
        getHandler().write(new ChallengeResponsePacket(challenged, response));
        return this;
    }

    @Override
    public ClientHandlerState notifyOfGameChange(ServerGame game) {
        super.notifyOfGameChange(game);

        if(game.getCreator().equals(creator)) {
            if(game.getStatus() == ServerProtocol.STATUS_PREMATURE_LEAVE) {
                getHandler().notifyCanBeChallenged();
                return new GameLobbyClientHandlerState(getHandler());
            }
        }

        return this;
    }

    @Override
    public ClientHandlerState notifyOfGameStart(String[] users) throws ProtocolException {
        getHandler().write(new StartPacket(users));
        return new GameClientHandlerState(getHandler(), creator);
    }

    @Override
    public ClientHandlerState exit() {
        if(getHandler().getClientName().equals(creator)) {
            try {
                getHandler().getGameByCreator(creator).stop();
            } catch (ProtocolException e) {
                // TODO again, logging service.
                System.out.println("WTF?");
            }
        } else {
            try {
                getHandler().getGameByCreator(creator).removePlayer(getHandler().getUser());
            } catch (ProtocolException e) {
                System.out.println("WTF?");
            }
        }

        return null;
    }
}
package rolit.model.networking.server;

import rolit.model.networking.client.ClientProtocol;
import rolit.model.networking.common.CommonProtocol;
import rolit.model.networking.common.ProtocolException;
import rolit.util.Crypto;

public class InitialClientHandlerState extends ClientHandlerState {
    public InitialClientHandlerState(ClientHandler handler) {
        super(handler);
    }

    @Override
    public ClientHandlerState handshake(rolit.model.networking.client.HandshakePacket packet) throws ProtocolException {
        if(packet.getSupports() < CommonProtocol.SUPPORTS_BAREBONE || packet.getSupports() > CommonProtocol.SUPPORTS_CHAT_CHALLENGE) {
            throw new ProtocolException("Invalid supports integer", ServerProtocol.ERROR_GENERIC);
        }

        if(packet.getName().length() < 2 || packet.getName().length() > 32) {
            throw new ProtocolException("Invalid name length or format", ServerProtocol.ERROR_INVALID_LOGIN);
        }

        getHandler().setClientSupports(packet.getSupports());

        if(packet.getName().startsWith("player_")) {
            String nonce = Crypto.getNonce();
            getHandler().write(new HandshakePacket(Server.GLOBAL_SUPPORTS, Server.GLOBAL_VERSION, nonce));
            return new AuthClientHandlerState(getHandler(), nonce, packet.getName());
        } else {
            getHandler().setClientName(packet.getName());
            getHandler().write(new HandshakePacket(Server.GLOBAL_SUPPORTS, Server.GLOBAL_VERSION));
            getHandler().writeInfo();
            getHandler().notifyOnline();
            getHandler().notifyCanBeChallenged();
            return new GameLobbyClientHandlerState(getHandler());
        }
    }

    @Override
    public ClientHandlerState exit() {
        return null;
    }
}
package rolit.model.networking.server;

import rolit.model.event.ServerListener;
import rolit.model.networking.common.CommonProtocol;
import rolit.model.networking.common.ProtocolException;
import rolit.util.Strings;

import java.io.IOException;
import java.net.InetAddress;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

/**
 * De server
 * @author Pieter Bos
 */
public class Server extends ServerSocket implements Runnable {
    private static final int DEFAULT_BACKLOG = 5;
    public static final int GLOBAL_SUPPORTS = CommonProtocol.SUPPORTS_CHAT_CHALLENGE;
    // TODO change global version
    public static final String GLOBAL_VERSION = "PieterMartijn_Alpha1";

    private Thread serverThread;
    private LinkedList<ServerListener> listeners = new LinkedList<ServerListener>();
    private LinkedList<ClientHandler> clients = new LinkedList<ClientHandler>();
    private HashMap<String, User> users = new LinkedHashMap<String, User>();
    private HashMap<String, ServerGame> games = new LinkedHashMap<String, ServerGame>();

    private Lock lock = new ReentrantLock();

    public Server(String bindAddress, int port) throws IOException {
        super(port, DEFAULT_BACKLOG, InetAddress.getByName(bindAddress));
        serverThread = new Thread(this);
    }

    public Thread getServerThread() {
        return serverThread;
    }

    /**
     * Voegt een nieuwe listener toe aan de lijst van listeners
     * @param listener de nieuwe listener.
     */
    public void addListener(ServerListener listener) {
        listeners.add(listener);
    }

    /**
     * Verwijdert een listener uit de lijst van listeners.
     * @param listener de listener die verwijders moet worden.
     */
    public void removeListener(ServerListener listener) {
        listeners.remove(listener);
    }

    /**
     * Start een nieuwe server thread.
     */
    public void serveForever() {
        serverThread.start();
    }

    /**
     * verstuurd een nieuwe error.
     * @param reason de rede voor de error.
     */
    public void fireServerError(String reason) {
        for(ServerListener listener : listeners) {
            listener.serverError(reason);
        }
    }

    /**
     * Voegt voor alle listeners de nieuwe ClientHandler toe.
     * @param handler de nieuwe ClientHandler.
     */
    private void fireNewClient(ClientHandler handler) {
        for(ServerListener listener : listeners) {
            listener.newClient(handler);
        }
    }

    /**
     * Verstuurd een error voor alle listeners.
     * @param reason de rede voor de error.
     */
    public void fireClientError(String reason) {
        for(ServerListener listener : listeners) {
            listener.clientError(reason);
        }
    }

    @Override
    public void run() {
        try {
            while(true) {
                Socket client = accept();
                ClientHandler handler = new ClientHandler(this, client);
                handler.start();
                fireNewClient(handler);
            }
        } catch(IOException e) {
            fireServerError("IOException: " + e.getMessage());
        }
    }

    public static void main(String[] args) throws IOException {
        new Server("0.0.0.0", 1234).serveForever();
    }

    /**
     * Notified alle spelers die zijn uitgedaagd.
     * @param challengedUsers de spelers die zijn uitgedaag.
     * @param challenger de speler die uitdaagd.
     * @throws ProtocolException
     */
    public void notifyChallenged(String[] challengedUsers, String challenger) throws ProtocolException {
        for(String challengedUser : challengedUsers) {
            if(users.get(challengedUser) == null || users.get(challengedUser).getUsername() == null || !users.get(challengedUser).getClient().supportsChallenge()) {
                throw new ProtocolException("Client tried to challenge users that cannot be challenged or are not online or do not exist.", ServerProtocol.ERROR_GENERIC);
            }
        }

        for(String challengedUser : challengedUsers) {
            User user = users.get(challengedUser);
            user.getClient().notifyChallengedBy(challenger, Strings.remove(challengedUsers, challengedUser));
        }
    }

    /**
     * Geeft een client een ClientHandler.
     * @param clientName de naam van de speler
     * @param clientHandler de ClientHandler.
     */
    public void setClientHandler(String clientName, ClientHandler clientHandler) {
        if(users.get(clientName) == null) {
            users.put(clientName, new User(clientName, clientHandler));
        } else {
            users.get(clientName).setClient(clientHandler);
        }
    }

    /**
     * Verstuurd een notificatie naar de challenger, en de andere speler die challenged zijn over de reactie van een
     * speler die gechallenged is.
     * @param response de reactie van de speler.
     * @param userNames de andere spelers die zijn uitgedaagd.
     * @param challenged de naam van de speler die een reactie geeft.
     * @throws ProtocolException wordt gegooid als er iets fout gaat.
     */
    public void notifyChallengeResponse(boolean response, String[] userNames, String challenged) throws ProtocolException {
        for(String userName : userNames) {
            users.get(userName).getClient().notifyChallengeResponseBy(response, challenged);
        }
    }

   public ServerGame getGameByCreator(String creator) {
        return games.get(creator);
    }

    public User getUser(String userName) {
        return users.get(userName);
    }

    /**
     * Maakt een nieuwe game aan.
     * @param userName de naam van de speler die de game aanmaakt.
     */
    public void createGame(String userName) throws ProtocolException {
        games.put(userName, new ServerGame(users.get(userName), this));
    }

    /**
     * Stuurt een notificatie aan alle andere clients over de verandering van het spel.
     * @param game de spel waarover de verandering gaat.
     */
    public void notifyOfGameChange(ServerGame game) {
        if(game.isStopped()) {
            games.remove(game.getCreator().getUsername());
        }

        for(User user : users.values()) {
            if(user.getClient() != null && user.getClient().getClientName() != null) {
                user.getClient().notifyOfGameChange(game);
            }
        }
    }

    public void writeInfo(String clientName) {
        User user = users.get(clientName);

        for(ServerGame game : games.values()) {
            user.getClient().notifyOfGameChange(game);
        }

        for(User other : users.values()) {
            if(other.getClient() != null && other.getClient().getClientName() != null && other.getClient().supportsChat()) {
                user.getClient().notifyOnlineOf(other.getUsername());
            }
        }

        for(User other : users.values()) {
            if(other.getClient() != null && other.getClient().getClientName() != null && other.getClient().canBeChallenged()) {
                user.getClient().notifyCanBeChallengedOf(other.getUsername());
            }
        }
    }

    public void notifyOnline(String clientName) {
        for(User user : users.values()) {
            if(user.getClient() != null && user.getClient().getClientName() != null && !user.getClient().getClientName().equals(clientName)) {
                user.getClient().notifyOnlineOf(clientName);
            }
        }
    }

    public void notifyOffline(String clientName) {
        for(User user : users.values()) {
            if(user.getClient() != null && user.getClient().getClientName() != null && !user.getClient().getClientName().equals(clientName)) {
                user.getClient().notifyOfflineOf(clientName);
            }
        }
    }

    public void notifyCannotBeChallenged(String clientName) {
        for(User user : users.values()) {
            if(user.getClient() != null && user.getClient().getClientName() != null && !user.getClient().getClientName().equals(clientName)) {
                user.getClient().notifyCannotBeChallengedOf(clientName);
            }
        }
    }

    public void notifyCanBeChallenged(String clientName) {
        for(User user : users.values()) {
            if(user.getClient() != null && user.getClient().getClientName() != null  && !user.getClient().getClientName().equals(clientName)) {
                user.getClient().notifyCanBeChallengedOf(clientName);
            }
        }
    }

    public void createChallengeGame(String challenger, LinkedList<String> others) throws ProtocolException {
        ServerGame game = new ServerGame(challenger, others, this);
        game.start();
    }

    public void notifyOfGameStart(ServerGame serverGame) throws ProtocolException {
        String[] names = new String[serverGame.getPlayerCount()];

        for(int i = 0; i < names.length; i++) {
            names[i] = serverGame.getPlayers().get(i).getUsername();
        }

        for(User player : serverGame.getPlayers()) {
            player.getClient().notifyOfGameStart(names);
        }
    }

    public void notifyMove(String creator, String mover, int x, int y) throws ProtocolException {
        ServerGame game = getGameByCreator(creator);

        for(User player : game.getPlayers()) {
            player.getClient().notifyOfMove(mover, x, y);
        }
    }

    public void lock() {
        lock.lock();
    }

    public void unlock() {
        lock.unlock();
    }
}
package rolit.model.networking.server;

import rolit.model.networking.common.Packet;
import rolit.model.networking.common.PacketArgs;

/**
 * Het pakketje dat wordt verstuurd als het spel wordt gestart.
 * @author Pieter Bos
 */
public class StartPacket extends Packet {
    private String[] players;

    protected StartPacket() {

    }

    public StartPacket(String[] players) {
        this.players = players;
    }

    public String[] getPlayers() {
        return players;
    }

    /**
     * Zet de argumenten van het pakketje in variabele.
     * @param args de argumenten van het pakket.
     */
    @Override
    protected void readFromArgs(PacketArgs args) {
        this.players = args.getMultiString(0);
    }

    /**
     * Geeft het type van het argument van het pakketje terug.
     * @return het type pakketje.
     */
    @Override
    protected PacketArgs.ArgumentType[] getArgumentTypes() {
        return new PacketArgs.ArgumentType[] { PacketArgs.ArgumentType.MultiString };
    }
    /**
     * Geeft de data van het pakket in een object array.
     * @return een object array met de spelers.
     */
    @Override
    protected Object[] getData() {
        return new Object[] { players };
    }
}
package rolit.model.networking.server;

import rolit.model.game.Game;
import rolit.model.game.Position;
import rolit.model.networking.common.ProtocolException;

import java.util.LinkedList;
import java.util.List;

/**
 * Het spel waarin gespeeld gaat worden.
 * @author Pieter Bos
 */
public class ServerGame {
    private final LinkedList<User> players = new LinkedList<User>();
    private final User creator;
    private Server server;
    private boolean started;
    private boolean stopped;

    private Game game;

    public ServerGame(User creator, Server server) throws ProtocolException {
        this.creator = creator;
        this.server = server;
        players.add(creator);
        notifyOfChange();
    }

    public ServerGame(String challenger, LinkedList<String> others, Server server) {
        creator = server.getUser(challenger);
        players.add(creator);

        for(String other : others) {
            players.add(server.getUser(other));
        }
    }

    public User getCreator() {
        return creator;
    }

    /**
     * Verstuurd een notificatie als de status van het spel verandert.
     * @throws ProtocolException wordt gegooid als er iets fout gaat.
     */
    public void notifyOfChange() throws ProtocolException {
        server.notifyOfGameChange(this);
    }

    /**
     * Voegt een speler toe aan het spel.
     * @param player de speler die wordt toegevoegd.
     * @throws ProtocolException wordt gegooid als er iets fout gaat.
     */
    public void addPlayer(User player) throws ProtocolException {
        players.add(player);
        notifyOfChange();
    }

    /**
     * Verwijdert een speler uit het spel.
     * @param player de speler die wordt verwijdert.
     * @throws ProtocolException
     */
    public void removePlayer(User player) throws ProtocolException {
        players.remove(player);
        notifyOfChange();
    }

    public int getPlayerCount() {
        return players.size();
    }

    public LinkedList<User> getPlayers() {
        return players;
    }

    public boolean isStarted() {
        return started;
    }

    public void start() throws ProtocolException {
        started = true;

        game = new Game(getPlayerCount());

        notifyOfChange();
        server.notifyOfGameStart(this);
    }

    public Server getServer() {
        return server;
    }

    public int getStatus() {
        return isStopped() ? -1 : (isStarted() ? 1 : 0);
    }

    public boolean isStopped() {
        return stopped;
    }

    /**
     * Breekt het spel af, als er iets mis gaat of als het spel is afgelopen.
     * @throws ProtocolException wordt gegooid als er iets niet goed is in de server.
     */
    public void stop() throws ProtocolException {
        this.stopped = true;
        notifyOfChange();
    }

    public int getIndex(User user) {
        int index = 0;

        for(User player : players) {
            if(player == user) {
                return index;
            }

            index++;
        }

        return -1;
    }

    public boolean isLegalMove(int x, int y) {
        return game.getBoard().isLegalMove(getPlayerCount() == 2 ? game.getCurrentPlayer() * 2 : game.getCurrentPlayer(), new Position(x, y));
    }

    public void doMove(int x, int y) {
        game.getBoard().doMove(getPlayerCount() == 2 ? game.getCurrentPlayer() * 2 : game.getCurrentPlayer(), new Position(x, y));
    }

    public void nextPlayer() {
        game.nextPlayer();
    }

    public int getPlayer() {
        return game.getCurrentPlayer();
    }

    public boolean isGameOver() {
        return game.getBoard().gameOver();
    }

    public int getScore() {
        if(!isGameOver()) {
            return 0;
        } else {
            return game.getBoard().getHighScore();
        }
    }

    public String[] getWinners() {
        Integer[] winnerIndexes = game.getBoard().determineWinners();
        List<String> winners = new LinkedList<String>();

        for(Integer index : winnerIndexes) {
            if(index < getPlayers().size()) {
                winners.add(getPlayers().get(index).getUsername());
            }
        }

        String[] winnersArray = new String[winners.size()];
        winners.toArray(winnersArray);
        return winnersArray;
    }
}
package rolit.model.networking.server;

import rolit.model.game.Player;

/**
 *
 * @author Pieter Bos
 */
public class User {
    private final String username;
    private ClientHandler client;

    public User(String username, ClientHandler client) {
        this.username = username;
        this.client = client;
    }

    public String getUsername() {
        return username;
    }

    public ClientHandler getClient() {
        return client;
    }

    public void setClient(ClientHandler client) {
        this.client = client;
    }

    public boolean isOnline() {
        return getClient() != null;
    }
}
package rolit.model.networking.server;

import rolit.model.networking.common.Packet;
import rolit.model.networking.common.PacketArgs;

/**
 * Het pakketje met een chat bericht.
 * @author Pieter Bos
 */
public class MessagePacket extends Packet {
    private String user;
    private String message;

    protected MessagePacket() {

    }

    public MessagePacket(String user, String message) {
        this.user = user;
        this.message = message;
    }

    public String getUser() {
        return user;
    }

    public String getMessage() {
        return message;
    }

    /**
     * Zet de argumenten van het pakketje in variabele.
     * @param args de argumenten van het pakket.
     */
    @Override
    protected void readFromArgs(PacketArgs args) {
        this.user = args.getString(0);
        this.message = args.getSpacedString(1);
    }

    /**
     * Geeft het type van de argumenten van het pakketje.
     * @return het type argument.
     */
    @Override
    protected PacketArgs.ArgumentType[] getArgumentTypes() {
        return new PacketArgs.ArgumentType[] { PacketArgs.ArgumentType.String, PacketArgs.ArgumentType.MultiString };
    }

    /**
     * Geeft de data van het pakket in een object array.
     * @return een object array met een speler, en een bericht.
     */
    @Override
    protected Object[] getData() {
        return new Object[] { user, message };
    }
}
package rolit.model.networking.server;

import rolit.model.networking.client.*;
import rolit.model.networking.common.ProtocolException;

/**
 * De status van de ClientHandler.
 * @author Pieter Bos
 */
public abstract class ClientHandlerState {
    private ClientHandler handler;

    public ClientHandlerState(ClientHandler handler) {
        this.handler = handler;
    }

    /**
     * Gooit een exceptie als er niet van status verandert kan worden.
     * @param commandName naam van het commanda.
     * @throws ProtocolException wordt gegooid van een status niet naar de andere status verandert kan worden.
     */
    private void error(String commandName) throws ProtocolException {
        throw new ProtocolException("Cannot do " + commandName + " while in state " + this.getClass().getName(), ServerProtocol.ERROR_GENERIC);
    }

    public ClientHandlerState challenge(rolit.model.networking.client.ChallengePacket packet) throws ProtocolException {
        error("challenge");
        return null;
    }

    public ClientHandlerState challengeResponse(rolit.model.networking.client.ChallengeResponsePacket packet) throws ProtocolException {
        error("challenge response");
        return null;
    }

    public ClientHandlerState createGame(rolit.model.networking.client.CreateGamePacket packet) throws ProtocolException {
        error("create game");
        return null;
    }

    public ClientHandlerState handshake(rolit.model.networking.client.HandshakePacket packet) throws ProtocolException {
        error("hello");
        return null;
    }

    public ClientHandlerState joinGame(rolit.model.networking.client.JoinGamePacket packet) throws ProtocolException {
        error("join game");
        return null;
    }

    public ClientHandlerState move(rolit.model.networking.client.MovePacket packet) throws ProtocolException {
        error("move");
        return null;
    }

    public ClientHandlerState startGame(rolit.model.networking.client.StartGamePacket packet) throws ProtocolException {
        error("start game");
        return null;
    }

    public ClientHandler getHandler() {
        return handler;
    }

    public ClientHandlerState auth(rolit.model.networking.client.AuthPacket packet) throws ProtocolException {
        error("auth");
        return null;
    }

    public ClientHandlerState notifyChallengedBy(String challenger, String[] others) throws ProtocolException {
        error("challenged");
        return null;
    }

    public ClientHandlerState notifyChallengeResponseBy(boolean response, String challenged) throws ProtocolException {
        error("challenge response");
        return null;
    }

    /**
     * Standaardgedrag is om gewoon het pakket door te sturen, tenzij de staat van het spel is veranderd terwijl het
     * spel al gestart is.
     * @param game het desbetreffende spel
     * @return zichzelf, aangezien de staat niet verandert.
     */
    public ClientHandlerState notifyOfGameChange(ServerGame game) {
        if(!(game.isStarted() && game.isStopped())) {
            getHandler().write(new GamePacket(game.getCreator().getUsername(), game.getStatus(), game.getPlayerCount()));
        }

        return this;
    }

    public ClientHandlerState exit() {
        // TODO add to logging service
        System.out.println("Warning: exit not implemented in state " + this.getClass().getName());
        return null;
    }

    /**
     * Wordt gebruikt om de initiele lijst met supportsChallenge's te sturen naar een nieuwe client.
     * @return false
     */
    public boolean canBeChallenged() {
        return false;
    }

    public ClientHandlerState notifyOfGameStart(String[] users) throws ProtocolException {
        error("game start by other");
        return null;
    }

    public ClientHandlerState notifyDoMove() throws ProtocolException {
        error("notify of move");
        return null;
    }

    public ClientHandlerState notifyOfMove(String mover, int x, int y) throws ProtocolException {
        error("notify of move by other");
        return null;
    }
}
package rolit.model.networking.server;

import rolit.model.networking.common.ProtocolException;

/**
 * De staat van de ClientHandler ten aanzien van het gechallenged kunnen worden.
 * @author Pieter Bos
 */
public class ChallengedClientHandlerState extends ClientHandlerState {
    private final String challenger;
    private String[] others;

    public ChallengedClientHandlerState(ClientHandler handler, String challenger, String[] others) {
        super(handler);
        this.challenger = challenger;
        this.others = others;
    }

    /**
     * Verandert de status van de ClientHandler als er een ChallengeResponse pakketje ontvangen wordt.
     * @param packet het ontvangen pakketje.
     * @return Een nieuwe ClientHandler staat met een nieuwe status.
     * @throws ProtocolException gooit deze exceptie als er iets fout gaat.
     */
    @Override
    public ClientHandlerState challengeResponse(rolit.model.networking.client.ChallengeResponsePacket packet) throws ProtocolException {
        getHandler().notifyChallengeResponse(packet.getResponse(), getChallenger(), getOthers());

        if(packet.getResponse()) {
            return new WaitForGameClientHandlerState(getHandler(), getChallenger());
        } else {
            getHandler().notifyCanBeChallenged();
            return new GameLobbyClientHandlerState(getHandler());
        }
    }

    /**
     * Verandert de status van de ClientHandler als de speler een challenge heeft geaccepteerd of gedeclined.
     * @param response De reactie van de speler op de challenge.
     * @param challenged de naam van de speler die gechallenged is.
     * @return een nieuwe ClientHandler staat met een nieuwe status.
     */
    @Override
    public ClientHandlerState notifyChallengeResponseBy(boolean response, String challenged) {
        getHandler().write(new ChallengeResponsePacket(challenged, response));
        return this;
    }

    public String getChallenger() {
        return challenger;
    }

    public String[] getOthers() {
        return others;
    }

    @Override
    public ClientHandlerState exit() {
        try {
            getHandler().notifyChallengeResponse(false, getChallenger(), getOthers());
        } catch (ProtocolException e) {  }

        return null;
    }
}
package rolit.model.networking.server;

import rolit.model.networking.common.Packet;
import rolit.model.networking.common.PacketArgs;

public class ChallengeResponsePacket extends Packet {
    private String user;
    private boolean accept;

    protected ChallengeResponsePacket() {

    }

    public ChallengeResponsePacket(String user, boolean accept) {
        this.user = user;
        this.accept = accept;
    }

    public String getUser() {
        return user;
    }

    public boolean isAccept() {
        return accept;
    }

    /**
     * Zet de argumenten van het pakket in de variabele.
     * @param args de argumenten van het pakket.
     */
    @Override
    protected void readFromArgs(PacketArgs args) {
        this.user = args.getString(0);
        this.accept = args.getBool(1);
    }

    /**
     * Geeft het type van het argument van het pakketje.
     * @return type argument.
     */
    @Override
    protected PacketArgs.ArgumentType[] getArgumentTypes() {
        return new PacketArgs.ArgumentType[] { PacketArgs.ArgumentType.String, PacketArgs.ArgumentType.Boolean };
    }

    /**
     * Geeft de data van het pakket in een object array.
     * @return een object array met de speler en de reactie van de speler op de challenge.
     */
    @Override
    protected Object[] getData() {
        return new Object[] { user, accept };
    }
}
package rolit.model.networking.server;

import rolit.model.networking.common.Packet;
import rolit.model.networking.common.PacketArgs;

/**
 * Het pakketje wat aangeeft als de game voorbij is.
 * @author Pieter Bos
 */
public class GameOverPacket extends Packet {
    private int score;
    private String[] winners;

    protected GameOverPacket() {

    }

    public GameOverPacket(int score, String[] winners) {
        this.score = score;
        this.winners = winners;
    }

    public int getScore() {
        return score;
    }

    public String[] getWinners() {
        return winners;
    }

    /**
     * Zet de argumenten van het pakketje in variabele.
     * @param args de argumenten van het pakket.
     */
    @Override
    protected void readFromArgs(PacketArgs args) {
        this.score = args.getInt(0);
        this.winners = args.getMultiString(1);
    }

    /**
     * Geeft het type van het argument van het pakketje.
     * @return type argument.
     */
    @Override
    protected PacketArgs.ArgumentType[] getArgumentTypes() {
        return new PacketArgs.ArgumentType[] { PacketArgs.ArgumentType.Integer, PacketArgs.ArgumentType.MultiString };
    }

    /**
     * Geeft de data van het pakket in een object array.
     * @return een object array van de score en de winnaar(s).
     */
    @Override
    protected Object[] getData() {
        return new Object[] { score, winners };
    }
}
package rolit.model.networking.server;

import rolit.model.networking.client.*;
import rolit.model.networking.common.CommonProtocol;
import rolit.model.networking.common.Packet;
import rolit.model.networking.common.ProtocolException;
import rolit.util.Strings;

import java.io.*;
import java.net.Socket;
import java.util.LinkedList;

/**
 * De ClientHandler
 * @author Pieter Bos
 */
public class ClientHandler implements Runnable {
    private final Server server;
    private final Socket client;
    private BufferedReader input;
    private PrintStream output;
    private final Thread thread;

    private ClientHandlerState state;

    private int clientSupports;
    private String clientName;

    public ClientHandler(Server server, Socket client) throws IOException {
        this.server = server;
        this.client = client;
        thread = new Thread(this);
        state = new InitialClientHandlerState(this);
    }

    /**
     * Start een nieuwe thread voor elke nieuwe client.
     */
    public void start() {
        thread.start();
    }

    /**
     * Verandert de status van de ClientHandlerState op basis de binnengekomen pakketjes.
     * @param packet Het pakketje wat ontvangen worden.
     * @throws ProtocolException wordt gegooid als er bij een van de pakketje die ontvangen wordt iets verkeerd gaat.
     */
    private void handlePacket(Packet packet) throws ProtocolException {
        ClientHandlerState oldState = state;

        if(packet instanceof rolit.model.networking.client.ChallengePacket) {
            state = state.challenge((rolit.model.networking.client.ChallengePacket) packet);
        } else if(packet instanceof rolit.model.networking.client.ChallengeResponsePacket) {
            state = state.challengeResponse((rolit.model.networking.client.ChallengeResponsePacket) packet);
        } else if(packet instanceof CreateGamePacket) {
            state = state.createGame((CreateGamePacket) packet);
        } else if(packet instanceof rolit.model.networking.client.HandshakePacket) {
            state = state.handshake((rolit.model.networking.client.HandshakePacket) packet);
        } else if(packet instanceof HighscorePacket) {
            highscore((HighscorePacket) packet);
        } else if(packet instanceof JoinGamePacket) {
            state = state.joinGame((JoinGamePacket) packet);
        } else if(packet instanceof MessagePacket) {
            message((MessagePacket) packet);
        } else if(packet instanceof rolit.model.networking.client.MovePacket) {
            state = state.move((rolit.model.networking.client.MovePacket) packet);
        } else if(packet instanceof StartGamePacket) {
            state = state.startGame((StartGamePacket) packet);
        } else if(packet instanceof AuthPacket) {
            state = state.auth((AuthPacket) packet);
        } else {
            throw new ProtocolException("Client caused the server to be in an impossible condition", ServerProtocol.ERROR_GENERIC);
        }

        if(oldState != state) {
            System.out.println(getClientName() + ": " + oldState.getClass().getName() + " -> " + state.getClass().getName());
        }
    }


    private void message(MessagePacket packet) {

    }

    private void highscore(HighscorePacket packet) {

    }

    /**
     * Notified de spelers die gechallenged worden.
     * @param challenged de spelers die gechallenged worden.
     * @throws ProtocolException een exceptie als er iets fout gaat.
     */
    public void notifyChallenged(String[] challenged) throws ProtocolException {
        server.notifyChallenged(challenged, getClientName());
    }

    @Override
    public void run() {
        try {
            try {
                this.input = new BufferedReader(new InputStreamReader(client.getInputStream(), "UTF-8"));
                this.output = new PrintStream(client.getOutputStream(), true, "UTF-8");

                while(true) {
                    Packet packet = Packet.readClientPacketFrom(input);
                    server.lock();
                    handlePacket(packet);
                    server.unlock();
                }
            } catch (ProtocolException e) {
                System.out.println("ProtocolException: " + e.getMessage());
                server.fireClientError("ProtocolException: " + e.getMessage());
                new ErrorPacket(e.getCode()).writeTo(output);
                client.close();
            }
        } catch (IOException e) {
            server.lock();
            server.fireClientError("IOException: " + e.getMessage());
        }

        state = state.exit();

        if(getClientName() != null) {
            if(supportsChat()) {
                server.notifyOffline(getClientName());
            }

            if(supportsChallenge()) {
                server.notifyCannotBeChallenged(getClientName());
            }

            getUser().setClient(null);
        }

        server.unlock();
    }

    public int getClientSupports() {
        return clientSupports;
    }

    public void setClientSupports(int clientSupports) {
        this.clientSupports = clientSupports;
    }

    public String getClientName() {
        return clientName;
    }

    public void setClientName(String clientName) {
        this.clientName = clientName;
        server.setClientHandler(clientName, this);
    }

    public synchronized void write(Packet packet) {
        packet.writeTo(output);
    }

    public boolean supportsChallenge() {
        return (getClientSupports() & CommonProtocol.SUPPORTS_CHALLENGE) != 0;
    }

    public boolean supportsChat() {
        return (getClientSupports() & CommonProtocol.SUPPORTS_CHAT) != 0;
    }

    public boolean canBeChallenged() {
        return supportsChallenge() && state.canBeChallenged();
    }

    public void notifyChallengedBy(String challenger, String[] others) throws ProtocolException {
        state = state.notifyChallengedBy(challenger, others);
    }

    /**
     * Stuurt een notificatie naar de andere spelers die gechallenged waren, en de challenger.
     * @param response de reactie van de speler
     * @param challenger de challenger.
     * @param others de andere spelers die gechallenged zijn.
     * @throws ProtocolException wordt gegooid als er iets fout gaat.
     */
    public void notifyChallengeResponse(boolean response, String challenger, String[] others) throws ProtocolException {
        server.notifyChallengeResponse(response, Strings.push(challenger, others), getClientName());
    }

    /**
     * verandert de status van de speler die reageert op een challenge.
     * @param response de reactie van de speler.
     * @param challenged de speler die gechallenged is.
     * @throws ProtocolException wordt gegooid als er iets fout gaat.
     */
    public void notifyChallengeResponseBy(boolean response, String challenged) throws ProtocolException {
        state = state.notifyChallengeResponseBy(response, challenged);
    }

    public ServerGame getGameByCreator(String creator) {
        return server.getGameByCreator(creator);
    }

    public User getUser() {
        return server.getUser(getClientName());
    }

    public void createGame() throws ProtocolException {
        server.createGame(getClientName());
    }

    public void notifyOfGameChange(ServerGame game) {
        state = state.notifyOfGameChange(game);
    }

    public void writeInfo() {
        server.writeInfo(this.getClientName());
    }

    public void notifyOnline() {
        if(supportsChat()) {
            server.notifyOnline(getClientName());
        }
    }

    public void notifyOnlineOf(String clientName) {
        if(supportsChat()) {
            write(new OnlinePacket(clientName, true));
        }
    }

    public void notifyOfflineOf(String clientName) {
        if(supportsChat()) {
            write(new OnlinePacket(clientName, false));
        }
    }

    public void notifyCannotBeChallengedOf(String clientName) {
        if(supportsChallenge()) {
            write(new CanBeChallengedPacket(clientName, false));
        }
    }

    public void notifyCanBeChallenged() {
        if(supportsChallenge()) {
            server.notifyCanBeChallenged(getClientName());
        }
    }

    public void notifyCanBeChallengedOf(String clientName) {
        if(supportsChallenge()) {
            write(new CanBeChallengedPacket(clientName, true));
        }
    }

    public void notifyCannotBeChallenged() {
        if(supportsChallenge()) {
            server.notifyCannotBeChallenged(getClientName());
        }
    }

    public void createChallengeGame(LinkedList<String> others) throws ProtocolException {
        server.createChallengeGame(getClientName(), others);
    }

    public void notifyOfGameStart(String[] names) throws ProtocolException {
        state = state.notifyOfGameStart(names);
    }

    public void notifyDoMove() throws ProtocolException {
        state = state.notifyDoMove();
    }

    public void notifyMove(String creator, int x, int y) throws ProtocolException {
        server.notifyMove(creator, getClientName(), x, y);
    }

    public void notifyOfMove(String mover, int x, int y) throws ProtocolException {
        state = state.notifyOfMove(mover, x, y);
    }
}
package rolit.model.networking.server;

import rolit.model.networking.common.Packet;
import rolit.model.networking.common.PacketArgs;

/**
 * Het pakketje wat verstuurd wordt naar de speler die aan de beurt is.
 * @author Pieter Bos
 */
public class MovePacket extends Packet {
    public MovePacket() {

    }

    @Override
    protected void readFromArgs(PacketArgs args) {

    }

    @Override
    protected PacketArgs.ArgumentType[] getArgumentTypes() {
        return new PacketArgs.ArgumentType[] {  };
    }

    @Override
    protected Object[] getData() {
        return new Object[] {  };
    }
}
package rolit.model.networking.server;

import rolit.model.networking.common.Packet;
import rolit.model.networking.common.PacketArgs;

/**
 * Het pakketje dat de server ontvangt van de challenger, bevat wie er gechallenged moet worden.
 * @author Pieter Bos
 */
public class ChallengePacket extends Packet {
    private String challenger;
    private String[] others;

    protected ChallengePacket() {

    }

    public ChallengePacket(String challenger, String[] others) {
        this.challenger = challenger;
        this.others = others;
    }

    /**
     * Zet de argumenten van het pakketje in de variabele.
     * @param args de argumenten van het pakket.
     */
    @Override
    protected void readFromArgs(PacketArgs args) {
        this.challenger = args.getString(0);
        this.others = args.getMultiString(1);
    }

    /**
     * Geeft het type van het argument van het pakketje.
     * @return type argument.
     */
    @Override
    protected PacketArgs.ArgumentType[] getArgumentTypes() {
        return new PacketArgs.ArgumentType[] { PacketArgs.ArgumentType.String, PacketArgs.ArgumentType.MultiString };
    }

    /**
     * Geeft de data van het pakket in een object array.
     * @return een object array met de challenger, en de andere challenged.
     */
    @Override
    protected Object[] getData() {
        return new Object[] { challenger, others };
    }
}
package rolit.model.networking.server;

import rolit.model.networking.common.Packet;
import rolit.model.networking.common.PacketArgs;

/**
 * Het pakketje met de informatie van een game.
 * @author Pieter Bos
 */
public class GamePacket extends Packet {
    private String game;
    private int status;
    private int players;

    protected GamePacket() {

    }

    public GamePacket(String game, int status, int players) {
        this.game = game;
        this.status = status;
        this.players = players;
    }

    public String getGame() {
        return game;
    }

    public int getStatus() {
        return status;
    }

    public int getPlayers() {
        return players;
    }

    /**
     * Zet de argumten van het pakketje in variabele.
     * @param args de argumenten van het pakket.
     */
    @Override
    protected void readFromArgs(PacketArgs args) {
        this.game = args.getString(0);
        this.status = args.getInt(1);
        this.players = args.getInt(2);
    }

    /**
     * Geeft het type van het argument van het pakketje.
     * @return type argument.
     */
    @Override
    protected PacketArgs.ArgumentType[] getArgumentTypes() {
        return new PacketArgs.ArgumentType[] { PacketArgs.ArgumentType.String, PacketArgs.ArgumentType.Integer, PacketArgs.ArgumentType.Integer };
    }

    @Override
    protected Object[] getData() {
        return new Object[] { game, status, players };
    }
}
package rolit.model.networking.server;

import rolit.model.networking.client.AuthPacket;
import rolit.model.networking.common.ProtocolException;
import rolit.model.networking.sssecurity.SSSecurity;
import rolit.util.Crypto;

import java.security.PublicKey;

import rolit.util.Crypto;

/**
 * De staat van ClientHandler ten aanzien van het authenticeren.
 * @author Pieter Bos
 */
public class AuthClientHandlerState extends ClientHandlerState {
    private String nonce;
    private String clientName;

    public AuthClientHandlerState(ClientHandler handler, String nonce, String clientName) {
        super(handler);
        this.nonce = nonce;
        this.clientName = clientName;
    }

    /**
     * Verandert de status van de ClientHandler als de speler geauthenticeerd wordt.
     * @param packet het pakket waarin de cypher zit die gecontroleerd moet worden.
     * @return een nieuwe ClientState met een nieuwe status.
     * @throws ProtocolException als de speler niet geauthenticeerd kan worden, wordt er een exception gegegooid.
     */
    @Override
    public ClientHandlerState auth(AuthPacket packet) throws ProtocolException {
        byte[] cypherText = Crypto.base64Decode(packet.getCypherText());
        byte[] original = Crypto.base64Decode(nonce);
        PublicKey publicKey = SSSecurity.getPublicKey(getHandler().getClientName());

        if(!Crypto.verify(cypherText, original, publicKey)) {
            throw new ProtocolException("Invalid client authentication", ServerProtocol.ERROR_INVALID_LOGIN);
        }

        getHandler().write(new AuthOkPacket());

        getHandler().setClientName(this.clientName);

        return new GameLobbyClientHandlerState(getHandler());
    }

    @Override
    public ClientHandlerState exit() {
        return null;
    }
}
package rolit.model.networking.server;

import rolit.model.networking.common.Packet;
import rolit.model.networking.common.PacketArgs;

/**
 * Het pakketje wat verstuurd als de status van een speler verandert.
 * @author Pieter Bos
 */
public class OnlinePacket extends Packet {
    private String user;
    private boolean online;

    protected OnlinePacket() {

    }

    public OnlinePacket(String user, boolean online) {
        this.user = user;
        this.online = online;
    }

    public String getUser() {
        return user;
    }

    public boolean isOnline() {
        return online;
    }

    /**
     * Zet de argumenten van het pakketje in variabele.
     * @param args de argumenten van het pakket.
     */
    @Override
    protected void readFromArgs(PacketArgs args) {
        this.user = args.getString(0);
        this.online = args.getBool(1);
    }

    /**
     * Geeft het type van het argument van het pakketje terug.
     * @return het type argument.
     */
    @Override
    protected PacketArgs.ArgumentType[] getArgumentTypes() {
        return new PacketArgs.ArgumentType[] { PacketArgs.ArgumentType.String, PacketArgs.ArgumentType.Boolean };
    }

    /**
     * Geeft de data van het pakket in een object array.
     * @return een object array van de naam van de speler, en een boolean of de client online is.
     */
    @Override
    protected Object[] getData() {
        return new Object[] { user, online };
    }
}
package rolit.model.networking.server;

import rolit.model.networking.common.CommonProtocol;

import java.io.IOException;

/**
 * Het protocol specifiek voor de server.
 * @author Pieter Bos
 * @author Martijn de Bijl
 *
 * Abstract class met alle constanten en methodes die gebruikt kunnen worden
 */
public abstract class ServerProtocol extends CommonProtocol {
    /**
     * Constante voor het handshake-commando
     */
    public static final String HANDSHAKE = "hello";

    /**
     * Constante voor het authOk-commando
     */
    public static final String AUTH_OK = "authOk";

    /**
     * Constante voor het error-commando
     */
    public static final String ERROR = "error";

    /**
     * Constante voor het game-commando
     */
    public static final String GAME = "game";

    /**
     * Constante voor het start-commando
     */
    public static final String START = "start";

    /**
     * Constante voor het move-commando
     */
    public static final String MOVE = "move";

    /**
     * Constante voor het move-done-commando
     */
    public static final String MOVE_DONE = "moveDone";

    /**
     * Constante voor het game-over-command
     */
    public static final String GAME_OVER = "gameOver";

    /**
     * Constante voor het message-commando
     */
    public static final String MESSAGE = "message";

    /**
     * Constante voor het challenge-commando
     */
    public static final String CHALLENGE = "challenge";

    /**
     * Constante voor het challenge-response-commando
     */
    public static final String CHALLENGE_RESPONSE = "challengeResponse";

    /**
     * Constante voor het can-be-challenged-commando
     */
    public static final String CAN_BE_CHALLENGED = "supportsChallenge";

    /**
     *
     */
    public static final String ONLINE = "online";

    /**
     * Constante voor highscore
     */
    public static final String HIGHSCORE = "highscore";

    public static final int ERROR_GENERIC = -1;
    public static final int ERROR_INVALID_LOGIN = 1;
    public static final int ERROR_GAME_FULL = 2;
    public static final int ERROR_TOO_LITTLE_PLAYERS = 3;
    public static final int ERROR_INVALID_MOVE = 4;
    public static final int ERROR_NO_SUCH_GAME = 5;
    public static final int ERROR_USER_HAS_NO_GAME = 6;
    public static final int ERROR_HANDSHAKE_MISSING = 7;
    public static final int ERROR_USER_ALREADY_HAS_GAME = 8;

    public static final int HIGHSCORE_UNAVAILABLE = -1;

    /**
     * Status om aan te geven dat de creator voortijdig is weggegaan
     */
    public static final int STATUS_PREMATURE_LEAVE = -1;

    /**
     * Status om aan te geven dat het spel nog niet is gestart.
     */
    public static final int STATUS_NOT_STARTED = 0;

    /**
     * Status om aan te geven dat het spel is gestart.
     */
    public static final int STATUS_STARTED = 1;

    /**
     * Antwoord op de handshake van de client. Moet altijd het eerst verzonden commando zijn, met uitzondering van
     * errors.
     * @requires Dat de handshake van de client is verzonden.
     * @requires Dat de handshake van de client niet een al ingelodge naam kiest.
     * @requires Dat de clientName niet begint met "player_"
     * @param supports Wat de server ondersteunt.
     * @param version Een beschrijving van wat de server kan
     */
    public abstract void handshake(int supports, String version) throws IOException;

    /**
     * Antwoord op de handshake van de client. Moet altijd het eerst verzonden commando zijn, met uitzondering van
     * errors.
     * @requires Dat de requirements van de eerste overload zijn voldaan.
     * @requires Dat de clientName juist wel begint met "player_"
     * @param supports
     * @param version
     * @param nonce
     * @throws IOException
     */
    public abstract void handshake(int supports, String version, String nonce) throws IOException;

    /**
     * Antwoord op het auth-pakket van de client.
     * @requires Dat de handshake is gedaan.
     * @requires Dat de client een juist gesignde nonce heeft gestuurd.
     * @requires Dat de nonce gesigned is met de juiste public-key volgens ss-security.student.utwente.nl
     * @throws IOException
     */
    public abstract void authOk() throws IOException;

    /**
     * Commando om de client te laten weten dat hij iets fout heeft gedaan, waardoor de verbinding moet worden
     * verbroken.
     * @requires Dat de client iets fout heeft gedaan...
     * @requires Dat dit het enige en eerste pakket na de fout is.
     * @param errorCode De error-code, op te zoeken in de errorCode-tabel.
     */
    public abstract void error(int errorCode) throws IOException;

    /**
     * Commando om de client te laten weten dat er óf een nieuw spel is, óf dat er een spel is veranderd in status.
     * Clients krijgen een serie van deze commando's na de handshake om zo een lijst van alle spellen op te bouwen. Als
     * er daarna iets verandert aan het aantal spelers of dat het spel is begonnen moet de server weer een update
     * sturen.
     * @requires Dat de handshake is gedaan.
     * @requires Dat óf het spel in hasStarted-status is veranderd, óf in aantal spelers is veranderd, óf dat de client
     * nog niet de volledige lijst met spellen heeft ontvangen direct na de handshake.
     * @param creator De maker van het spel.
     * @param status De status van het spel.
     * @param noPlayers Het aantal spelers in het spel.
     */
    public abstract void game(String creator, int status, int noPlayers) throws IOException;

    /**
     * Commando om een spel te starten met twee spelers, die in die volgorde een zet moeten doen.
     * @requires Dat de handshake is gedaan.
     * @requires Dat de speler in een spel zit.
     * @requires Dat de creator van het spel het spel heeft gestart.
     * @requires Dat dit bericht nog niet is gestuurd voor dit spel.
     * @param playerOne De eerste speler
     * @param playerTwo De tweede speler
     */
    public abstract void start(String playerOne, String playerTwo) throws IOException;

    /**
     * Commando om een spel te starten met drie spelers, die in die volgorde een zet moeten doen.
     * @requires Dat de requirements bij de eerste overload zijn voldaan.
     * @param playerOne De eerste speler
     * @param playerTwo De tweede speler
     * @param playerThree De derde speler
     */
    public abstract void start(String playerOne, String playerTwo, String playerThree) throws IOException;

    /**
     * Commando om een spel te starten met vier spelers, die in die volgorde een zet moeten doen.
     * @requires Dat de requirements bij de eerste overload zijn voldaan.
     * @param playerOne De eerste speler
     * @param playerTwo De tweede speler
     * @param playerThree De derde speler
     * @param playerFour De vierde speler
     */
    public abstract void start(String playerOne, String playerTwo, String playerThree, String playerFour) throws IOException;

    /**
     * Commando om de client te vertellen dat hij een zet moet gaan doen.
     * @requires Dat de handshake is gedaan.
     * @requires Dat de speler in een spel zit.
     * @requires Dat het spel is gestart.
     * @requires Dat de speler ook echt aan de beurt is.
     */
    public abstract void move() throws IOException;

    /**
     * Commando om de client te laten weten dat iemand een zet heeft gedaan in het huidige spel.
     * @requires Dat de handshake is gedaan.
     * @requires Dat de speler in een spel zit.
     * @requires Dat het spel is gestart.
     * @requires Dat de speler die zet heeft gedaan
     * @param name Naam van de speler die de zet heeft gedan.
     * @param x X-coördinaat, waarbij de linkerkant 0 is en de rechterkant 7.
     * @param y Y-coördinaat, waarbij de bovenkant 0 is en de onderkant 7.
     */
    public abstract void moveDone(String name, int x, int y) throws IOException;

    /**
     * Commando om de client te laten weten dat het spel is afgelopen, om welke reden dan ook. Eventueel zijn er
     * winnaars als het spel helemaal is voltooid. De server mag bepalen wat er gebeurt als er meerdere mensen dezelfde
     * score hebben.
     * @requires Dat de handshake is gedaan.
     * @requires Dat de speler in een spel zit.
     * @requires Dat het spel is gestart.
     * @requires Dat:
     *           * Als het spel is gestart: ofwel het spel is afgelopen volgens de regels van de server ofwel één van de
     *                 mensen is weggegaan
     * @param score De hoogste score
     * @param winners De mensen met die score
     */
    public abstract void gameOver(int score, String[] winners) throws IOException;

    /**
     * Commando om de client op te hoogte te stellen van een chatbericht
     * @requires Dat de handshake is gedaan.
     * @requires Dat de speler dit bericht heeft verzonden.
     * @param name Afzender van het chatbericht
     * @param body Tekst van het chatbericht
     */
    public abstract void message(String name, String body) throws IOException;

    /**
     * Commando om de client op te hoogte te stellen van een uitdaging met twee mensen.
     * @requires Dat de handshake is gedaan.
     * @requires Dat de speler niet is uitgedaagd.
     * @requires Dat de speler niet in een spel zit.
     * @requires Dat de speler uitdaagbaar is.
     * @param challenger De uitdager
     */
    public abstract void challenge(String challenger, String other1) throws IOException;

    /**
     * Commando om de client op de hoogte te stellen van een uitdaging met drie mensen
     * @requires Dat de requirements bij de eerste overload zijn voldaan.
     * @param challenger De uitdager
     * @param other1 Andere gebruiker
     */
    public abstract void challenge(String challenger, String other1, String other2) throws IOException;

    /**
     * Commando om de client op de hoogte te stellen van een uitdaging met vier mensen
     * @requires Dat de requirements bij de eerste overload zijn voldaan.
     * @param challenger De uitdager
     * @param other1 Andere gebruiker 1
     * @param other2 Andere gebruiker 2
     */
    public abstract void challenge(String challenger, String other1, String other2, String other3) throws IOException;

    /**
     * Commando om mensen die in een uitdaging zitten op de hoogte te stellen van de status van de uitgedaagden.
     * @requires Dat de handshake is gedaan.
     * @requires Dat de client is uitgedaagd.
     * @param name Naam van de uitgedaagde.
     * @param accept Of deze persoon accepteert.
     */
    public abstract void challengeResponse(String name, boolean accept) throws IOException;

    /**
     * Commando om de client op de hoogte te stellen van het veranderen van de status van iemand.
     * @requires Dat de handshake is gedaan.
     * @requires Dat de flag true is als de speler is uitgedaagd of een uitdager is.
     * @param name Naam van de uitgedaagde
     * @param flag Of hij kan worden uitgedaagd.
     */
    public abstract void canBeChallenged(String name, boolean flag) throws IOException;

    /**
     * Commando om de client op de hoogte te stellen van de gevraagde highscores.
     * @requires Dat de handshake is gedaan.
     * @requires Dat de client heeft gevraagd om highscores.
     * @requries Dat als het eerste argument van highscore een van player of date is, args respectievelijk van het
     * volgende formaat is:
     *  - lengte een met als enige argument een integer, de hoogste score van de speler
     *  - lengte twee met als eerste argument een speler en als tweede argument de score van die speler op de
     *    desbetreffende dag.
     * @param args Argumenten
     */
    public abstract void highscore(String[] args) throws IOException;

    /**
     * Commando om de client op de hoogte te stellen van een gebruiker die inlogt of weggaat
     * @requires Dat de handshake is gedaan
     * @requires Dat ófwel er een client bijkomt, ófwel er een client weggaat, ófwel dat de client de lijst met mensen
     * nog niet in zijn geheel heeft ontvangen na de lijst van spellen. Dit laatste is geen requirement voor servers
     * zonder chat.
     */
    public abstract void online(String name, boolean isOnline) throws IOException;
}
package rolit.model.networking.server;

import rolit.model.networking.common.ProtocolException;

/**
 * De ClientHandler ten aanzien van de status van de game.
 * @author Pieter Bos
 */
public class GameClientHandlerState extends ClientHandlerState {
    private final String creator;
    private final ServerGame game;

    public GameClientHandlerState(ClientHandler handler, String creator) {
        super(handler);
        this.creator = creator;
        this.game = getHandler().getGameByCreator(creator);
    }

    public String getCreator() {
        return creator;
    }

    /**
     * Verandert de status van de game
     * @param packet het pakketje met de zet van de speler.
     * @return een nieuwe status van de game.
     */
    @Override
    public ClientHandlerState move(rolit.model.networking.client.MovePacket packet) throws ProtocolException {
        int index = game.getIndex(getHandler().getUser());

        if(!game.isLegalMove(packet.getX(), packet.getY())) {
            throw new ProtocolException("Client tried to do an illegal move", ServerProtocol.ERROR_INVALID_MOVE);
        }

        game.doMove(packet.getX(), packet.getY());
        getHandler().notifyMove(creator, packet.getX(), packet.getY());

        if(game.isGameOver()) {
            game.stop();
        } else {
            game.nextPlayer();
            game.getPlayers().get(game.getPlayer()).getClient().notifyDoMove();
        }

        return this;
    }

    @Override
    public ClientHandlerState notifyDoMove() {
        getHandler().write(new rolit.model.networking.server.MovePacket());
        return this;
    }

    @Override
    public ClientHandlerState notifyOfMove(String mover, int x, int y) {
        getHandler().write(new MoveDonePacket(mover, x, y));
        return this;
    }

    @Override
    public ClientHandlerState notifyOfGameChange(ServerGame updateGame) {
        super.notifyOfGameChange(updateGame);

        if(updateGame == game) {
            if(game.isStopped()) {
                getHandler().write(new GameOverPacket(game.getScore(), game.getWinners()));
                getHandler().notifyCanBeChallenged();
                return new GameLobbyClientHandlerState(getHandler());
            }
        }

        return this;
    }

    @Override
    public ClientHandlerState exit() {
        try {
            game.stop();
        } catch (ProtocolException e) {
            // TODO again, logging service.
            System.out.println("WTF?");
        }
        return null;
    }
}
package rolit.model.networking.server;

import rolit.model.networking.common.Packet;
import rolit.model.networking.common.PacketArgs;

/**
 * Het eerste pakketje wat gestuurd wordt.
 * @author Pieter Bos
 */

public class HandshakePacket extends Packet {
    private int supports;
    private String version;
    private String nonce;

    protected HandshakePacket() {

    }

    public HandshakePacket(int supports, String version, String nonce) {
        this.supports = supports;
        this.version = version;
        this.nonce = nonce;
    }

    public HandshakePacket(int supports, String version) {
        this(supports, version, null);
    }

    public int getSupports() {
        return supports;
    }

    public String getVersion() {
        return version;
    }

    public String getNonce() {
        return nonce;
    }

    /**
     * Zet de argumenten van het pakketje in variabele.
     * @param args de argumenten van het pakket.
     */
    @Override
    protected void readFromArgs(PacketArgs args) {
        this.supports = args.getInt(0);
        this.version = args.getString(1);
        this.nonce = args.getMultiString(2).length == 1 ? args.getMultiString(2)[0] : null;
    }

    /**
     * Geeft het type de argumetnten.
     * @return het type argument.
     */
    @Override
    protected PacketArgs.ArgumentType[] getArgumentTypes() {
        return new PacketArgs.ArgumentType[] { PacketArgs.ArgumentType.Integer, PacketArgs.ArgumentType.String, PacketArgs.ArgumentType.MultiString };
    }

    /**
     * Geeft de data van het pakket in een object array.
     * @return een object array van wat de server support, de versie en de nonce.
     */
    @Override
    protected Object[] getData() {
        return new Object[] { supports, version, nonce == null ? new String[] {  } : new String[] { nonce } };
    }
}
package rolit.model.networking.server;

import rolit.model.networking.client.StartGamePacket;
import rolit.model.networking.common.ProtocolException;

import java.util.LinkedList;

/**
 * De staat van de ClientHandler status van de challenger.
 * @author Pieter Bos
 */
public class ChallengerClientHandlerState extends ClientHandlerState {
    LinkedList<String> currentlyAccepted = new LinkedList<String>();

    public ChallengerClientHandlerState(ClientHandler handler, String[] challenged) {
        super(handler);
    }

    /**
     * Als de challenger de game start verandert de status van de clients.
     * @param packet een StartGame pakket.
     * @return een nieuwe ClientHandler met een nieuwe status.
     */
    @Override
    public ClientHandlerState startGame(StartGamePacket packet) throws ProtocolException {
        getHandler().createChallengeGame(currentlyAccepted);

        return new GameClientHandlerState(getHandler(), getHandler().getClientName());
    }

    /**
     * Stuurt een notification naar de challenger als een speler die gechallenged is reageert.
     * @param response de reactie van de speler op de challenge.
     * @param challenged de andere spelers die gechallenged zijn.
     * @return een nieuwe ClientHandler met een nieuwe status.
     */
    @Override
    public ClientHandlerState notifyChallengeResponseBy(boolean response, String challenged) {
        getHandler().write(new ChallengeResponsePacket(challenged, response));

        if(response) {
            currentlyAccepted.add(challenged);
        } else {
            currentlyAccepted.remove(challenged);
        }

        return this;
    }
}
package rolit.model.networking.server;

import rolit.model.networking.common.Packet;
import rolit.model.networking.common.PacketArgs;

/**
 * @author Pieter Bos
 */
public class HighscorePacket extends Packet {
    private String[] data;

    protected HighscorePacket() {

    }

    public HighscorePacket(String[] data) {
        this.data = data;
    }

    public String[] getDataField() {
        return data;
    }

    /**
     * Zet de argumenten van het pakketje in variabele.
     * @param args de argumenten van het pakket.
     */
    @Override
    protected void readFromArgs(PacketArgs args) {
        this.data = args.getMultiString(0);
    }

    /**
     * Geeft het type van het argument van het pakketje.
     * @return het type argument.
     */
    @Override
    protected PacketArgs.ArgumentType[] getArgumentTypes() {
        return new PacketArgs.ArgumentType[] { PacketArgs.ArgumentType.MultiString };
    }

    /**
     * Geeft de data van het pakket in een object array.
     * @return een object array van de data.
     */
    @Override
    protected Object[] getData() {
        return new Object[] { data };
    }
}
package rolit.model.networking.server;

import rolit.model.networking.client.ChallengePacket;
import rolit.model.networking.client.CreateGamePacket;
import rolit.model.networking.client.JoinGamePacket;
import rolit.model.networking.common.CommonProtocol;
import rolit.model.networking.common.ProtocolException;

/**
 * De ClientHandler status ten aanzien van de lobby.
 * @author Pieter Bos
 */
public class GameLobbyClientHandlerState extends ClientHandlerState {
    public GameLobbyClientHandlerState(ClientHandler handler) {
        super(handler);
    }

    /**
     * Verandert de status van de speler die challenged naar challenger.
     * @param packet het pakketje dat ontvangen is.
     * @return een nieuwe status voor de challenger.
     * @throws ProtocolException als er iets fout gaat wordt er een exceptie gegooid.
     */
    @Override
    public ClientHandlerState challenge(ChallengePacket packet) throws ProtocolException {
        getHandler().notifyChallenged(packet.getChallenged());
        getHandler().notifyCannotBeChallenged();
        return new ChallengerClientHandlerState(getHandler(), packet.getChallenged());
    }

    /**
     * Verandert de status van een client als de speler een spel joint.
     * @param packet het JoinGame pakketje dat van de client ontvangen wordt.
     * @return een nieuwe status van de client.
     * @throws ProtocolException als er iets fout gaat wordt er een exceptie gegooid.
     */
    @Override
    public ClientHandlerState joinGame(JoinGamePacket packet) throws ProtocolException {
        ServerGame game = getHandler().getGameByCreator(packet.getCreator());

        if(game == null) {
            throw new ProtocolException("Client tried to join a game that does not exist", ServerProtocol.ERROR_NO_SUCH_GAME);
        }

        if(game.getPlayerCount() >= CommonProtocol.MAXIMUM_PLAYER_COUNT) {
            throw new ProtocolException("Client tried to join a game that is already full", ServerProtocol.ERROR_GAME_FULL);
        }

        game.addPlayer(getHandler().getUser());

        getHandler().notifyCannotBeChallenged();

        return new WaitForGameClientHandlerState(getHandler(), packet.getCreator());
    }

    /**
     * Als de speler een game maakt wordt de speler in een wachtende status gezet.
     * @param packet het CreateGame pakktje ontvangen van de client.
     * @return een nieuwe status van de client.
     */
    @Override
    public ClientHandlerState createGame(CreateGamePacket packet) throws ProtocolException {
        getHandler().createGame();
        getHandler().notifyCannotBeChallenged();
        return new WaitForGameClientHandlerState(getHandler(), getHandler().getClientName());
    }

    /**
     * Verandert de status van een client als hij gechallenged wordt.
     * @param challenger de speler die challenged.
     * @param others de andere spelers die gechallenged zijn.
     * @return
     */
    @Override
    public ClientHandlerState notifyChallengedBy(String challenger, String[] others) {
        getHandler().write(new rolit.model.networking.server.ChallengePacket(challenger, others));
        getHandler().notifyCannotBeChallenged();
        return new ChallengedClientHandlerState(getHandler(), challenger, others);
    }

    /**
     * Verandert de status van de speler die gechallenged is na zijn reactie op de challenge.
     * @param response de reactie van de speler op de challenge.
     * @param challenged de speler.
     * @return een nieuwe status van de client.
     */
    @Override
    public ClientHandlerState notifyChallengeResponseBy(boolean response, String challenged) {
        getHandler().write(new ChallengeResponsePacket(challenged, response));
        return this;
    }

    @Override
    public ClientHandlerState exit() {
        return null;
    }

    /**
     * De enige staat waarin een client gechallenged kan worden.
     * @return true
     */
    @Override
    public boolean canBeChallenged() {
        return true;
    }
}
package rolit.model.networking.server;

import rolit.model.networking.common.Packet;
import rolit.model.networking.common.PacketArgs;

/**
 * Het pakketje dat gestuurd wordt als de authenticatie gelukt is.
 * @author Pieter Bos
 */
public class AuthOkPacket extends Packet {
    public AuthOkPacket() {

    }

    /**
     *
     * @param args de argumenten van het pakket.
     */
    @Override
    protected void readFromArgs(PacketArgs args) {

    }

    /**
     * Geeft het type van het argument van het pakketje.
     * @return type argument.
     */
    @Override
    protected PacketArgs.ArgumentType[] getArgumentTypes() {
        return new PacketArgs.ArgumentType[] {  };
    }

    /**
     * Geeft de data van het pakket in een object array.
     * @return een object array van de argumenten van het pakketje.
     */
    @Override
    protected Object[] getData() {
        return new Object[] {  };
    }
}
package rolit.model.networking.server;

import rolit.model.networking.common.Packet;
import rolit.model.networking.common.PacketArgs;

/**
 * Het pakketje wat verstuurd wordt als een speler een zet heeft gedaan.
 * @author Pieter Bos
 */
public class MoveDonePacket extends Packet {
    private String user;
    private int x;
    private int y;

    protected MoveDonePacket() {

    }

    public MoveDonePacket(String user, int x, int y) {
        this.user = user;
        this.x = x;
        this.y = y;
    }

    public String getUser() {
        return user;
    }

    public int getX() {
        return x;
    }

    public int getY() {
        return y;
    }

    /**
     * Zet de argumenten van het pakketje in variabele.
     * @param args de argumenten van het pakket.
     */
    @Override
    protected void readFromArgs(PacketArgs args) {
        this.user = args.getString(0);
        this.x = args.getInt(1);
        this.y = args.getInt(2);
    }

    /**
     * Geeft het type van de argumenten van het pakketje.
     * @return het type argument.
     */
    @Override
    protected PacketArgs.ArgumentType[] getArgumentTypes() {
        return new PacketArgs.ArgumentType[] { PacketArgs.ArgumentType.String, PacketArgs.ArgumentType.Integer, PacketArgs.ArgumentType.Integer };
    }

    /**
     * Geeft de data van het pakket in een object array.
     * @return een object array met de speler, en de coördinaten van de zet.
     */
    @Override
    protected Object[] getData() {
        return new Object[] { user, x, y };
    }
}
package rolit.model.networking.client;

import rolit.model.networking.common.CommonProtocol;

/**
 * Het deel van het protocal dat alleen voor de client nodig is.
 * @author Pieter Bos
 * @author Martijn de Bijl
 *
 * Abstract class met alle constanten en methodes die gebruikt kunnen worden
 */
public abstract class ClientProtocol extends CommonProtocol {
    /**
     * Constante voor het handshake-commando
     */
    public static final String HANDSHAKE = "hello";

    /**
     * Constante voor het auth-commando
     */
    public static final String AUTH = "auth";

    /**
     * Constante voor het create-gamecommando
     */
    public static final String CREATE_GAME = "createGame";

    /**
     * Constante voor het join-gamecommando
     */
    public static final String JOIN_GAME = "joinGame";

    /**
     * Constante voor het start-gamecommando
     */
    public static final String START_GAME = "startGame";

    /**
     * Constante voor het movecommando
     */
    public static final String MOVE = "move";

    /**
     * Constante voor het messagecommando
     */
    public static final String MESSAGE = "message";

    /**
     * Constante voor het challengecommando
     */
    public static final String CHALLENGE = "challenge";

    /**
     * Constante voor het challenge-responsecommando
     */
    public static final String CHALLENGE_RESPONSE = "challengeResponse";

    /**
     * Constante voor het highscorecommando
     */
    public static final String HIGHSCORE = "highscore";

    /**
     * Constant voor het errorcommando
     */
    public static final String ERROR = "error";

    public static final int ERROR_GENERIC = -1;

    /**
     * Handshake voor de server. Moet altijd het eerste verzonden pakket zijn, met uitzondering van de errors.
     * @requires Dat de handshake nog niet is ontvangen
     * @requires Dat dit het eerste pakket op de communicatelijn is.
     * @param clientName Naam van de client.
     * @param supports Wat de client ondersteunt.
     * @param version Een beschrijving van wat de client kan.
     */
    public abstract void hello(String clientName, int supports, String version);

    /**
     * Authenticatie van de client.
     * @requires Dat de handshake is gedaan.
     * @requires Dat de client de private key heeft opgehaald bij ss-security.student.utwente.nl met de verstuurde
     * private key en bijbehorend wachtwoord.
     * @requires Dat de nonce die door de server is gestuurd is gesigned met de private key.
     * @param signature De gesignde nonce
     */
    public abstract void auth(String signature);

    /**
     * Maak een spel
     * @requires Dat de handshake is gedaan.
     * @requires Dat de client nog geen spel is begonnen
     */
    public abstract void createGame();

    /**
     * Join een spel
     * @requires Dat de handshake is gedaan.
     * @requires Dat de speler nog niet in een spel zit.
     * @requires Dat het spel nog niet vol zit.
     * @param creator De maker van het spel
     */
    public abstract void joinGame(String creator);

    /**
     * @requires Dat de handshake is gedaan.
     * @requires Dat de speler in een spel zit.
     * @requires Dat de speler de creator van het spel is.
     * @requires Dat het spel nog niet is gestart.
     * Start het spel waarvan de gebruiker de creator is.
     */
    public abstract void startGame();

    /**
     * Doe een zet
     * @requires Dat de handshake is gedaan.
     * @requires Dat de speler in een spel zit
     * @requires Dat de speler een move-commando heeft ontvangen.
     * @param x X-coördinaat
     * @param y Y-coördinaat
     */
    public abstract void move(int x, int y);

    /**
     * @requires Dat de handshake is gedaan.
     * @requires Dat de server chat-berichten ondersteunt.
     * Stuur een bericht naar iedereen in de lobby of iedereen in het spel
     * @param body Het bericht
     */
    public abstract void message(String body);

    /**
     * Daag één ander uit voor een spel
     * @requires Dat de handshake is gedaan.
     * @requires Dat de speler niet in een spel zit.
     * @requires Dat de speler niet een uitdager is.
     * @requires Dat de speler niet al is uitgedaagd.
     * @requires Dat de uitgedaagde(n) kunnen worden uitgedaagd.
     * @param other De ander
     */
    public abstract void challenge(String other);

    /**
     * Daag twee anderen uit voor een spel
     * @requires Dat de requirements bij de andere overload worden voldaan.
     * @param other1 De een
     * @param other2 De ander
     */
    public abstract void challenge(String other1, String other2);

    /**
     * Daag drie anderen uit voor een spel
     * @requires Dat de requirements bij de andere overload worden voldaan.
     * @param other1 De eerste andere
     * @param other2 De tweede andere
     * @param other3 De derder andere
     */
    public abstract void challenge(String other1, String other2, String other3);

    /**
     * Reageer op een uitdaging
     * @requires Dat de handshake is gedaan.
     * @requires Dat de speler is uitgedaagd.
     * @param accept Of de client accepteert
     */
    public abstract void challengeResponse(boolean accept);

    /**
     * Vraag highscores op bij de server
     * @requires Dat de handshake is gedaan
     * @requires Dat wanneer het type één van "date" of "player" is, arg respectievelijk van het volgende formaat is:
     *           * yyyy-[m]m-[d]d
     *           * SpelerNaamZonderSpaties
     * @param type Type highscore (bijv. date, player)
     * @param arg Een argument (bijv. 2014-01-01)
     */
    public abstract void highscore(String type, String arg);

    /**
     * Commando om de server te laten weten dat hij iets fout heeft gedaan, waardoor de verbinding moet worden verbroken.
     * @requires Dat de server iets fout heeft gedaan...
     * @requires Dat dit het enige en eerste pakket na de fout is.
     * @param errorCode De error-code, op te zoeken in de errorCode-tabel.
     */
    public abstract void error(int errorCode);
}
package rolit.model.networking.client;

import rolit.model.networking.common.Packet;
import rolit.model.networking.common.PacketArgs;

/**
 * Het pakketje waarmee een spel gestart wordt.
 * @author Pieter Bos
 */
public class StartGamePacket extends Packet {
    public StartGamePacket() {

    }

    /**
     * Het startGame pakket heeft geen argumenten.
     * @param args de argumenten van het pakket.
     */
    @Override
    protected void readFromArgs(PacketArgs args) {

    }

    /**
     * Geeft het type van het argument van het pakketje.
     * @return type argument.
     */
    @Override
    protected PacketArgs.ArgumentType[] getArgumentTypes() {
        return new PacketArgs.ArgumentType[] {  };
    }

    /**
     * Geeft de data van het pakket in een object array.
     * @return een object array met de argumenten van het pakket.
     */
    @Override
    protected Object[] getData() {
        return new Object[] {  };
    }
}
package rolit.model.networking.client;

import rolit.model.networking.common.Packet;
import rolit.model.networking.common.PacketArgs;

/** Het pakketje met een message voor de chat.
 * @author Pieter Bos
 */
public class MessagePacket extends Packet {
    private String message;

    protected MessagePacket() {

    }

    public MessagePacket(String message) {

        this.message = message;
    }

    public String getMessage() {
        return message;
    }

    /**
     * Zet de argumenten van het pakketje in variabele.
     * @param args de argumenten van het pakket.
     */
    @Override
    protected void readFromArgs(PacketArgs args) {
        this.message = args.getString(0);
    }

    /**
     * Geeft het type van het argument van het pakketje.
     * @return type argument.
     */
    @Override
    protected PacketArgs.ArgumentType[] getArgumentTypes() {
        return new PacketArgs.ArgumentType[] { PacketArgs.ArgumentType.String };
    }

    /**
     * Geeft de data van het pakket in een object array.
     * @return een data array van de message.
     */
    @Override
    protected Object[] getData() {
        return new Object[] { message };
    }
}
package rolit.model.networking.client;

public class ClientGame {
    private String creator;
    private int players;

    public ClientGame(String creator, int players) {
        this.creator = creator;
        this.players = players;
    }

    public String getCreator() {
        return creator;
    }

    public void setCreator(String creator) {
        this.creator = creator;
    }

    public int getPlayers() {
        return players;
    }

    public void setPlayers(int players) {
        this.players = players;
    }
}
package rolit.model.networking.client;

import rolit.model.networking.common.Packet;
import rolit.model.networking.common.PacketArgs;

/**
 * Het pakketje met de reactie op de challenge.
 * @author Pieter Bos
 */

public class ChallengeResponsePacket extends Packet {
    private boolean response;

    protected ChallengeResponsePacket() {

    }

    public ChallengeResponsePacket(boolean response) {
        this.response = response;
    }

    public boolean getResponse() {
        return response;
    }

    /**
     * Zet de argumenten van het pakket in variabele.
     * @param args de reactie op de challenge.
     */
    @Override
    protected void readFromArgs(PacketArgs args) {
        this.response = args.getBool(0);
    }

    /**
     * Geeft het type van het argument van het pakketje.
     * @return type argument.
     */
    @Override
    protected PacketArgs.ArgumentType[] getArgumentTypes() {
        return new PacketArgs.ArgumentType[] { PacketArgs.ArgumentType.Boolean };
    }

    /**
     * Geeft de data van het pakket in een object array.
     * @return een object array met de response van een speler.
     */
    @Override
    protected Object[] getData() {
        return new Object[] { response };
    }
}
package rolit.model.networking.client;

import rolit.model.networking.common.*;
import rolit.model.networking.common.ProtocolException;
import rolit.model.networking.server.CanBeChallengedPacket;
import rolit.model.networking.server.GamePacket;
import rolit.model.networking.server.OnlinePacket;
import rolit.util.Arrays;

import java.io.*;
import java.lang.reflect.Array;
import java.net.*;

public class ServerHandler {
    private static final String GLOBAL_VERSION = "PieterMartijn_Alpha1";
    private static final int GLOBAL_SUPPORTS = CommonProtocol.SUPPORTS_CHAT_CHALLENGE;
    private Socket socket;

    private static final Class[] IGNORE_TYPES = new Class[] {
            GamePacket.class,
            rolit.model.networking.server.MessagePacket.class,
            rolit.model.networking.server.ChallengePacket.class,
            OnlinePacket.class,
            CanBeChallengedPacket.class
    };

    private PrintStream output;
    private PacketSource source;
    private PacketInputStream input;
    private String hostName;
    private int port;

    public ServerHandler(String hostName, int port) throws IOException {
        this.hostName = hostName;
        this.port = port;
        socket = new Socket();
        socket.connect(new InetSocketAddress(InetAddress.getByName(hostName), port));

        source = new PacketSource(socket.getInputStream());
        input = source.createInputStream();
        output = new PrintStream(new BufferedOutputStream(socket.getOutputStream()), true, "UTF-8");
    }

    public PacketSource getSource() {
        return source;
    }

    private Packet readPacket() throws IOException, rolit.model.networking.common.ProtocolException {
        return input.readPacket();
    }

    public void handshake(String userName) {
        new HandshakePacket(userName, GLOBAL_SUPPORTS, GLOBAL_VERSION).writeTo(output);
    }

    public Packet expectPacket(Class<? extends Packet>[] expect) throws IOException, ProtocolException {
        Packet packet = readPacket();

        while(Arrays.contains(IGNORE_TYPES, packet.getClass())) {
            packet = readPacket();
        }

        for(Class<? extends Packet> c : expect) {
            if(c.isAssignableFrom(packet.getClass())) {
                return packet;
            }
        }

        throw new ProtocolException("De server stuurde een pakket dat de client niet verwachtte.");
    }

    public <T extends Packet> T expectPacket(Class<T> c) throws IOException, ProtocolException {
        return (T) expectPacket(new Class[] { c });
    }

    public PacketInputStream createPacketInputStream() {
        return source.createInputStream();
    }

    public void start() {
        source.start();
    }

    public void auth(String sign) {
        new AuthPacket(sign).writeTo(output);
    }

    public String getHostName() {
        return hostName;
    }

    public int getPort() {
        return port;
    }

    public void createGame() {
        new CreateGamePacket().writeTo(output);
    }

    public void joinGame(String creator) {
        new JoinGamePacket(creator).writeTo(output);
    }
}
package rolit.model.networking.client;

import rolit.model.networking.common.Packet;
import rolit.model.networking.common.PacketArgs;

/** Het pakket met de informatie waar de volgende zet gedaan moet worden.
 * @author Pieter Bos
 */

public class MovePacket extends Packet {
    private int x;
    private int y;

    protected MovePacket() {

    }

    public MovePacket(int x, int y) {
        this.x = x;
        this.y = y;
    }

    public int getX() {
        return x;
    }

    public int getY() {
        return y;
    }

    /**
     * Zet de argumenten van het pakket in variabele.
     * @param args de argumenten van het pakket.
     */
    @Override
    protected void readFromArgs(PacketArgs args) {
        this.x = args.getInt(0);
        this.y = args.getInt(1);
    }

    /**
     * Geeft het type van het argument van het pakketje.
     * @return type argument.
     */
    @Override
    protected PacketArgs.ArgumentType[] getArgumentTypes() {
        return new PacketArgs.ArgumentType[] { PacketArgs.ArgumentType.Integer, PacketArgs.ArgumentType.Integer };
    }

    /**
     * Geeft de data van het pakket in een object array.
     * @return een data array van de coördinaten.
     */
    @Override
    protected Object[] getData() {
        return new Object[] { x, y };
    }
}
package rolit.model.networking.client;

import rolit.model.networking.common.Packet;
import rolit.model.networking.common.PacketArgs;

/** Het pakket wat ervoor zorgt dat er een game gemaakt wordt.
 * @author Pieter Bos
 */
public class CreateGamePacket extends Packet {

    public CreateGamePacket() {

    }

    /**
     * Zet de argumenten van het pakket in variabele, CreateGame heeft geen argumenten.
     * @param args de argumenten van het pakket.
     */
    @Override
    protected void readFromArgs(PacketArgs args) {

    }

    /**
     * Geeft het type van het argument van het pakketje.
     * @return type argument.
     */
    @Override
    protected PacketArgs.ArgumentType[] getArgumentTypes() {
        return new PacketArgs.ArgumentType[] {  };
    }

    /**
     * Geeft de data van het pakket in een object array.
     * @return een object array met de data van het pakket
     */
    @Override
    protected Object[] getData() {
        return new Object[] {  };
    }
}
package rolit.model.networking.client;

import rolit.model.networking.common.Packet;
import rolit.model.networking.common.PacketArgs;

/** Het pakketje wat de challenge verstuurd naar spelers.
 * @author Pieter Bos
 */
public class ChallengePacket extends Packet {

    /**
     * De array met de spelers die gechallenged worden.
     */
    protected ChallengePacket() {

    }

    private String[] challenged;

    /**
     * De contructor van het pakktje.
     * @param challenged de spelers die gechallenged moeten worden.
     */
    public ChallengePacket(String[] challenged) {
        this.challenged = challenged;
    }

    /**
     * Zet de argumenten van het pakket in variabele.
     * @return de string gepresentatie van de spelers
     */
    public String[] getChallenged() {
        return challenged;
    }

    /**
     * Geeft de spelers die gechallenged zijn uit de argumenten van het pakket.
     * @param args de spelers.
     */
    @Override
    protected void readFromArgs(PacketArgs args) {
        this.challenged = args.getMultiString(0);
    }

    /**
     * Geeft het type van het argument van het pakketje.
     * @return type argument.
     */
    @Override
    protected PacketArgs.ArgumentType[] getArgumentTypes() {
        return new PacketArgs.ArgumentType[] { PacketArgs.ArgumentType.MultiString };
    }

    /**
     * Geeft het type van het argument van het pakketje.
     * @return type argument.
     */
    @Override
    protected Object[] getData() {
        return new Object[] { challenged };
    }
}
package rolit.model.networking.client;

import rolit.model.networking.common.Packet;
import rolit.model.networking.common.PacketArgs;

/** Het pakketje dat ervoor zorgt dat een speler een spel joint.
 * @author Pieter Bos
 */
public class JoinGamePacket extends Packet {

    private String creator;

    protected JoinGamePacket() {

    }

    public JoinGamePacket(String creator) {
        this.creator = creator;
    }

    public String getCreator() {
        return creator;
    }

    /**
     * Zet de argumenten van het pakket in variabele.
     * @param args de argumenten van het pakket.
     */
    @Override
    protected void readFromArgs(PacketArgs args) {
        this.creator = args.getString(0);
    }

    /**
     * Geeft het type van het argument van het pakketje.
     * @return type argument.
     */
    @Override
    protected PacketArgs.ArgumentType[] getArgumentTypes() {
        return new PacketArgs.ArgumentType[] { PacketArgs.ArgumentType.String };
    }

    /**
     * Geeft de data van het pakket in een object array.
     * @return een object array met de creator erin.
     */
    @Override
    protected Object[] getData() {
        return new Object[] { creator };
    }
}
package rolit.model.networking.client;

import rolit.model.networking.common.Packet;
import rolit.model.networking.common.PacketArgs;

/**
 * Het pakket dat als eerste wordt gestuurd, om de verbinding op te zetten.
 * @author Pieter Bos
 */
public class HandshakePacket extends Packet {
    private String name;
    private int supports;
    private String version;

    protected HandshakePacket() {

    }

    public HandshakePacket(String name, int supports, String version) {

        this.name = name;
        this.supports = supports;
        this.version = version;
    }

    public String getName() {
        return name;
    }

    public int getSupports() {
        return supports;
    }

    public String getVersion() {
        return version;
    }

    /**
     * Zet de argumenten van het pakket in variabele.
     * @param args de argumenten van het pakket.
     */
    @Override
    protected void readFromArgs(PacketArgs args) {
        this.name = args.getString(0);
        this.supports = args.getInt(1);
        this.version = args.getString(2);
    }

    /**
     * Geeft het type van het argument van het pakketje.
     * @return type argument.
     */
    @Override
    protected PacketArgs.ArgumentType[] getArgumentTypes() {
        return new PacketArgs.ArgumentType[] { PacketArgs.ArgumentType.String, PacketArgs.ArgumentType.Integer, PacketArgs.ArgumentType.String };
    }

    /**
     * Geeft het type van het argument van het pakketje.
     * @return type argument.
     */
    @Override
    protected Object[] getData() {
        return new Object[] { name, supports, version };
    }


}
package rolit.model.networking.client;

import rolit.model.networking.common.Packet;
import rolit.model.networking.common.PacketArgs;

/**
 * Het pakketje waarmee iemand zich kan autenticeren.
 * @author Pieter Bos
 */
public class AuthPacket extends Packet {
    private String cypherText;

    protected AuthPacket() {

    }

    public AuthPacket(String cypherText) {
        this.cypherText = cypherText;
    }

    public String getCypherText() {
        return cypherText;
    }

    /**
     * Zet de argumenten van het pakket in een variabele.
     * @param args de argumenten van het pakket.
     */
    @Override
    protected void readFromArgs(PacketArgs args) {
        this.cypherText = args.getString(0);
    }

    /**
     * Geeft het type van het argument van het pakketje.
     * @return type argument.
     */
    @Override
    protected PacketArgs.ArgumentType[] getArgumentTypes() {
        return new PacketArgs.ArgumentType[] { PacketArgs.ArgumentType.String };
    }

    /**
     * Geeft de data van het pakket in een object array.
     * @return een object array met ce cypherText.
     */
    @Override
    protected Object[] getData() {
        return new Object[] { cypherText };
    }
}
package rolit.model.networking.client;

import rolit.model.networking.common.Packet;
import rolit.model.networking.common.PacketArgs;

/** Het pakketje wat de highscores kan opvragen.
 * @author Pieter Bos
 */
public class HighscorePacket extends Packet {
    private String type;
    private String arg;

    protected HighscorePacket() {
        
    }

    public HighscorePacket(String type, String arg) {
        this.type = type;
        this.arg = arg;
    }

    public String getType() {
        return type;
    }

    public String getArg() {
        return arg;
    }

    /**
     * Zet de argumenten van het pakket in variabele.
     * @param args de argumenten van het pakket.
     */
    @Override
    protected void readFromArgs(PacketArgs args) {
        this.type = args.getString(0);
        this.arg = args.getString(1);
    }

    /**
     * Geeft het type van het argument van het pakketje.
     * @return type argument.
     */
    @Override
    protected PacketArgs.ArgumentType[] getArgumentTypes() {
        return new PacketArgs.ArgumentType[] { PacketArgs.ArgumentType.String, PacketArgs.ArgumentType.String };
    }

    /**
     * Geeft de data van het pakket in een object array.
     * @return een object array met de het type van de highscore, en het argument daarbij.
     */
    @Override
    protected Object[] getData() {
        return new Object[] { type, arg };
    }
}
package rolit.model.game;

import rolit.util.Strings;

import java.io.IOException;

/**
 * De interface van een speler
 * @author Martijn de Bijl
 */
public interface Player {

    /**
     * Geeft een kleur aan een speler aan de hand van de hoeveelste speler hij is.
     * @param nummer de integer die de van de speler aangeeft.
     */
    public void setColor(int nummer);

    /**
     * Geeft de kleur van de speler terug.
     * @return een integer die de kleur representeerd.
     */
    public int getColor();

    /**
     * Geeft de naam van de speler terug.
     * @return een string met de naam van de speler.
     */
    public String getNaam();

    /**
     * Bepaald wat de volgende zet zal worden.
     * @param board het bord waarop de zet zal worden gedaan.
     * @return een positie op het bord, dat een legale zet is.
     */
    public Position determineMove(Board board);

    /**
     * Doet de zet die bepaald is in determineMove.
     * @param board het bord waarop de zet gedaan wordt.
     */
    public void doMove(Board board);

}
package rolit.model.game;

import rolit.util.Strings;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Scanner;

/**
 * De klasse menselijke speler
 * @author Martijn de Bijl
 */
public class HumanPlayer implements Player{
    /**
     * De kleur van de speler
     */
    private int color;
    /**
     * De naam van de speler
     */
    private String naam;

    /**
     * Maakt een nieuwe menselijke speler met een naam.
     * @param naam de naam van de speler.
     */
    public HumanPlayer(String naam) {
        this.naam = naam;
    }

    /**
     * Geeft een kleur aan een speler aan de hand van de hoeveelste speler hij is.
     * @param nummer de integer die de van de speler aangeeft.
     */
    public void setColor(int nummer) {
        this.color = nummer;
    }

    /**
     * Geeft de kleur van de speler terug.
     * @return een integer die de kleur representeerd.
     */
    public int getColor() {
        return color;
    }

    /**
     * Geeft de naam van de speler terug.
     * @return een string met de naam van de speler.
     */
    public String getNaam() {
        return naam;
    }

    /**
     * Vraagt via de console om een x en een y coördinaat in te vullen.
     * @param board het bord waar de zet op gedaan zal worden.
     * @return een positie op het bord.
     */
    public Position determineMove(Board board) {
        String prompt = "> " + getNaam() + " (" + getColor() + ")" + ", what is your choice? ";
        Position choice = readPosition(prompt);
        boolean valid = board.isLegalMove(this.getColor(), choice);
        while (!valid) {
            System.out.println("ERROR: field " + choice + " is no valid choice.");
            choice = readPosition(prompt);
            valid = board.isLegalMove(this.getColor(), choice);
        }
        return choice;
    }

    public void doMove(Board board) {
        Position positie = determineMove(board);
        board.doMove(this.getColor(), positie);
    }

    /**
     * Leest de positie uit de console.
     * @param prompt de vraag die aan de speler gesteld word.
     * @return een positie die ingevuld is door de speler.
     */
    private Position readPosition(String prompt) {
        System.out.print(prompt);
        System.out.flush();
        String line = null;

        try {
            line = new BufferedReader(new InputStreamReader(System.in)).readLine();
        } catch (IOException e) {
            line = null;
        }

        return new Position(Integer.parseInt(line.split(" ")[0]), Integer.parseInt(line.split(" ")[1]));
    }

    public static void main(String[] args) {
        Board board = new Board();
        Player player = new HumanPlayer("Martijn");
        player.doMove(board);
        System.out.println(board.toString());

    }

}
package rolit.model.game.Test;

import org.junit.Before;
import org.junit.Test;
import rolit.model.game.*;

import static junit.framework.Assert.assertEquals;

/**
 * Test game.
 * @author Martijn de Bijl
 */
public class GameTest {

    private Game game2;
    private Game game3;
    private Game game4;


    @Before
    public void setUp() throws Exception {
        game2 = new Game(2);
        game3 = new Game(3);
        game4 = new Game(4);

        game2.addPlayer(new EasyComputerPlayer());
        game2.addPlayer(new HumanPlayer("Martijn"));

        game3.addPlayer(new EasyComputerPlayer());
        game3.addPlayer(new EasyComputerPlayer());
        game3.addPlayer(new EasyComputerPlayer());


        game4.addPlayer(new EasyComputerPlayer());
        game4.addPlayer(new EasyComputerPlayer());
        game4.addPlayer(new EasyComputerPlayer());
        game4.addPlayer(new EasyComputerPlayer());
    }

    @Test
    public void testGetBoard() throws Exception {
        Board board = new Board();
        game2.getBoard().equals(board);
    }

    @Test
    public void testGetCurrentPlayer() throws Exception {
        assertEquals(2,game2.getCurrentPlayer());
    }

    @Test
    public void testStart2() throws Exception {
        game2.start();
    }

    @Test
    public void testStart3() throws Exception {
        game3.start();
    }

    @Test
    public void testStart4() throws Exception {
        game4.start();
    }

    @Test
    public void testAddPlayer() throws Exception {
        game2.addPlayer(new EasyComputerPlayer());
    }


}
package rolit.model.game.Test;

import org.junit.Before;
import org.junit.Test;
import rolit.model.game.Board;
import rolit.model.game.HumanPlayer;
import rolit.model.game.Player;

import static junit.framework.Assert.assertEquals;

/**
 * Created by Martijn on 23-1-14.
 */
public class HumanPlayerTest {

    private Player player;
    private Board board;

    @Before
    public void setUp(){
        board = new Board();
        player = new HumanPlayer("Martijn");
    }

    @Test
    public void testSetColor() throws Exception {
        player.setColor(0);
        assertEquals(0, player.getColor());
    }

    @Test
    public void testGetColor() throws Exception {
        player.setColor(2);
        assertEquals(2,player.getColor());
    }

    @Test
    public void testGetNaam() throws Exception {
        assertEquals("Martijn", player.getNaam());
    }

    @Test
    public void testDetermineMove() throws Exception {
        player.determineMove(board);
    }

    @Test
    public void testDoMove() throws Exception {
        player.doMove(board);
    }
}
package rolit.model.game.Test;

import org.junit.Before;
import org.junit.Test;
import rolit.model.game.*;

import static junit.framework.Assert.*;

/**
 * De test die alle methoden test in board.
 * @author Martijn de Bijl
 */
public class BoardTest {
    private Board board;
    private Position position;
    private int player;

    /**
     *
     * @throws Exception
     */
    @Before
    public void setUp() throws Exception {
        board = new Board();
        position = new Position(5,5);
        Player p = new EasyComputerPlayer();
        p.setColor(0);
        player = p.getColor();
    }

    @Test
    public void testGetField() throws Exception {
        assertEquals(Board.EMPTY_FIELD, board.getField(position));
    }

    @Test
    public void testGetField1() throws Exception {
        assertEquals(Board.EMPTY_FIELD, board.getField(position));
    }

    @Test
    public void testSetField() throws Exception {
        board.setField(2,2,0);
        assertEquals(0,board.getField(2,2));
    }

    @Test
    public void testSetField1() throws Exception {
        board.setField(position, 0);
        assertEquals(0, board.getField(position));
    }

    @Test
    public void testSetField2() throws Exception {
        try {
            board.setField(new Position(9, 20), 0);
            fail();
        } catch(ArrayIndexOutOfBoundsException e) {

        }
    }

    @Test
    public void testIsEmpty() throws Exception {
        assertTrue(board.isEmpty(5,5));
    }

    @Test
    public void testIsEmpty1() throws Exception {
        assertTrue(board.isEmpty(position));
    }

    @Test
    public void testCopy() throws Exception {
        assertEquals(board, board.copy());
    }

    @Test
    public void testGetCapture() throws Exception {
        Capture capture = new Capture(new Position(-1,1), 1);
        Capture [] captures = board.getCapture(player, position);
        capture.equals(captures[0]);
    }

    @Test
    public void testIsLegalMove() throws Exception {
        Position position = new Position(5,5);
        assertTrue(board.isLegalMove(player, position));
    }

    @Test
    public void testIsLegalMove1() throws Exception {
        Position position = new Position(6,6);
        assertFalse(board.isLegalMove(player, position));
    }

    @Test
    public void testIsLegalMove2() throws Exception {
        Position position = new Position(-1,-1);
        assertFalse(board.isLegalMove(player, position));
    }

    @Test
    public void testDoMove() throws Exception {
        assertTrue(board.doMove(player, position));
        assertEquals(0, board.getField(4,4));
    }

    @Test
    public void testGameOver() throws Exception {
        for (int y = 0; y < Board.BOARD_HEIGHT; y++){
            for (int x = 0; x < Board.BOARD_WIDTH; x++){
                board.setField(x,y, 0);
            }
        }
        assertTrue(board.gameOver());
    }

    @Test
    public void testGameOver1() throws Exception {
        for (int y = 0; y < Board.BOARD_HEIGHT; y++){
            for (int x = 0; x < (Board.BOARD_WIDTH - 1); x++){
                board.setField(x,y, 0);
            }
        }
        assertFalse(board.gameOver());
    }

    @Test
    public void testDetermineWinner() throws Exception {
        for (int y = 0; y < Board.BOARD_HEIGHT; y++){
            for (int x = 0; x < Board.BOARD_WIDTH; x++){
                board.setField(x,y, 0);
            }
        }
        assertEquals(1, board.determineWinners().length);
    }

    @Test
    public void testGetHighScore() throws Exception{
        board.determineWinners();
        assertEquals(1,board.getHighScore());
    }

    public void testDetermineWinner1() throws Exception {
        Integer[] winners = board.determineWinners();
        assertEquals(2, (int)winners[2]);
    }

}
package rolit.model.game;

/**
 * Een positie met een x en y coördinaat.
 * Created by Martijn on 20-1-14.
 */
public class Position {

    /**
     * De y coördinaat van de positie.
     */
    private int y;
    /**
     * De x coördinaat van de positie.
     */
    private int x;

    /**
     * Maakt een nieuwe positie.
     * @param x de x-coördinaat van de positie, oftwel de horizontale plaats van de positie.
     * @param y de y-coördinaat van de positie, oftewel de verticale plaats van de positie.
     */
    public Position(int x, int y){
        this.x = x;
        this.y = y;
    }

    /**
     * Geeft de x coördinaat terug van de positie.
     * @return de integer van de x-coördinaat
     */
    public int getX(){
        return x;
    }

    /**
     * Geeft de y coördinaat terug van de positie.
     * @return de integer van de y-coördinaat.
     */
    public int getY(){
        return y;
    }

    /**
     * Telt twee posities bij elkaar op.
     * @param direction de andere positie die erbij wordt opgeteld.
     * @return een nieuwe positie, met nieuwe coördinaten.
     */
    public Position add(Position direction) {
        Position result = new Position(this.getX() + direction.getX(), this.getY() + direction.getY());
        return result;
    }

    public boolean outOfBounds(){
        return getX() >= Board.BOARD_WIDTH || getY() >= Board.BOARD_HEIGHT || getX() < 0 || getY() < 0;
    }

}
package rolit.model.game;

import java.util.LinkedList;
import java.util.Random;

/**
 * De klasse makkelijke computer tegenstander.
 * @author Martijn de Bijl
 */
public class EasyComputerPlayer implements Player {
    /**
     * De kleur van de computer speler.
     */
    private int color;
    /**
     * De naam de de computer speler.
     */
    private final String naam = "Easy computer";

    /**
     * De constructor van de computer speler.
     */
    public EasyComputerPlayer() {

    }

    /**
     * Geeft een kleur aan een speler aan de hand van de hoeveelste speler hij is.
     * @param nummer de integer die de van de speler aangeeft.
     */
    public void setColor(int nummer) {
        this.color = nummer;
    }

    /**
     * Geeft de kleur terug van de computer speler.
     * @return een integer die de kleur van de speler representateerd.
     */
    public int getColor() {
        return color;
    }

    /**
     * Geeft de naam van de computer speler terug.
     * @return een string van de naam, altijd Easy computer.
     */
    public String getNaam() {
        return naam;
    }

    /**
     * Bepaald de volgende zet op een bepaald bord.
     * @param board het bord waarop de zet zal worden gedaan.
     * @return een positie op het bord.
     */
    public Position determineMove(Board board) {
        LinkedList<Position> possibleMoves = new LinkedList<Position>();
        for (int y = 0; y < Board.BOARD_HEIGHT; y++) {
            for (int x = 0; x < Board.BOARD_WIDTH; x++) {
                Position position = new Position(x, y);
                if (board.isLegalMove(this.getColor(), position)) {
                    possibleMoves.add(position);
                }
            }
        }
        Random random = new Random();
        Position randomPosition = possibleMoves.get(random.nextInt(possibleMoves.size()));
        return randomPosition;
    }

    /**
     * Doet de zet bepaald met determineMove.
     * @param board het bord waarop de zet gedaan wordt.
     */
    public void doMove(Board board) {
        board.doMove(this.getColor(), determineMove(board));
    }
}
package rolit.model.game;

import java.io.IOException;

/**
 * Start het spel, houdt de spelers en het bord bij.
 * @author Martijn de Bijl
 */
import rolit.model.networking.common.ProtocolException;
import rolit.model.networking.server.User;

import java.util.LinkedList;

public class Game {
    /**
     * Aantal spelers in het spel.
     */
    private final int players;

    /**
     * Het bord wat bij het spel hoort.
     */
    private final Board board;

    /**
     * De speler die nu aan de beurt is.
     */
    private int currentPlayer;

    private Player[] playerArray;

    /**
     * Maakt een nieuwe game, met een nieuw bord.
     *
     * @param players het aantal spelers.
     */
    public Game(int players) {
        this.players = players;
        board = new Board();
        currentPlayer = 0;
        playerArray = new Player[players];
    }

    /**
     * Geeft het bord wat bij dit spel hoort.
     *
     * @return het bord.
     */
    public Board getBoard() {
        return board;
    }

    /**
     * Geeft de speler die nu aan de beurt is terug.
     *
     * @return de integer die de speler aangeeft.
     */
    public int getCurrentPlayer() {
        return currentPlayer;
    }

    /**
     * Start het spel, en laat de spelers spelen, zolang het bord niet vol is.
     */
    public void start() throws ProtocolException {
        while (!board.gameOver()) {
            playerArray[currentPlayer].doMove(board);
            currentPlayer = (currentPlayer + 1) % players;
            System.out.println(board.toString());
        }
        if (board.gameOver()) {
            System.out.println(board.determineWinners());
        }
    }

    /**
     * Voegt de speler toe aan het spel.
     * @param player de speler die toegevoegd wordt.
     */
    public void addPlayer(Player player) throws GameFullException {
        if(currentPlayer >= players){
            throw new GameFullException();
        }
        else {
            playerArray[currentPlayer] = player;
            player.setColor(currentPlayer);
            currentPlayer = currentPlayer + 1;
        }
    }

    public void nextPlayer() {
        currentPlayer = (currentPlayer + 1) % players;
    }
}
package rolit.model.game;

/**
 * Created by Martijn on 23-1-14.
 */
public class GameFullException extends Exception {


}
package rolit.model.game;

import rolit.view.client.MainView;

import java.util.LinkedList;
import java.util.List;
import java.util.Objects;

/**
 * The board class
 *
 * @author Martijn de Bijl
 */
public class Board {
    /**
     * De standaard hoogte voor het bord.
     */
    public static final int BOARD_WIDTH = 8;
    /**
     * De standaard breedte van het bord.
     */
    public static final int BOARD_HEIGHT = 8;
    /**
     * De variabele die een leeg veld aangeeft.
     */
    public static final int EMPTY_FIELD = 9;

    /**
     * De array waarin de informatie van het bord is opgeslagen.
     */
    private int[][] array;

    /**
     * Alle richtingen waarin gekeken moet worden naar aanliggende velden.
     */
    private static Position[] DIRECTIONS = {
            new Position(-1, -1),
            new Position(-1, 0),
            new Position(-1, 1),
            new Position(1, 0),
            new Position(1, -1),
            new Position(1, 1),
            new Position(0, 1),
            new Position(0, -1)
    };

    /**
     * Constructor voor klasse bord. Hierin wordt de array aangemaakt en gevuld met legen velden en de 4 balletje in
     * het midden.
     */
    public Board() {
        array = new int[BOARD_WIDTH][BOARD_HEIGHT];
        for (int x = 0; x < BOARD_WIDTH; x++) {
            for (int y = 0; y < BOARD_HEIGHT; y++) {
                array[x][y] = EMPTY_FIELD;
                array[x][y] = EMPTY_FIELD;
            }
        }
        array[3][3] = 0;
        array[4][3] = 1;
        array[4][4] = 2;
        array[3][4] = 3;
    }

    /**
     * Geeft terug waarmee een bepaald veld gevuld is.
     *
     * @param x de x-coördinaat, oftewel horizontale positie op het bord.
     * @param y de y-coördinaat, oftwel vericale positie op het bord.
     * @return geeft een integer terug die de kleur van de speler, of een leeg veld aangeeft.
     */
    public int getField(int x, int y) {
        return array[x][y];
    }

    /**
     * Geeft terug waarmee een bepaald veld gevuld is.
     *
     * @param position de positie van het veld, gegeven in een vector met een x en y coördinaat.
     * @return geeft een integer terug die de kleur van de speler, of een leeg veld aangeeft.
     */
    public int getField(Position position) {
        int x = (position.getX());
        int y = (position.getY());
        return array[x][y];
    }

    /**
     * Vult een bepaald veld met een kleur van een speler.
     *
     * @param x     de x-coördinaat, oftewel horizontale positie op het bord.
     * @param y     de y-coördinaat, oftwel vericale positie op het bord.
     * @param field de integer die de kleur van de speler aangeeft.
     */
    public void setField(int x, int y, int field) {
        array[x][y] = field;
    }

    /**
     * Vult een bepaald veld met een kleur van een speler.
     *
     * @param position de positie van het veld, gegeven in een vector met een x en y coördinaat.
     * @param color    de integer die de kleur van de speler aangeeft.
     */
    public void setField(Position position, int color) {
        array[position.getX()][position.getY()] = color;
    }

    /**
     * Geeft terug of een veld leeg is.
     *
     * @param x de x-coördinaat, oftewel horizontale positie op het bord.
     * @param y de y-coördinaat, oftwel vericale positie op het bord.
     * @return een boolean of het veld leeg is.
     */
    public boolean isEmpty(int x, int y) {
        return array[x][y] == EMPTY_FIELD;
    }

    /**
     * Geeft terug of een veld leeg is.
     *
     * @param position de positie van het veld, gegeven in een vector met een x en y coördinaat.
     * @return een boolean of het veld leeg is.
     */
    public boolean isEmpty(Position position) {
        return array[position.getX()][position.getY()] == EMPTY_FIELD;
    }

    /**
     * Maakt een kopie van het huidige bord.
     *
     * @return een nieuw bord met alle informatie van het huidige bord.
     */
    public Board copy() {
        Board copy = new Board();
        for (int x = 0; x < BOARD_WIDTH; x++) {
            for (int y = 0; y < BOARD_HEIGHT; y++) {
                copy.setField(x, y, getField(x, y));
            }
        }
        return copy;
    }

    /**
     * Kijkt op een bepaald veld in alle richtingen welke slagen mogelijk zijn.
     *
     *
     * @param player       de speler die de zet wil doen.
     * @param movePosition het veld waarop de speler de zet wil doen.
     * @return een array met alle slagen die mogelijk zijn.
     */
    public Capture[] getCapture(int player, Position movePosition) {
        Position position = new Position(movePosition.getX(), movePosition.getY());
        LinkedList<Capture> captures = new LinkedList<Capture>();
        int length = 0;

        if (!isEmpty(position)) {
            Capture[] capture = new Capture[0];
            return capture;
        } else {
            for (Position direction : DIRECTIONS) {
                length = 1;

                Position checkField = new Position(position.add(direction).getX(), position.add(direction).getY());

                while (!checkField.outOfBounds() && this.getField(checkField) != player && this.getField(checkField) != EMPTY_FIELD) {
                    checkField = checkField.add(direction);
                    length++;
                }

                if (!checkField.outOfBounds() && this.getField(checkField) == player && length > 1) {
                    captures.add(new Capture(direction, length));
                }

            }

            Capture[] result = new Capture[captures.size()];
            captures.toArray(result);
            return result;
        }
    }

    /**
     * Kijkt of een zet legaal is.
     *
     * @param player       de speler die de zet wil doen.
     * @param movePosition het veld waarop de speler de zet wil doen.
     * @return een boolean of de zet legaal is.
     */
    public boolean isLegalMove(int player, Position movePosition) {

        if (movePosition.outOfBounds()) {
            return false;
        }

        Capture[] captures = getCapture(player, movePosition);

        if (captures.length != 0) {
            return true;
        }

        for (int y = 0; y < BOARD_HEIGHT; y++) {
            for (int x = 0; x < BOARD_WIDTH; x++) {
                Position checkField = new Position(x, y);
                if (getCapture(player, checkField).length > 0) {
                    System.out.println("Move is illegal because " + x + ", " + y + " has " + getCapture(player, checkField).length + " captures");
                    return false;
                }
            }
        }

        if (hasSurroundingFields(movePosition)){
            return true;
        }

        return false;
    }

    private boolean hasSurroundingFields(Position movePosition) {
        for (Position direction : DIRECTIONS){
            if (!movePosition.add(direction).outOfBounds()){
                if (getField(movePosition.add(direction)) != EMPTY_FIELD){
                    return true;
                }
            }
        }
       return false;
    }

    /**
     * Doet de zet van een speler, en verandert alle kleuren naar zijn kleur van de geslagen balletjes.
     *
     * @param player       de speler die de zet doet.
     * @param movePosition het veld waarop de speler de zet wil doen.
     * @return een boolean of de zet gelukt is.
     */
    public boolean doMove(int player, Position movePosition) {
        if (isLegalMove(player, movePosition)) {
            Capture[] captures = getCapture(player, movePosition);
            setField(movePosition, player);

            for (Capture capture : captures) {
                for (int i = 0; i <= captures.length; i++) {
                    int x = (movePosition.getX() + i * (capture.getDirection().getX()));
                    int y = (movePosition.getY() + i * (capture.getDirection().getY()));
                    Position seize = new Position(x, y);
                    if (!seize.outOfBounds()) {
                        setField(seize, player);
                    }
                }
            }
            return true;
        } else {
            return false;
        }
    }

    /**
     * Maakt een visuele representatie van het huidige bord.
     *
     * @return een string zo geformat dat het bord leesbaar is.
     */
    public String toString() {
        String result = "+-+-+-+-+-+-+-+-+\n";
        for (int y = 0; y < BOARD_HEIGHT; y++) {
            boolean first = true;

            for (int x = 0; x < BOARD_WIDTH; x++) {
                if (first) {
                    result += "|";
                }

                first = false;

                result += getField(x, y) == EMPTY_FIELD ? " " : getField(x, y);

                result += "|";
            }

            result += "\n+-+-+-+-+-+-+-+-+\n";
        }
        return result;
    }

    /**
     * Kijkt of alle velden gevuld zijn, dus of het spel is afgelopen.
     *
     * @return een boolean of het spel al voorbij is.
     */
    public boolean gameOver() {
        boolean gameOver = true;

        for (int y = 0; y < BOARD_HEIGHT; y++) {
            for (int x = 0; x < BOARD_WIDTH; x++) {
                if (getField(x, y) == EMPTY_FIELD) {
                    gameOver = false;
                }
            }
        }

        return gameOver;
    }

    public int getHighScore(){
        Integer[] winnaars = determineWinners();
        int winner = (int)winnaars[0];
        int highScore = 0;
        for (int y = 0; y < BOARD_HEIGHT; y++){
            for (int x = 0; x < BOARD_WIDTH; x++){
                if (getField(x,y) == winner){
                    highScore++;
                }
            }
        }
        return highScore;
    }

    /**
     * Bepaald de winneer van het spel, als het spel is afgelopen.
     *
     * @return een integer die de kleur van de winnaar representateerd.
     */
    public Integer[] determineWinners() {
        int rood = 0;
        int geel = 0;
        int groen = 0;
        int blauw = 0;

        if (gameOver() == true) {
            for (int y = 0; y < BOARD_HEIGHT; y++) {
                for (int x = 0; x < BOARD_WIDTH; x++) {
                    if (getField(x, y) == 0) {
                        rood++;
                    } else if (getField(x, y) == 1) {
                        geel++;
                    } else if (getField(x, y) == 2) {
                        groen++;
                    } else {
                        blauw++;
                    }
                }
            }

        }

        int max = -1;
        List<Integer> result = new LinkedList<Integer>();
        int[] data = {rood, geel, groen, blauw};

        for (int i = 0; i < data.length; i++) {
            if (data[i] > max) {
                max = data[i];
                result.clear();
                result.add(i);
            } else if (data[i] == max) {
                result.add(i);
            }
        }

        Integer[] arrayResult = new Integer[result.size()];
        result.toArray(arrayResult);
        return arrayResult;
    }

    @Override
    public boolean equals(Object object) {
        if (object instanceof Board) {
            for (int y = 0; y < BOARD_HEIGHT; y++) {
                for (int x = 0; x < BOARD_WIDTH; x++) {
                    if (this.getField(x, y) != ((Board) object).getField(x, y)) {
                        return false;
                    }

                }
            }
            return true;
        } else {
            return false;
        }
    }
}
package rolit.model.game;

import java.util.Objects;

/**
 * De klasse die op een bepaald veld de vector bijhoudt met de slagen die gedaan kunnen worden.
 * @author Martijn de Bijl
 */
public class Capture {
    /**
     * De lengte van de capture.
     */
    private int length;
    /**
     * De richting van een capture, gegeven met een positie die met de x- en y-coördinaten de richting aangeeft.
     */
    private Position direction;

    /**
     * Maakt een niewe capture met een lengte en richting.
     * @param direction de richting van de capture gegeven met een positie met bepaalde coördinaten die de richting
     * aangeven
     * @param length de lengte van de capture
     */
    public Capture(Position direction, int length){
        this.length = length;
        this.direction = direction;
    }

    /**
     * gGeft de lengte terug.
     * @return een integer van de lengte.
     */
    public int getLength(){
        return length;
    }

    /**
     * Geeft de richting terug.
     * @return geeft de richting terug in een positie.
     */
    public Position getDirection(){
        return direction;
    }

    @Override
    public boolean equals(Object object){
      if (object instanceof Capture){
          Capture capture = (Capture)object;
          return (this.getDirection() == ((Capture) object).getDirection() && this.getLength() == ((Capture) object).getLength());
    } else{
          return false;
      }
    }
}
package rolit.model.event;

import rolit.model.networking.server.ClientHandler;

public interface ServerListener {
    public void serverError(String reason);
    public void newClient(ClientHandler handler);
    public void clientError(String reason);
}
package rolit.util;

import java.util.LinkedList;
import java.util.List;

public class Strings {
    public static String join(String delimiter, String[] strings) {
        String result = "";
        boolean first = true;

        for(String string : strings) {
            if(!first) {
                result += delimiter;
            }

            first = false;

            result += string;
        }

        return result;
    }

    public static String[] remove(String[] original, String toBeRemoved) {
        List<String> result = new LinkedList<String>();

        for(String s : original) {
            if(!s.equals(toBeRemoved)) {
                result.add(s);
            }
        }

        String[] stringArray = new String[result.size()];
        result.toArray(stringArray);
        return stringArray;
    }

    public static String[] push(String s, String[] array) {
        String[] result = new String[array.length + 1];

        int i = 0;

        for(String arrayS : array) {
            result[i++] = arrayS;
        }

        result[result.length - 1] = s;

        return result;
    }
}
package rolit.util;

import java.util.HashMap;
import java.util.LinkedHashMap;

public class BiMap<K, V> {
    private HashMap<K, V> forward = new LinkedHashMap<K, V>();
    private HashMap<V, K> backward = new LinkedHashMap<V, K>();

    public void put(K key, V value) {
        forward.put(key, value);
        backward.put(value, key);
    }

    public V get(Object key) {
        return forward.get(key);
    }

    public K getBackward(Object value) {
        return backward.get(value);
    }
}
package rolit.util;

import java.nio.charset.MalformedInputException;
import java.security.*;
import java.security.PublicKey;
import java.security.SecureRandom;
import java.util.Arrays;

/**
 * Created by laurens on 1/21/14.
 */
public class Crypto {
    /**
     * Alle characters van base64 in volgorde.
     */
    private static final String BASE64_CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

    private static final char BASE64_PADDING = '=';

    private static final int NONCE_LENGTH = 256;

    /**
     * Converteert bytes naar een Base64-String. Er is namelijk geen standaardmethode in Java om dit te doen.
     * @param data De bytes
     * @return De String
     */
    public static String base64Encode(byte[] data) {
        String result = "";

        for(int i = 0; i < data.length / 3; i++) {
            int byte1 = (data[i * 3] + 256) % 256,
                    byte2 = (data[i * 3 + 1] + 256) % 256,
                    byte3 = (data[i * 3 + 2] + 256) % 256;

            result += BASE64_CHARS.charAt(byte1 / 4);
            result += BASE64_CHARS.charAt((byte1 % 4) * 16 + byte2 / 16);
            result += BASE64_CHARS.charAt((byte2 % 16) * 4 + byte3 / 64);
            result += BASE64_CHARS.charAt(byte3 % 64);
        }

        if(data.length % 3 == 1) {
            int byte1 = (data[data.length - 1] + 256) % 256;

            result += BASE64_CHARS.charAt(byte1 / 4);
            result += BASE64_CHARS.charAt((byte1 % 4) * 16);
            result += BASE64_PADDING;
            result += BASE64_PADDING;
        } else if(data.length % 3 == 2) {
            int byte1 = (data[data.length - 2] + 256) % 256,
                    byte2 = (data[data.length - 1] + 256) % 256;

            result += BASE64_CHARS.charAt(byte1 / 4);
            result += BASE64_CHARS.charAt((byte1 % 4) * 16 + byte2 / 16);
            result += BASE64_CHARS.charAt((byte2 % 16) * 4);
            result += BASE64_PADDING;
        }

        return result;
    }

    /**
     * Converteert een Bas64-String naar bytes.
     * @param data De String
     * @return De bytes
     */
    public static byte[] base64Decode(String data) {
        byte[] result = new byte[data.length() / 4 * 3];

        for(int i = 0; i < data.length() / 4; i++) {
            char char1 = data.charAt(i * 4), char2 = data.charAt(i * 4 + 1),
                    char3 = data.charAt(i * 4 + 2), char4 = data.charAt(i * 4 + 3);

            boolean char1Valid = BASE64_CHARS.indexOf(char1) != -1 || char1 == BASE64_PADDING;
            boolean char2Valid = BASE64_CHARS.indexOf(char2) != -1 || char2 == BASE64_PADDING;
            boolean char3Valid = BASE64_CHARS.indexOf(char3) != -1 || char3 == BASE64_PADDING;
            boolean char4Valid = BASE64_CHARS.indexOf(char4) != -1 || char4 == BASE64_PADDING;

            if(!(char1Valid && char2Valid && char3Valid && char4Valid)) {
                return null;
            }

            int result1 = BASE64_CHARS.indexOf(char1) * 4 + BASE64_CHARS.indexOf(char2) / 16;
            int result2 = (BASE64_CHARS.indexOf(char2) % 16) * 16 + BASE64_CHARS.indexOf(char3) / 4;
            int result3 = ((BASE64_CHARS.indexOf(char3) + 4) % 4) * 64 + BASE64_CHARS.indexOf(char4);

            result[i * 3] = (byte) (result1 < 128 ? result1 : (result1 - 256));
            result[i * 3 + 1] = (byte) (result2 < 128 ? result2 : (result2 - 256));
            result[i * 3 + 2] = (byte) (result3 < 128 ? result3 : (result3 - 256));
        }

        if(data.charAt(data.length() - 2) == '=') {
            return Arrays.copyOfRange(result, 0, result.length - 2);
        } else if(data.charAt(data.length() - 1) == '=') {
            return Arrays.copyOfRange(result, 0, result.length - 1);
        } else {
            return result;
        }
    }

    public static String getNonce() {
        byte[] bytes = new byte[NONCE_LENGTH];
        SecureRandom random = new SecureRandom();
        random.nextBytes(bytes);
        return base64Encode(bytes);
    }

    public static boolean verify(byte[] cypherText, byte[] original, PublicKey publicKey) {
        try {
            if(cypherText == null || original == null || publicKey == null) {
                return false;
            }

            Signature signature = Signature.getInstance("SHA1withRSA");
            signature.initVerify(publicKey);
            signature.update(original);
            return signature.verify(cypherText);
        } catch (NoSuchAlgorithmException e) {

        } catch (InvalidKeyException e) {

        } catch (SignatureException e) {

        }

        return false;
    }

    public static byte[] sign(byte[] original, PrivateKey privateKey) {
        try {
            Signature signature = Signature.getInstance("SHA1withRSA");
            signature.initSign(privateKey);
            signature.update(original);
            return signature.sign();
        } catch (NoSuchAlgorithmException e) {

        } catch (InvalidKeyException e) {

        } catch (SignatureException e) {

        }

        return null;
    }
}
package rolit.util;

public class Arrays {
    public static <T> boolean contains(T[] array, T element) {
        for(T t : array) {
            if((element == null && t == null) || (element != null && element.equals(t))) {
                return true;
            }
        }

        return false;
    }
}
